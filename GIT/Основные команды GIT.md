## Основные команды

Git может отслеживать файлы проекта только в том случае, когда они помещены под контроль версий. Для этого нужно зайти в директорию проекта и выполнить команду инициализации `git init`.

Проект может быть как новый, так и уже существующий. Процесс инициализации от этого не поменяется:

```
# Создаем новый проект
mkdir hexlet-git

# Переходим в созданную директорию
cd hexlet-git

# Выполняем инициализацию
git init

Initialized empty Git repository in /private/tmp/hexlet-git/.git/
```

Команда `git init` создает репозиторий — директорию _.git_, которая содержит все необходимые для работы Git-файлы.

С помощью команды `git status` можно посмотреть статус репозитория:

```
git status

On branch main
No commits yet
nothing to commit (create/copy files and use "git add" to track)
```

В этом выводе указано, что репозиторий пустой (`No commits yet`) — в нем нет новых или измененных файлов.

Давайте попробуем добавить несколько файлов:

```
# Создаем файл README.md со строкой текста
echo 'Hello, Hexlet!' > README.md
echo 'Haskell Curry' > PEOPLE.md
```

Теперь снова смотрим на статус:

```
git status

# Часть вывода убрана
Untracked files:
  (use "git add <file>..." to include in what will be committed)
    PEOPLE.md
    README.md
```

Git увидел, что в проекте появились новые файлы, о которых ему ничего не известно. Они помечаются как **неотслеживаемые файлы** (_untracked files_).

Git не следит за изменениями в таких файлах, потому что они не добавлены в репозиторий.

Добавление в репозиторий происходит в два шага. Первым шагом выполняем команду подготовки файлов `git add <путь до файла>`:

```
# Для каждого нового или измененного файла
git add README.md
```

Смотрим, что произошло:

```
git status

Changes to be committed:
  (use "git rm --cached <file>..." to unstage)
    new file:   README.md

Untracked files:
  (use "git add <file>..." to include in what will be committed)
    PEOPLE.md
```

Файл _README.md_ теперь находится в состоянии «подготовлен к коммиту» — другими словами, файл **попал в индекс**.

Следующий шаг — это **коммит**. Под этим термином понимается окончательное добавление в репозиторий, когда Git запоминает файл навсегда и следит за всеми последующими изменениями.

Во время коммита мы берем все подготовленные изменения (они могут включать любое количество файлов) и отправляем их в репозиторий как единое целое. Вот, как он выполняется:

```
git commit -m 'add README.md'

[main (root-commit) 3c5d976] add README.md
1 file changed, 1 insertion(+)
create mode 100644 README.md
```

Флаг `-m` означает _message_, то есть описание коммита. Коммит можно выполнять и без него, но тогда откроется редактор, в котором нужно будет ввести описание коммита.

Мы рекомендуем делать осмысленные описания — это хороший тон. Пример соглашения по именованию коммитов приведен в дополнительных материалах к уроку.

Перейдем к процессу работы с Git:

![Git workflow](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6IjE0MWY1ZjBjOGRjM2NjZTAyODI2OGI0MjBkNjcxMGFjLmpwZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=589e8d11fa50c42d2cd6e229805d96aa91d19dc0aaba2e2f4b2196de7611da14)

Может возникнуть вопрос: зачем так сложно? Зачем отдельно отправлять файлы в индекс командой `git add`? Почему нельзя добавлять все измененные файлы сразу в коммит?

Как ни странно, такой процесс создан как раз для удобства программистов. Дело в том, что во время разработки может меняться и добавляться много файлов. Но это не значит, что мы хотим добавить все эти изменения в один коммит.

Со смысловой точки зрения, коммит — это какое-то логически завершенное изменение внутри проекта. Его размер бывает очень разным:

- Маленьким, если мы исправляем одну опечатку в одном файле
- Большим, если мы внедряем новую функциональность

Главное в коммите — его **атомарность**. Другими словами, он должен выполнять ровно одну задачу.

Теперь файл _README.md_ находится внутри репозитория. Убедиться в этом можно, запустив команду `git status`:

```
git status

Untracked files:
  (use "git add <file>..." to include in what will be committed)
    PEOPLE.md
```

Команда _git status_ не выводит файлы, которые добавлены в репозиторий и не содержат изменений. При этом сам файл _README.md_ находится внутри директории _hexlet-git_.





### Конфигурация

`git config --global user.name "[name]"` — установить имя, которое будет прикрепляться к коммиту.

`git config --global user.email "[email address]"` — установить email, который будет прикрепляться к коммиту.

### Создание репозиториев

`git init [project-name]` — создать новый локальный репозиторий с заданным именем.

`git clone [url]` — загрузить проект и его полную историю изменений.

### Работа с файлами

`git rm [file]` — удалить файл из рабочей директории и добавить в индекс информацию об удалении.

`git rm --cached [file]` — удалить файл из репозитория, но сохранить его локально.

### Работа с изменениями

`git status` — полный список изменений файлов, ожидающих коммита (`-s` — краткий вид изменений)

`git diff` — показать изменения в файлах, которые еще не были добавлены в индекс коммита (staged).

`git add [file]` — сделать указанный файл готовым для коммита.

`git add .` — сделать все измененные файлы готовыми для коммита.

`git add '*.txt'` — добавить только файлы, соответствующие указанному выражению.

`git diff --staged` — показать что было добавленно в индекс с помощью `git add`, но еще не было закоммиченно.

`git diff HEAD` — показать что изменилось с последнего коммита.

`git diff [branch]` — сравнить текущую ветку с заданной.

`git difftool -d master..` — показать изменения, сделанные в текущей ветке.

`git diff --stat` — показать статистику какие файлы были изменены и как.

`git reset [file]` — убрать файлы из индекса коммита (изменения не теряются).

`git commit` — записать изменения в репозиторий. для написания сообщения откроется назначенный редактор.

`git commit -m "[descriptive message]"` — записать изменения с заданным сообщением.

`git commit --amend` — добавить изменения к последнему коммиту.

### Работа с ветками

`git branch` — список всех локальных веток в текущей директории.

`git branch [branch-name]` — создать новую ветку.

`git checkout [branch-name]` — переключиться на указанную ветку и обновить рабочую директорию.

`git checkout -b <name> <remote>/<branch>` — переключиться на удаленную ветку.

`git checkout [filename]` — вернуть файл в первоначальное состояние если он еще не был добавлен в индекс коммита.

`git merge [branch]` — соединить изменения в текущей ветке с изменениями из заданной.

`git branch -a` — посмотреть полный список локальных и удаленных веток.

`git branch -d [branch]` — удалить заданную ветку.

`git branch -D [branch]` — принудительно удалить заданную ветку, игнорируя ошибки.

`git branch -m <oldname> <newname>` — переименовать ветку.

### Просмотр истории

`git log` — список изменения текущей ветки.

`git log --pretty=format:"%h %s" --graph` — изменение вида отображения истории изменений.

`git log --author='Name' --after={1.week.ago} --pretty=oneline --abbrev-commit` — посмотреть над чем работал заданный пользователь последнюю неделю.

`git log --no-merges master..` — посмотреть историю изменений только для текущей ветки.

`git show [commit]` — показать метадату и изменения в заданном коммите.

`git show [branch]:[file]` — посмотреть на файл в другой ветке, не переключаясь на неё.

### Отмена коммитов

`git reset` — убрать изменения из индекса коммита, сами изменения останутся.

`git reset [commit/tag]` — отменить все коммиты после указанного коммита, изменения будут сохранены локально.

`git reset --hard [commit]` — принудительно вернутся к указанному коммиту, не сохраняя историю и изменения.

### Синхронизация изменений

`git fetch [bookmark]` — загрузить всю историю с заданного удаленного репозитория.

`git push` — запушить текущую ветку в удаленную ветку.

`git push [remote] [branch]` — запушить ветку в указанный репозиторий и удаленную ветку.

`git pull` — загрузить историю и изменения удаленной ветки и произвести слияние с текущей веткой.

`git pull [remote][branch]` — указать конкретную удаленную ветку для слияния.

`git remote` — посмотреть список доступных удаленных репозиториев.

`git remote add [remote][url]` — добавить новый удаленный репозиторий.

#git