

**Представление** — это виртуальная таблица. В отличие от обычных таблиц, содержащих данные, представление содержит запрос, который динамически извлекает данные тогда, когда это необходимо. Представления можно использовать точно так же, как и обычные таблицы: извлекать данные из них, фильтровать и сортировать, объединять с другими таблицами или представлениями.

Представления не содержат фактических данных, они извлекают их из других таблиц. Поэтому, если данные этих таблиц изменятся, изменится и содержимое связанных с ними представлений.

## Создание представлений

Для создания представлений используется оператор `CREATE VIEW`, синтаксис которого имеет следующий вид:

```sql
CREATE VIEW <имя представления> AS
<извлекающий запрос>
```

Несложно заметить, что создание представления выполняется достаточно просто. Фактически от нас требуется лишь написать запрос, который определенным образом извлекает из таблиц базы данных нужную информацию, а также дать этому запросу имя.

Представления, как и таблицы, должны иметь уникальные имена. Они не могут быть названы так же, как другие таблицы или представления.

В качестве примера напишем запрос, создающий представление `FirstBooks`, которое включает информацию о первых трех книгах.

Результатом приведенного ниже запроса:

```sql
CREATE VIEW FirstBooks AS
SELECT *
FROM Books
LIMIT 3;

SELECT *
FROM FirstBooks;
```

является:

```no-highlight
+----+------------------------+--------------+-----------+
| id | title                  | release_year | author_id |
+----+------------------------+--------------+-----------+
| 1  | The Shining            | 1977         | 1         |
| 2  | Fight Club             | 1996         | 2         |
| 3  | The Catcher in the Rye | 1951         | 3         |
+----+------------------------+--------------+-----------+
```

Запрос выше начинается с создания представления, которому дается имя `FirstBooks`, затем указывается содержимое этого представления — три первые записи таблицы `Books`. Завершается запрос извлечением всей информации, находящейся в представлении `FirstBooks`.

Несмотря на то, что представление в контексте запроса ведет себя как обычная таблица, оно на самом деле таковым не является. Каждое обращение к представлению приводит к выполнению соответствующего запроса.

Если в базе данных содержится некоторое представление, то при попытке создать представление с таким же именем произойдет ошибка. Чтобы ее избежать, можно воспользоваться расширенным оператором `CREATE OR REPLACE VIEW`. Данный оператор создаст представление только в том случае, если оно еще не существует. Если же представление с создаваемым именем существует, оно будет заменено новым.

 Результатом приведенного ниже запроса:

```sql
CREATE VIEW FirstBooks AS
SELECT *
FROM Books
LIMIT 3;

CREATE OR REPLACE VIEW FirstBooks AS
SELECT *
FROM Books
LIMIT 5;

SELECT *
FROM FirstBooks;
```

является:

```no-highlight
+----+------------------------+--------------+-----------+
| id | title                  | release_year | author_id |
+----+------------------------+--------------+-----------+
| 1  | The Shining            | 1977         | 1         |
| 2  | Fight Club             | 1996         | 2         |
| 3  | The Catcher in the Rye | 1951         | 3         |
| 4  | The Green Mile         | 1996         | 1         |
| 5  | Haunted                | 2005         | 2         |
+----+------------------------+--------------+-----------+
```

В данном примере сначала создается представление `FirstBooks`, которое включает три первые записи таблицы `Books`. Затем создается представление с тем же именем, которое включает пять первых записей таблицы `Books`. Второе создание представления `FirstBooks` выполняется с помощью оператора `CREATE OR REPLACE VIEW`, поэтому оно приводит не к ошибке, а к тому, что новое представление заменяет старое.

 При определении представления нельзя использовать подзапрос в блоке оператора `FROM`.

### Представления для упрощения запросов

Представления удобно использовать в том случае, когда из базы данных постоянно нужно извлекать одни и те же данные. Предположим, нам чаще всего приходится работать с информацией о книгах автора `Stephen King`. Это может быть получение названия самой поздней книги писателя или названий всех его книг в порядке их выпуска.

Очевидно, что все такие запросы будут иметь один общий фрагмент, в котором из таблицы `Books` извлекаются данные о книгах автора `Stephen King`:

```sql
SELECT title, release_year
FROM Books INNER JOIN Authors ON Books.author_id = Authors.id
WHERE Authors.name = 'Stephen' and Authors.surname = 'King';
```

С помощью оператора `CREATE VIEW` мы можем преобразовать его в представление, скажем, с именем `StephenKingBooks`, чтобы в дальнейшем, вместо этого не самого маленького запроса, использовать одно говорящее имя.

Результатом приведенного ниже запроса:

```sql
CREATE VIEW StephenKingBooks AS
SELECT title, release_year
FROM Books INNER JOIN Authors ON Books.author_id = Authors.id
WHERE Authors.name = 'Stephen' and surname = 'King';

SELECT *
FROM StephenKingBooks
ORDER BY release_year;
```

является:

```no-highlight
+-------------------+--------------+
| title             | release_year |
+-------------------+--------------+
| The Shining       | 1977         |
| Dolores Claiborne | 1993         |
| The Green Mile    | 1996         |
| The Outsider      | 2018         |
+-------------------+--------------+
```

В примере выше извлекается информация о всех книгах автора `Stephen King` с дополнительной сортировкой по дате выхода, однако не напрямую из таблицы `Books`, а из представления `StephenKingBooks`, которое как раз и содержит все необходимые данные.

Результатом приведенного ниже запроса:

```sql
CREATE VIEW StephenKingBooks AS
SELECT title, release_year
FROM Books INNER JOIN Authors ON Books.author_id = Authors.id
WHERE Authors.name = 'Stephen' and Authors.surname = 'King';

SELECT *
FROM StephenKingBooks
ORDER BY release_year DESC
LIMIT 1;
```

является:

```no-highlight
+--------------+--------------+
| title        | release_year |
+--------------+--------------+
| The Outsider | 2018         |
+--------------+--------------+
```

Здесь из представления `StephenKingBooks` извлекается название самой поздней книги, написанной автором `Stephen King`.

### Представления для форматирования данных

Представления могут быть полезны при частой необходимости извлекать данные в определенном формате. Например, в таблице `Books` информация об авторах книг не хранится в явном виде — указываются лишь их идентификаторы. Однако нам нередко может требоваться таблица, которая содержит как названия книг, так и их авторов. Для этого мы можем создать соответствующее представление и пользоваться им при необходимости получить данные в требуемом формате.

Результатом приведенного ниже запроса:

```sql
CREATE VIEW BooksInfo AS
SELECT title,
       CONCAT(Authors.name, ' ', Authors.surname) AS author
FROM Books INNER JOIN Authors ON Books.author_id = Authors.id;

SELECT *
FROM BooksInfo;
```

является:

```no-highlight
+------------------------+-----------------+
| title                  | author          |
+------------------------+-----------------+
| The Shining            | Stephen King    |
| Fight Club             | Chuck Palahniuk |
| The Catcher in the Rye | Jerome Salinger |
| The Green Mile         | Stephen King    |
| Haunted                | Chuck Palahniuk |
| The Outsider           | Stephen King    |
| Lullaby                | Chuck Palahniuk |
| Franny and Zooey       | Jerome Salinger |
| Invisible Monsters     | Chuck Palahniuk |
| Dolores Claiborne      | Stephen King    |
+------------------------+-----------------+
```

Запрос выше создает представление `BooksInfo`, которое объединяет содержимое таблиц `Books` и `Authors`, беря из первой таблицы название книги, а из второй — информацию об авторе этой книги.

## Изменение представлений

Запрос, который используется в представлении, может быть изменен. Для этого используется оператор `ALTER VIEW`, синтаксис которого имеет следующий вид:

```sql
ALTER VIEW <имя представления> AS
<новый извлекающий запрос>
```

В качестве примера использования данного оператора напишем запрос, создающий представление `FirstBooks`, которое включает три первые записи таблицы `Books`, а затем изменяющий созданное представление таким образом, чтобы оно включало пять первых записей.

Результатом приведенного ниже запроса:

```sql
CREATE VIEW FirstBooks AS
SELECT *
FROM Books
LIMIT 3;

ALTER VIEW FirstBooks AS
SELECT *
FROM Books
LIMIT 5;

SELECT *
FROM FirstBooks;
```

является: 

```no-highlight
+----+------------------------+--------------+-----------+
| id | title                  | release_year | author_id |
+----+------------------------+--------------+-----------+
| 1  | The Shining            | 1977         | 1         |
| 2  | Fight Club             | 1996         | 2         |
| 3  | The Catcher in the Rye | 1951         | 3         |
| 4  | The Green Mile         | 1996         | 1         |
| 5  | Haunted                | 2005         | 2         |
+----+------------------------+--------------+-----------+
```

## Удаление представлений

Представление может быть удалено. Для этого используется оператор `DROP VIEW`, синтаксис которого имеет следующий вид:

```sql
DROP VIEW <имя представления>
```

Предположим, в нашей базе данных содержится представление `FirstBooks` и мы хотим его удалить. Тогда запрос, выполняющий такую операцию, будет выглядеть следующим образом:

```sql
DROP VIEW FirstBooks;
```

При попытке удалить несуществующее представление произойдет ошибка. Если после оператора `DROP VIEW` указать ключевые слова `IF EXISTS`, удаление будет выполнено только в том случае, если представление существует.

 Определить названия полей виртуальной таблицы можно не только в самом запросе с помощью псевдонимов, но и путем указания этих имен в скобках через запятую после названия представления.

Результатом приведенного ниже запроса:

```
CREATE VIEW BooksInfo (bookname, writer) AS
SELECT title,
       CONCAT(Authors.name, ' ', Authors.surname)
FROM Books INNER JOIN Authors ON Books.author_id = Authors.id;

SELECT *
FROM BooksInfo;
```

является:

```no-highlight
+------------------------+-----------------+
| bookname               | writer          |
+------------------------+-----------------+
| The Shining            | Stephen King    |
| Fight Club             | Chuck Palahniuk |
| The Catcher in the Rye | Jerome Salinger |
| The Green Mile         | Stephen King    |
| Haunted                | Chuck Palahniuk |
| The Outsider           | Stephen King    |
| Lullaby                | Chuck Palahniuk |
| Franny and Zooey       | Jerome Salinger |
| Invisible Monsters     | Chuck Palahniuk |
| Dolores Claiborne      | Stephen King    |
+------------------------+-----------------+
```

 Представления могут быть вложенными. Это означает, что представление может быть создано посредством запроса, который извлекает данные из другого представления.

 Представления предназначены для извлечения данных, а не изменения, поэтому в большинстве случаев они являются неизменяемыми, и при попытке применить к представлениям операторы `INSERT, UPDATE` или `DELETE` произойдет ошибка. Однако если представление извлекает данные из единственной таблицы, причем извлекает их полностью, то такое представление изменить можно. Но важно понимать, что само представление не содержит никаких данных, поэтому все изменения будут применены к той таблице, с которой связано представление.

 С помощью представлений можно ограничивать доступ к данным, предоставляя пользователю или приложению права не на таблицу, а на представление. Также представления могут использоваться для обеспечения интерфейса обратной совместимости: если структура таблицы, с которой работало приложение, изменилась, с помощью представления можно смоделировать ее прежний вид.

 Несмотря на то, что операторы `ALTER VIEW` и `CREATE OR REPLACE VIEW` похожи, между ними есть важное отличие. Оператор `ALTER VIEW` изменяет существующее представление и завершается с ошибкой, если оно **не** существует. Оператор `CREATE OR REPLACE VIEW` создает новое представление, удаляя старое, если оно существует.