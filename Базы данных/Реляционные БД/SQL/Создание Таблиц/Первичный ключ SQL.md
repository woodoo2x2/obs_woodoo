## Первичный ключ

В реляционной модели баз данных первичный ключ играет очень важную роль и является неотъемлемой частью практически любой таблицы. Чтобы поле могло быть первичным ключом, оно должно обладать двумя свойствами:

- поле не должно содержать значение `NULL`
- поле не должно содержать повторяющиеся значения

Таким образом, чтобы при создании таблицы определить какое-либо ее поле как первичный ключ, мы можем воспользоваться сочетанием ограничений `NOT NULL` и `UNIQUE`, которые как раз и будут гарантировать, что поле содержит лишь уникальные непустые значения. Однако данный способ не достаточно нагляден, а также не позволяет определить первичный ключ, включающий несколько полей. Поэтому в SQL для определения первичного ключа таблицы существует отдельное ограничение — `PRIMARY KEY`.

В качестве примера использования данного ограничения создадим таблицу `Books`, предназначенную для хранения информации о различных книгах. Она будет включать три следующих поля:

- `id` — целочисленное поле, содержащее уникальный непустой идентификатор книги
- `title` — строковое поле, содержащее название книги
- `author` — строковое поле, содержащее автора книги

Теперь рассмотрим запрос, создающий предложенную таблицу. Он выглядит следующим образом:

```sql
CREATE TABLE Books
(
    id     INT PRIMARY KEY,
    title  VARCHAR(40),
    author VARCHAR(40)
)
```

В таблице `Books` ограничение `PRIMARY KEY` применено к полю `id`, то есть это поле является первичным ключом. Теперь при попытке добавить в данную таблицу запись, значение поля `id` которой равняется `NULL` или не является уникальным в рамках этого поля, произойдет ошибка.

Например, результатом приведенного ниже запроса:

```sql
CREATE TABLE Books
(
    id     INT PRIMARY KEY,
    title  VARCHAR(40),
    author VARCHAR(40)
);

INSERT INTO Books (id, title, author)
VALUES (NULL, 'It', 'Stephen King');
```

является ошибка:

```no-highlight
ERROR 1048: Column 'id' cannot be null
```

Аналогичное поведение будет наблюдаться при попытке изменить значение поля `id` уже имеющейся записи на `NULL` или на значение, которое не является уникальным в рамках этого поля.

Например, результатом приведенного ниже запроса:

```sql
CREATE TABLE Books
(
    id     INT PRIMARY KEY,
    title  VARCHAR(40),
    author VARCHAR(40)
);

INSERT INTO Books (id, title, author)
VALUES (1, 'It', 'Stephen King'),
       (2, 'Heart of Darkness', 'Joseph Conrad');

UPDATE Books
SET id = 1
WHERE id = 2;
```

является ошибка:

```no-highlight
ERROR 1062: Duplicate entry '1' for key 'Books.PRIMARY'
```

### Составной первичный ключ

Ограничение `PRIMARY KEY` может быть указано в определении лишь одного поля, поэтому при необходимости задать первичный ключ, включающий два и более полей, нужно использовать несколько иной синтаксис.

Предположим, что мы решили сменить структуру предложенной в начале урока таблицы `Books` и отказаться от поля `id`, а в качестве первичного ключа принять сочетание полей `title` и `author`. Тогда запрос, создающий таблицу, будет выглядеть следующим образом:

```sql
CREATE TABLE Books
(
    title  VARCHAR(40),
    author VARCHAR(40),
    PRIMARY KEY (title, author)
);
```

В примере выше видно, что если первичный ключ является составным, то его определение нужно вынести в отдельное определение поля, в котором следует сначала указать ограничение `PRIMARY KEY`, а затем в скобках перечислить все поля, составляющие первичный ключ.

### Автоматическое заполнение

Нередко первичный ключ таблицы представляет собой целочисленное поле, содержащее последовательные значения, начиная с `1`. С первичным ключом подобного формата обычно сочетают ограничение `AUTO_INCREMENT`, которое используется для автоматического заполнения поля рядом натуральных чисел. Другими словами, при добавлении записи в таблицу значение такого поля указывать не обязательно, для первой записи автоматически будет принято число `1`, для второй — `2`, и так далее.

Ограничение `AUTO_INCREMENT` может быть указано в определении лишь одного поля, причем это поле должно быть первичным ключом. Также ограничение `AUTO_INCREMENT` не сочетается с ограничением `DEFAULT`.

В качестве примера расширим определение предложенной в начале урока таблицы `Books` и применим ограничение `AUTO_INCREMENT` к ее полю `id`. Тогда запрос, создающий таблицу, будет выглядеть следующим образом:

```sql
CREATE TABLE Books
(
    id     INT PRIMARY KEY AUTO_INCREMENT,
    title  VARCHAR(40),
    author VARCHAR(40)
);
```

Теперь при добавлении записи в таблицу `Books` значение поля `id` можно не указывать, оно само примет нужное последовательное значение.

После выполнения приведенного ниже запроса:

```sql
CREATE TABLE Books
(
    id     INT PRIMARY KEY AUTO_INCREMENT,
    title  VARCHAR(40),
    author VARCHAR(40)
);

INSERT INTO Books (title, author)
VALUES ('It', 'Stephen King'),
       ('Heart of Darkness', 'Joseph Conrad'),
       ('War and Peace', 'Leo Tolstoy');
```

таблица `Books` будет иметь вид:

```no-highlight
+----+-------------------+---------------+
| id | title             | author        |
+----+-------------------+---------------+
| 1  | It                | Stephen King  |
| 2  | Heart of Darkness | Joseph Conrad |
| 3  | War and Peace     | Leo Tolstoy   |
+----+-------------------+---------------+
```

Важно заметить, что ограничение `AUTO_INCREMENT` определяет значение поля `id`, основываясь лишь на очередности добавления записи. Например, третья по счету добавляемая запись в качестве значения поля `id` примет число `3` даже в том случае, если какие-либо добавленные ранее записи были удалены.

После выполнения приведенного ниже запроса:

```sql
CREATE TABLE Books
(
    id     INT PRIMARY KEY AUTO_INCREMENT,
    title  VARCHAR(40),
    author VARCHAR(40)
);

INSERT INTO Books (title, author)
VALUES ('It', 'Stephen King'),
       ('Heart of Darkness', 'Joseph Conrad');

DELETE FROM Books;
  
INSERT INTO Books (title, author)
VALUES ('War and Peace', 'Leo Tolstoy');
```

таблица `Books` будет иметь вид:

```no-highlight
+----+---------------+-------------+
| id | title         | author      |
+----+---------------+-------------+
| 3  | War and Peace | Leo Tolstoy |
+----+---------------+-------------+
```

В данном примере в таблицу добавляются две записи, которые в качестве значения поля `id` принимают числа `1` и `2` соответственно. Затем обе добавленные записи удаляются и добавляется третья запись, которая в качестве значения поля `id` принимает число `3`, а не `1`, несмотря на то что таблица не содержит ни одной записи.

Исключением является очистка таблицы с помощью оператора `TRUNCATE`. При его использовании счетчик ограничения `AUTO_INCREMENT` сбрасывается до `1`.

После выполнения приведенного ниже запроса:

```sql
CREATE TABLE Books
(
    id     INT PRIMARY KEY AUTO_INCREMENT,
    title  VARCHAR(40),
    author VARCHAR(40)
);

INSERT INTO Books (title, author)
VALUES ('It', 'Stephen King'),
       ('Heart of Darkness', 'Joseph Conrad');

TRUNCATE Books;
  
INSERT INTO Books (title, author)
VALUES ('War and Peace', 'Leo Tolstoy');
```

таблица `Books` будет иметь вид:

```no-highlight
+----+---------------+-------------+
| id | title         | author      |
+----+---------------+-------------+
| 1  | War and Peace | Leo Tolstoy |
+----+---------------+-------------+
```

#sql