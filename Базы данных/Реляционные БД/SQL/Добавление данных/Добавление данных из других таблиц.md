редположим, в нашей базе данных появилась дополнительная таблица под названием `NewBooks`, которая хранит информацию о двух различных книгах и имеет следующий вид:

```no-highlight
+----+-------------------+-----------------+-------+
| id | title             | author          | price |
+----+-------------------+-----------------+-------+
| 6  | Animal Farm       | George Orwell   | 9.99  |
| 7  | Lord of the Flies | William Golding | 5.99  |
+----+-------------------+-----------------+-------+
```


Если нам требуется перенести эту информацию в основную таблицу `Books`, то сделать это можно сочетанием операторов `INSERT` и `SELECT` путем извлечения данных из таблицы `NewBooks` с последующим их добавлением в таблицу `Books`.

После выполнения приведенного ниже запроса:

```sql
INSERT INTO Books (id, title, author, price)
SELECT id, title, author, price
FROM NewBooks;
```

таблица `Books` будет иметь вид:

```no-highlight
+----+------------------------+-----------------+-------+
| id | title                  | author          | price |
+----+------------------------+-----------------+-------+
| 1  | The Shining            | Stephen King    | 7.99  |
| 2  | Fight Club             | Chuck Palahniuk | 9.99  |
| 3  | The Catcher in the Rye | J.D. Salinger   | 3.49  |
| 4  | The Green Mile         | Stephen King    | 15.99 |
| 5  | Haunted                | Chuck Palahniuk | 13.99 |
| 6  | Animal Farm            | George Orwell   | 9.99  |
| 7  | Lord of the Flies      | William Golding | 5.99  |
+----+------------------------+-----------------+-------+
```

В данном примере сначала выполняется извлекающий запрос, который возвращает все записи таблицы `NewBooks`. Затем каждая запись добавляется в таблицу `Books`. Важно заметить, что извлекающий запрос должен возвращать таблицу, количество полей которой совпадает с количеством имен полей, указанных после оператора `INSERT`, причем названия полей в возвращаемой извлекающим запросом таблице значения не имеют, так как их сопоставление происходит лишь с учетом порядка.
Извлекающий запрос, используемый при добавлении данных из других таблиц, является полноценным запросом, поэтому может иметь произвольную сложность.

Можно заметить, что в таблице `NewBooks` идентификаторы книг имеют значения `6` и `7`. Сделано это для того, чтобы при переносе записей из таблицы `NewBooks` в таблицу `Books` не возникало совпадений между значениями поля `id`, поскольку оно является первичным ключом.

Однако на практике первичные ключи могут и будут совпадать, поэтому теперь рассмотрим задачу несколько сложнее, при которой идентификаторы книг в таблице `NewBooks` имеют более привычные значения `1` и `2`:

```no-highlight
+----+-------------------+-----------------+-------+
| id | title             | author          | price |
+----+-------------------+-----------------+-------+
| 1  | Animal Farm       | George Orwell   | 9.99  |
| 2  | Lord of the Flies | William Golding | 5.99  |
+----+-------------------+-----------------+-------+
```

Если мы вновь попытаемся перенести данные с помощью предыдущего запроса, то столкнемся с ошибкой, поскольку произойдет попытка добавить в таблицу `Books` запись, идентификатор которой совпадает с идентификатором уже имеющейся в таблице записи.

Результатом приведенного ниже запроса:

```sql
INSERT INTO Books (id, title, author, price)
SELECT id, title, author, price
FROM NewBooks;
```

является ошибка:

```no-highlight
ERROR 1062: Duplicate entry '1' for key 'Books.PRIMARY'
```

Для решения данной задачи нам необходимо для каждой добавляемой записи определять новое значение поля `id`. Несложно догадаться, что таким значением является сумма максимального значения поля `id` таблицы `Books` и текущего значения поля `id` добавляемой записи. Максимальное значение поля `id` таблицы `Books` мы можем вычислить с помощью подзапроса, а текущее значение поля `id` добавляемой записи нам доступно и так.

После выполнения приведенного ниже запроса:

```sql
INSERT INTO Books (id, title, author, price)
SELECT (SELECT MAX(id)
        FROM Books) + NewBooks.id,
        title, author, price
FROM NewBooks;
```

таблица `Books` будет иметь вид:

```no-highlight
+----+------------------------+-----------------+-------+
| id | title                  | author          | price |
+----+------------------------+-----------------+-------+
| 1  | The Shining            | Stephen King    | 7.99  |
| 2  | Fight Club             | Chuck Palahniuk | 9.99  |
| 3  | The Catcher in the Rye | J.D. Salinger   | 3.49  |
| 4  | The Green Mile         | Stephen King    | 15.99 |
| 5  | Haunted                | Chuck Palahniuk | 13.99 |
| 6  | Animal Farm            | George Orwell   | 9.99  |
| 7  | Lord of the Flies      | William Golding | 5.99  |
+----+------------------------+-----------------+-------+
```

Здесь, например, первая добавляемая запись в качестве нового значения поля `id` имеет число `6`, поскольку максимальным значением поля `id` таблицы `Books` является число `5`, а текущим значением поля `id` добавляемой записи является число `1`.

Следует заметить, что пример выше является учебным, и на практике явно работать со значениями первичного ключа и следить за их уникальностью обычно не нужно, поскольку подобным может заниматься сама СУБД. Чаще всего поле, являющееся первичным ключом, определяют как целочисленное и самозаполняющееся. При добавлении первой записи значение такого поля автоматически принимается равным `1`, при добавлении второй записи — `2`, и так далее. Подробнее об этом будет рассказано в следующем модуле, посвященном созданию таблиц.