Несмотря на то что некоррелированный подзапрос является достаточно мощным инструментом, он может справиться не с любой задачей. Предположим, нам требуется написать запрос, извлекающий данные о книгах, пользовательская оценка которых больше, чем у предыдущей книги в таблице, то есть у книги с идентификатором на один меньше.

Схематически необходимый запрос мы можем показать следующим образом:

```sql
SELECT title, user_score
FROM Books
WHERE user_score > <оценка предыдущей книги>;
```

Проблема данной задачи заключается в том, что для ее решения нам необходимо, чтобы для каждой записи справа от знака `>` располагалось соответствующее именно ей значение (оценка книги с идентификатором на один меньше), а не какое-либо фиксированное значение.

Реализовать это можно с помощью **коррелированного** подзапроса. Он используется в том случае, когда для каждой записи, анализируемой основным запросом, подзапрос должен вернуть результат, зависящий от значений в этой записи. Иными словами, коррелированный подзапрос отвечает на вопрос, ответ на который зависит от обрабатываемой основным запросом записи.

С применением коррелированного подзапроса мы можем показать необходимый нам запрос более точно, однако по-прежнему схематически:

```sql
SELECT title, user_score
FROM Books
WHERE user_score > (SELECT user_score
                    FROM Books
                    WHERE <поле id внутренней таблицы> = <поле id внешней таблицы> - 1);
```

Проблема, возникающая на данном этапе проектирования запроса, связана с именованием полей. Поскольку коррелированный подзапрос, помимо значений полей собственной таблицы, использует значения полей таблицы, принадлежащей основному запросу, должна быть возможность различать эти поля, если они имеют одинаковые названия.

Для этого при обращении к полю явно указывают название таблицы, например, `Books.id` (поле `id` таблицы `Books`). Если и основной запрос, и подзапрос обращаются к одной и той же таблице, то одной из таблиц дают псевдоним.

Теперь мы можем показать окончательный вариант необходимого нам запроса:

```sql
SELECT title, user_score
FROM Books
WHERE user_score > (SELECT user_score
                    FROM Books AS InnerBooks
                    WHERE id = Books.id - 1);
```

результатом которого является:

```no-highlight
+------------------------------------------+------------+
| title                                    | user_score |
+------------------------------------------+------------+
| Fight Club                               | 99         |
| The Great Gatsby                         | 87         |
| It                                       | 75         |
| Harry Potter and the Prisoner of Azkaban | 89         |
+------------------------------------------+------------+
```

Итак, основной запрос здесь извлекает записи из таблицы `Books`, а также фильтрует их с помощью подзапроса. Значение подзапроса не вычисляется единожды, а определяется для каждой рассматриваемой основным запросом записи отдельно, поскольку оно напрямую зависит от этой записи.

Например, если основной запрос рассматривает следующую запись:

```no-highlight
+----+------------------------------------------+---------------------+--------------+------------+
| 7  | It                                       | Stephen King        | 39           | 75         |
+----+------------------------------------------+---------------------+--------------+------------+
```

то в подзапросе значение `Books.id` на данный момент равняется `7` и выполнение подзапроса происходит с учетом именно этого значения, вследствие чего подзапросом возвращается таблица, содержащая значение поля `user_score` той записи, значение поля `id` которой равняется `7 - 1 = 6`:

```no-highlight
+------------+
| user_score |
+------------+
| 51         |
+------------+
```

Далее в основном запросе выполняется сравнение значения поля `user_score` рассматриваемой записи со значением, которое вернул подзапрос для этой записи: `75 > 51`. Так как результатом этого сравнения является истина, рассматриваемая запись попадает в результирующую таблицу.

Таким образом, коррелированный подзапрос выполняется для каждой записи отдельно (сперва для первой, затем для второй и так далее) и для каждой записи возвращает результат, полученный на основе ее значений.

Обращение к полю с явным указанием таблицы (например, `Books.id`) является лишь обращением по **полному имени**. Полные имена применяются в тех случаях, когда может возникнуть неопределенность в именовании полей, к примеру, когда поле подзапроса сравнивается с полем основного запроса и эти поля имеют одинаковые имена.

Полными именами можно пользоваться всегда, однако большой нужды в этом нет, поскольку в рамках запроса обращение все равно будет происходить к полям той таблицы, чье имя или псевдоним указаны после ключевого слова `FROM`.

Например, приведенные ниже запросы функционально полностью идентичны:

- ```sql
    SELECT title
    FROM Books;
    ```
    
- ```sql
    SELECT Books.title
    FROM Books;
    ```
    
- ```sql
    SELECT title
    FROM Books AS B;
    ```
    
- ```sql
    SELECT B.title
    FROM Books AS B;
    ```

Если таблице присвоен псевдоним, то и обращение к полям этой таблицы по полному имени должно происходить только с помощью данного псевдонима.

Результатом приведенного ниже запроса:

```sql
SELECT B.title
FROM Books AS B
WHERE B.author = 'J.R.R. Tolkien';
```

является:

```no-highlight
+-----------------------+
| title                 |
+-----------------------+
| The Lord of the Rings |
| The Silmarillion      |
+-----------------------+
```

Попытка обратиться к полям таблицы по полному имени с использованием ее исходного имени приведет к ошибке.

Результатом приведенного ниже запроса:

```sql
SELECT Books.title
FROM Books AS B
WHERE Books.author = 'J.R.R. Tolkien'
```

является ошибка:

```no-highlight
ERROR 1054: Unknown column 'Books.title' in 'field list'
```

Если подзапрос возвращает таблицу из одного поля и нескольких записей, то помимо сравнения некоторого значения с этой таблицей с помощью ключевых слов `ALL` и `ANY`, можно выполнить проверку на вхождение с помощью оператора `IN`.

К примеру, мы можем написать запрос, извлекающий данные о книгах, оценка критиков которых совпадает с оценкой критиков предыдущей или последней перед предыдущей книги, то есть книги с идентификатором на один или два меньше.

Результатом приведенного ниже запроса:

```sql
SELECT title, critic_score
FROM Books
WHERE critic_score IN (SELECT critic_score
                       FROM Books AS InnerBooks
                       WHERE id = (Books.id - 1) OR id = Books.id - 2);
```

является:

```no-highlight
+------------------------+--------------+
| title                  | critic_score |
+------------------------+--------------+
| The Catcher in the Rye | 99           |
| It                     | 39           |
```