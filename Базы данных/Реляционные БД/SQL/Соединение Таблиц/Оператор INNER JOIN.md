**Первая таблица.** Информация об авторах книг располагается в таблице `Authors`, которая имеет следующий вид:

```no-highlight
+----+-----------------+
| id | author          |
+----+-----------------+
| 1  | Chuck Palahniuk |
| 2  | Stephen King    |
| 3  | John Tolkien    |
+----+-----------------+
```

Первое поле этой таблицы содержит идентификатор автора, второе — имя и фамилию.

**Вторая таблица.** Информация о размещенных в библиотеке книгах располагается в таблице `Books`, которая имеет следующий вид:

```no-highlight
+----+-----------+-----------------------+
| id | author_id | title                 |
+----+-----------+-----------------------+
| 1  | 1         | Fight Club            |
| 2  | 2         | The Green Mile        |
| 3  | 3         | The Lord of the Rings |
| 4  | 2         | It                    |
| 5  | 1         | Haunted               |
+----+-----------+-----------------------+
```

Первое поле этой таблицы содержит идентификатор книги, второе — идентификатор автора, третье — название книги.

**Третья таблица.** Информация о пользователях библиотеки располагается в таблице `Users`, которая имеет следующий вид:

```no-highlight
+----+---------------------+
| id | user                |
+----+---------------------+
| 1  | Keanu Reeves        |
| 2  | Matthew McConaughey |
| 3  | Thomas Hanks        |
| 4  | Bradd Pitt          |
| 5  | Liam Neeson         |
+----+---------------------+
```


В SQL внутреннее соединение выполняется с помощью оператора `INNER JOIN` и ключевого слова `ON`. Сначала указывается первая таблица, затем оператор `INNER JOIN`, а после вторая таблица. Завершается выражение ключевым словом `ON`, после которого располагается условие соединения.

Общий синтаксис внутреннего соединения имеет следующий вид:

```css
<первая таблица> INNER JOIN <вторая таблица> ON <условие соединения>
```

В качестве примера выполним рассмотренное ранее соединение таблиц `Books` и `Authors` с условием `Books.author_id = Authors.id` и извлечем из полученной в результате соединения таблицы все данные.

Результатом приведенного ниже запроса:

```sql
SELECT *
FROM Books INNER JOIN Authors ON Books.author_id = Authors.id;
```

является:

```no-highlight
+----+-----------+-----------------------+----+-----------------+
| id | author_id | title                 | id | author          |
+----+-----------+-----------------------+----+-----------------+
| 1  | 1         | Fight Club            | 1  | Chuck Palahniuk |
| 2  | 2         | The Green Mile        | 2  | Stephen King    |
| 3  | 3         | The Lord of the Rings | 3  | John Tolkien    |
| 4  | 2         | It                    | 2  | Stephen King    |
| 5  | 1         | Haunted               | 1  | Chuck Palahniuk |
+----+-----------+-----------------------+----+-----------------+
```

По сути, связка операторов `INNER JOIN` и `ON` выполняет внутреннее соединение двух таблиц и возвращает полученный результат в виде новой таблицы. Поэтому, указывая после ключевого слова `FROM` выражение, выполняющее соединение таблиц, мы подразумеваем то, что извлечение должно происходить из таблицы, что будет получена в результате соединения.

Запрос, который извлекает данные из таблицы, полученной в результате соединения, называют **многотабличным**.

Таблица, полученная в результате приведенного выше соединения, сопоставляет каждой книге ее автора. Поэтому если мы извлечем из нее лишь поля `title` и `author`, то получим решение задачи, что была предложена в начале урока.

Результатом приведенного ниже запроса:

```sql
SELECT title, author
FROM Books INNER JOIN Authors ON Books.author_id = Authors.id;
```

является:

```no-highlight
+-----------------------+-----------------+
| title                 | author          |
+-----------------------+-----------------+
| Fight Club            | Chuck Palahniuk |
| The Green Mile        | Stephen King    |
| The Lord of the Rings | John Tolkien    |
| It                    | Stephen King    |
| Haunted               | Chuck Palahniuk |
+-----------------------+-----------------+
```

Таблица, получаемая во время соединения таблиц, нередко может включать поля, имеющие одинаковые имена. К примеру, в таблицах `Books` и `Authors` такими полями являются поля с именем `id`. Обращаться к таким полям можно, но только по их полным именам.

Результатом приведенного ниже запроса:

```sql
SELECT Books.id, Authors.id
FROM Books INNER JOIN Authors ON Books.author_id = Authors.id;
```

является:

```no-highlight
+----+----+
| id | id |
+----+----+
| 1  | 1  |
| 2  | 2  |
| 3  | 3  |
| 4  | 2  |
| 5  | 1  |
+----+----+
```

Поскольку таблица, получаемая в результате соединения, это все еще обычная таблица, с ней допустимо выполнять все изученные нами операции: сортировку, фильтрацию и группировку. Например, с помощью фильтрации мы можем получить названия книг лишь определенного автора.

Результатом приведенного ниже запроса:

```sql
SELECT title
FROM Books INNER JOIN Authors ON Books.author_id = Authors.id
WHERE author = 'Chuck Palahniuk';
```

является:

```no-highlight
+------------+
| title      |
+------------+
| Fight Club |
| Haunted    |
+------------+
```

В качестве дополнительного примера выполним соединение таблиц `BooksRental` и `Books` с условием `BooksRental.book_id = Books.id`.

Результатом приведенного ниже запроса:

```sql
SELECT *
FROM BooksRental INNER JOIN Books ON BooksRental.book_id = Books.id;
```

является:

```no-highlight
+----+---------+---------+----+-----------+-----------------------+
| id | book_id | user_id | id | author_id | title                 |
+----+---------+---------+----+-----------+-----------------------+
| 1  | 4       | 1       | 4  | 2         | It                    |
| 2  | 1       | 3       | 1  | 1         | Fight Club            |
| 3  | 2       | 3       | 2  | 2         | The Green Mile        |
| 4  | 4       | 4       | 4  | 2         | It                    |
| 5  | 3       | 1       | 3  | 3         | The Lord of the Rings |
+----+---------+---------+----+-----------+-----------------------+
```

В таблице, полученной в результате данного соединения, каждой арендованной книге сопоставляется ее название. И вновь следует обратить внимание на то, как именно выполняется внутреннее соединение: из таблиц `BooksRental` и `Books` берутся лишь те пары записей, для которых выполняется условие соединения. Например, пятая запись из таблицы `Books` не берется, так как для нее нельзя подобрать запись из таблицы `BooksRental` так, чтобы условие соединения выполнялось.

Используя таблицу, полученную в результате приведенного выше соединения, можно получить названия книг, которые были арендованы хотя бы раз. Для этого достаточно извлечь все уникальные значения поля `title`.

Результатом приведенного ниже запроса:

```sql
SELECT DISTINCT title
FROM BooksRental INNER JOIN Books ON BooksRental.book_id = Books.id;
```

является:

```no-highlight
+-----------------------+
| title                 |
+-----------------------+
| It                    |
| Fight Club            |
| The Green Mile        |
| The Lord of the Rings |
+-----------------------+
```

### Соединение нескольких таблиц

Таблица, полученная в результате соединения, сама может быть соединена с другой таблицей, благодаря чему мы можем выполнять соединение не только двух таблиц, но и большего их количества.

В качестве примера выполним соединение трех таблиц: `BooksRental, Books` и `Users`.

Результатом приведенного ниже запроса:

```sql
SELECT *
FROM BooksRental INNER JOIN Books ON BooksRental.book_id = Books.id
                 INNER JOIN Users ON BooksRental.user_id = Users.id;
```

является:

```no-highlight
+----+---------+---------+----+-----------+-----------------------+----+--------------+
| id | book_id | user_id | id | author_id | title                 | id | user         |
+----+---------+---------+----+-----------+-----------------------+----+--------------+
| 1  | 4       | 1       | 4  | 2         | It                    | 1  | Keanu Reeves |
| 2  | 1       | 3       | 1  | 1         | Fight Club            | 3  | Thomas Hanks |
| 3  | 2       | 3       | 2  | 2         | The Green Mile        | 3  | Thomas Hanks |
| 4  | 4       | 4       | 4  | 2         | It                    | 4  | Bradd Pitt   |
| 5  | 3       | 1       | 3  | 3         | The Lord of the Rings | 1  | Keanu Reeves |
+----+---------+---------+----+-----------+-----------------------+----+--------------+
```

В данном примере выполняется поочередное соединение таблиц `BooksRental, Books` и `Users`: сначала соединяются таблицы `BooksRental` и `Books`, затем полученный результат соединяется с таблицей `Users`. Обратите внимание, что в условии соединения с таблицей `Users` обращение к полю `user_id` происходит по имени первой таблицы — `BooksRental`. Несмотря на то что таблица `Users` соединяется с результатом соединения таблиц `BooksRental` и `Books`, а не с таблицей `BooksRental`, такое обращение корректно.

Используя таблицу, полученную в результате приведенного выше соединения, можно получить информацию о том, какие книги были арендованы каждым пользователем. Для этого достаточно извлечь все значения полей `user` и `title`.

```sql
SELECT user, title
FROM BooksRental INNER JOIN Books ON BooksRental.book_id = Books.id
                 INNER JOIN Users ON BooksRental.user_id = Users.id
ORDER BY user;
```

является:

```no-highlight
+--------------+-----------------------+
| user         | title                 |
+--------------+-----------------------+
| Bradd Pitt   | It                    |
| Keanu Reeves | It                    |
| Keanu Reeves | The Lord of the Rings |
| Thomas Hanks | Fight Club            |
| Thomas Hanks | The Green Mile        |
+--------------+-----------------------+
```

### Самосоединения

Соединять одну таблицу можно не только с другой таблицей, но и с самой собой. Подобное может быть удобно во время работы с таблицей, содержащей рекурсивный внешний ключ.

Предположим, мы имеем таблицу `Staff`, которая хранит информацию о сотрудниках некоторой компании:

```no-highlight
+----+----------------+------------+
| id | staffer        | manager_id |
+----+----------------+------------+
| 1  | Bill Gates     | NULL       |
| 2  | Alan Turing    | 1          |
| 3  | Isaac Newton   | 1          |
| 4  | Edgar Codd     | 2          |
+----+----------------+------------+
```

Первое поле этой таблицы содержит идентификатор сотрудника, второе — имя и фамилию, третье — идентификатор руководителя (также является сотрудником). Если у сотрудника нет руководителя, значением поля `manager_id` является `NULL`.

Закономерной задачей при работе с таблицей `Staff` возникает определение руководителя каждого сотрудника. Решить такую задачу можно, соединив таблицу с самой собой и сопоставив каждой записи из первой таблицы такую запись из второй таблицы, значение поля `id` которой равняется значению поля `manager_id` записи из первой таблицы. Условием соединения в таком случае будет `Staff.id = Staff.manager_id`. Несложно понять, что в таком случае мы сталкиваемся с проблемой именования таблиц, поскольку по условию неясно, какие таблицы имеются в виду (разные или одна и та же), поэтому для однозначного определения таблиц каждой таблице необходимо дополнительно дать псевдоним.

Результатом приведенного ниже запроса:

```sql
SELECT S1.staffer,
       S2.staffer AS manager
FROM Staff AS S1 INNER JOIN Staff AS S2 ON S1.manager_id = S2.id;
```

является:

```no-highlight
+----------------+-------------+
| staffer        | manager     |
+----------------+-------------+
| Alan Turing    | Bill Gates  |
| Isaac Newton   | Bill Gates  |
| Edgar Codd     | Alan Turing |
+----------------+-------------+
```

При выполнении внутреннего соединения порядок таблиц не имеет значения. Если мы соединим первую таблицу со второй или вторую с первой, результат будет равнозначным.

Результатом приведенного ниже запроса:

```sql
SELECT title, author
FROM Books INNER JOIN Authors ON Books.author_id = Authors.id;
```

как и результатом приведенного ниже запроса:

```sql
SELECT title, author
FROM Authors INNER JOIN Books ON Books.author_id = Authors.id;
```

является:

```no-highlight
+-----------------------+-----------------+
| title                 | author          |
+-----------------------+-----------------+
| Fight Club            | Chuck Palahniuk |
| The Green Mile        | Stephen King    |
| The Lord of the Rings | John Tolkien    |
| It                    | Stephen King    |
| Haunted               | Chuck Palahniuk |
+-----------------------+-----------------+
```

Единственная разница заключается, разве что, в порядке полей в таблице, получаемой в результате соединения: сначала следуют все поля первой таблицы, затем — второй.

При использовании оператора `INNER JOIN` ключевое слово `INNER` (в переводе на русский "внутренний") является опциональным и может быть опущено.

Например, приведенные ниже запросы функционально полностью идентичны:

```sql
SELECT *
FROM Books INNER JOIN Authors ON Books.author_id = Authors.id;
```
    
    
```sql
SELECT *
FROM Books JOIN Authors ON Books.author_id = Authors.id;
```



SQL поддерживает дополнительный синтаксис для внутреннего соединения, который имеет следующий вид:

```css
<первая таблица>, <вторая таблица> WHERE <условие соединения>
```

Например, приведенные ниже запросы функционально полностью идентичны:

```sql
    SELECT *
    FROM Books INNER JOIN Authors ON Books.author_id = Authors.id;
    ```
    
 ```sql
    SELECT *
    FROM Books, Authors WHERE Books.author_id = Authors.id;
    ```
    

Внутреннее соединение, выполняемое с помощью данного дополнительного синтаксиса, называют **неявным соединением**. В нынешнее время неявные соединения считаются устаревшими и не рекомендуются для использования, однако они до сих пор могут встречаться в профильной литературе.