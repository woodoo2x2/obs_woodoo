[[Оператор GROUP BY SQL]]
[[Группировка по нескольким полям]]
[[Группировка по вычисляемому полю]]
[[Особенности группировки]]
[[Оператор HAVING (Фильтрация групп)]]
[[Сортировка групп]]
[[Порядок обработки и выполнения операторов]]


 Для оператора `GROUP BY` все значения `NULL` трактуются как равные. Таким образом, при группировке по полю, содержащему значения `NULL`, все такие записи попадут в одну группу.

 Если группировка записей выполняется по вычисляемому полю, причем этому полю присвоен псевдоним, то в операторе `GROUP BY` можно воспользоваться этим псевдонимом.

Результатом приведенного ниже запроса:

```sql
SELECT CONCAT(artist, ', ', album) AS artist_and_album,
       COUNT(*) AS num_of_songs
FROM Songs
GROUP BY artist_and_album;
```

является:

```no-highlight
+--------------------------------------+--------------+
| artist_and_album                     | num_of_songs |
+--------------------------------------+--------------+
| Green Day, American Idiot            | 3            |
| Heart, Dreamboat Annie               | 1            |
| Blondie, No Exit                     | 1            |
| The Smiths, The Queen Is Dead        | 1            |
| The Sounds, Crossing the Rubicon     | 2            |
| Blondie, Pollinator                  | 1            |
| The Sounds, Dying to Say This to You | 1            |
+--------------------------------------+--------------+
```

При фильтрации и сортировке групп также можно пользоваться псевдонимами, если они были присвоены.

Результатом приведенного ниже запроса:

```sql
SELECT artist,
       COUNT(*) AS num_of_songs
FROM Songs
GROUP BY artist
HAVING num_of_songs > 1
ORDER BY num_of_songs;
```

является:

```no-highlight
+------------+--------------+
| artist     | num_of_songs |
+------------+--------------+
| Blondie    | 2            |
| Green Day  | 3            |
| The Sounds | 3            |
+------------+--------------+
```

В запросе выше записи сперва группируются по полю `artist`, а затем фильтруются и сортируются по псевдониму `num_of_songs`, который содержит количество записей в группе.

Если псевдоним вычисляемого поля совпадает с именем какого-либо поля таблицы, группировка и фильтрация будет выполняться именно по значениям поля таблицы.

Результатом приведенного ниже запроса:

```sql
SELECT LEFT(artist, 1) AS artist,
       COUNT(*) AS num_of_artists
FROM Songs
GROUP BY artist
HAVING artist != 'B'
ORDER BY artist;
```

является:

```no-highlight
+--------+----------------+
| artist | num_of_artists |
+--------+----------------+
| B      | 2              |
| G      | 3              |
| H      | 1              |
| T      | 1              |
| T      | 3              |
+--------+----------------+
```

Оператор HAVING достаточно сильно похож на [[Оператор WHERE]], и в действительности все типы фильтраций, выполняемые оператором `WHERE` (сравнения, поиск с помощью метасимволов), также поддерживаются оператором `HAVING`. Единственная разница состоит в том, что `WHERE` фильтрует записи, a `HAVING` — группы.

[[Агрегатные Функции SQL]] позволяют выполнить ряд итоговых вычислений с данными. Например, с помощью [[Функция COUNT() SQL]] мы можем определить количество песен, принадлежащих группе `Green Day`.

Результатом приведенного ниже запроса:

```
SELECT COUNT(*) AS num_of_songs
FROM Songs
WHERE artist = 'Green Day';
```

является:

```no-highlight
+--------------+
| num_of_songs |
+--------------+
| 3            |
+--------------+
```

Аналогичным образом мы можем определить количество песен, принадлежащих какому-либо другому определенному исполнителю. Однако если нам понадобится вычислить количество песен, принадлежащих каждому исполнителю, сделать это лишь с помощью агрегатных функций не выйдет.

Для решения подобной задачи используются **группы**. Группировка дает возможность разделить все данные на логические наборы, благодаря чему становится возможным выполнение итоговых вычислений отдельно по каждой группе.

#sql