В большинстве случаев мы можем напрямую обратиться к нужному элементу и извлечь его данные. Однако иногда нас ждут неожиданные препятствия. Представьте ситуацию, в которой на странице есть два элемента с одинаковым классом, но размещенные в разных родительских элементах. Как нам извлечь конкретный из них?

![](https://ucarecdn.com/9444aa02-5cfe-469c-8e5d-7858516948b9/)

В этом примере оба тега `<p>` имеют одинаковый класс `text`. Для того, чтобы получить тег, родительский элемент которого имеет класс `"author"`, нам и потребуется составной селектор.

Символ пробела (' ') в составном селекторе служит для выбора элементов, которые находятся внутри заданного родителя, независимо от уровня их вложенности. То есть, `.author .text` будет означать поиск элемента с классом `text`, является потомком (на любом уровне вложенности) элемента с классом `author`.

`.author .text` - это означает, что мы ищем тег с классом `text`, родителем которого является тег с классом `author`. Элемент `.text` может находиться на любом уровне вложенности от элемента `.author` и между ними может быть сколько угодно других тегов.  
  
Это утверждение легко проверить. У нас есть структура данных по [ссылке](https://parsinger.ru/2.1/DOM/sostav_selector.html), и `.author .text` найдёт необходимый тег с глубинной вложенности в четыре уровня от родительского элемента `.author`.  
![](https://ucarecdn.com/8559022e-c020-426b-abf7-3c009e87ac7d/)

Или другой пример, где мы хотим извлечь конкретный элемент при помощи составного селектора:

`.container .price_box p` перейдите на этот [сайт](https://parsinger.ru/html/index4_page_1.html) для поиске тега.

![](https://ucarecdn.com/6ba36876-6d5f-4d86-9b0d-89ae865b27d2/)

Как видите, мы получаем все элементы, которые соответствуют критериям поиска. Глубина вложенности селектора может быть любой. В данном примере глубина вложенности равна двум уровням.

**Потомки или дочерние элементы**

"`>`" — символ, который, в отличие от пробела, используется для выбора непосредственных дочерних элементов относительно указанного родительского элемента. В контексте парсинга веб-страниц, это означает, что селектор будет сосредоточен на более узком диапазоне элементов, исключая те, которые находятся на других уровнях вложенности.

`.img_box > .name_item` — данный синтаксис позволяет нам точно определить и выбрать элемент с классом `.name_item`, который является непосредственным дочерним элементом (англ, "child") с классом `.img_box`. В этом случае, `.img_box` выступает в роли родительского элемента (англ,"parent").

![](https://ucarecdn.com/0c9ef32a-8622-4bb2-b31a-5c564cc717e3/)

Можете сами в этом убедится, откройте [сайт](https://parsinger.ru/html/index4_page_1.html) и поэкспериментируйте c `.img_box > .name_item`.

**Поиск по порядковому номеру дочернего элемента**

`#description > li:nth-child(3)` — этот синтаксис чрезвычайно полезен, особенно если вы хотите найти конкретный элемент в списке. Функция `:nth-child()` позволяет выбирать элемент на основе его порядкового номера в списке дочерних элементов. В данном примере мы ищем третий элемент в списке.

Забавный факт: в большинстве языков программирования индексация начинается с 0, но в контексте поиска по HTML-структуре счёт начинается с 1. Это одна из тех мелочей, которую просто необходимо запомнить, чтобы избежать ошибок и неточностей при парсинге.

_[ссылка для поиска](https://parsinger.ru/html/hdd/4/4_1.html)_

![](https://ucarecdn.com/53804089-b499-43ec-afb6-405cea10a686/)

**Использование двух классов и более** 

Предположим, у вас есть HTML-элемент с классами `class1` и `class2`. Если нужно найти элемент, который имеет именно эти два класса, вы можете использовать селектор `.class1.class2` (без пробела между ними).  
 

Это особенно полезно, когда вы сталкиваетесь с более сложными структурами HTML, где одни и те же классы могут использоваться в разных контекстах. С помощью такой комбинации классов вы сможете точнее находить нужные вам теги.

Ключевой момент здесь — отсутствие пробела между именами классов. Это говорит парсеру, что искомый элемент должен иметь оба эти класса одновременно. Стоит это запомнить, чтобы уточнить вашу стратегию парсинга и сделать её максимально эффективной.

`.main.author` - **такой составной селектор используется для поиска элемента с двойным классом.** 

![](https://ucarecdn.com/074b813f-3019-4c01-9de6-0b67cb41b28c/)

Если классов будет больше, чем мы указали в составном селекторе, то элемент будет найден.

![](https://ucarecdn.com/f08eedad-d00e-42fb-a88e-22f851d52e44/)

_(этот пример не сработает на сайте тренажёре, он размещён тут для наглядности.)_

Искомый элемент обладает пятью классами: `**row** **user user-top nav-bottom margin-bottom**`, мы можем локализовать этот элемент, используя всего лишь два из этих классов. Например, `.user.nav-bottom` (без пробела между ними) позволит нам найти данный элемент.
#ПарсингPython 