Smalltalk (\[ˈsmɔːltɔːk]) — объектно-ориентированный язык программирования с динамической типизацией, основанный на идее посылки сообщений, разработанный в Xerox PARC Аланом Кэем, Дэном Ингаллсом, Тедом Кэглером, Адель Голдберг, и другими в 1970-х годах. Представляет собой интегрированную среду разработки и исполнения, объекты которой доступны для модификации через неё саму, и программирование в которой в итоге сводится к модификации её собственного поведения. Язык был представлен как Smalltalk-80.

Smalltalk является одним из многих объектно-ориентированных языков, основанных на языке Симула, который сам оказал большое влияние на развитие таких объектно-ориентированных языков, как: Objective-C, Actor, Java, Erlang, Groovy, Ruby и многих других. Многие идеи 1980-х и 1990-х по написанию программ появились в сообществе Smalltalk. К ним можно отнести рефакторинг, шаблоны проектирования (применительно к ПО), карты «класс — обязанности — взаимодействие» и экстремальное программирование в целом. Основатель концепции вики Уорд Каннингем также входит в сообщество Smalltalk. 

Основные идеи

Основными идеями Smalltalk являются:

    Всё — объекты, и всё их взаимодействие — через посылку сообщений. Строки, целые числа, логические значения, определения классов, блоки кода, стеки, память, составляющие самой интегрированной среды разработки и исполнения — всё представляется в виде объектов. У объектов есть методы и состояние. Любому объекту может быть послано любое сообщение. При отправке сообщения среда исполнения всегда ищет у объекта-получателя подходящий метод и выполняет его, а если не находит — выполняет у объекта-получателя специальный метод для неопознанных сообщений. Объект-получатель сам определяет, является ли полученное сообщение правильным, и что надо сделать, чтобы его обработать.
    Всё доступно для изменения. Если вы хотите изменить саму интегрированную среду разработки и исполнения, вы можете сделать это в работающей системе, без остановки, перекомпиляции и перезапуска. Если вам необходима в языке новая управляющая конструкция языка, вы можете добавить её. В некоторых реализациях вы можете также изменить синтаксис языка или способ работы сборщика мусора.
    Динамическая типизация — это означает, что вы не указываете типы переменных в программе, что делает язык гораздо лаконичней (как объяснено выше, является ли операция правильной, определяет объект-получатель, а не компилятор).

Smalltalk также использует другие современные идеи:

    Сборка мусора встроена в язык и незаметна разработчику.
    Dynamic translation: современные коммерческие виртуальные машины компилируют байткоды в машинные коды для быстрого выполнения.
    Выполнение кода в виртуальной машине. Программы Smalltalk обычно компилируются в байткоды и выполняются виртуальной машиной, что позволяет выполнять их на любом оборудовании, для которого существует виртуальная машина.

Одной из особенностей Smalltalk является то, что даже такие традиционные конструкции, как if-then-else, for, while, и т. д. не являются частью языка. Все они реализованы с помощью объектов. Например, решение принимается с помощью посылки сообщения ifTrue: логическому объекту, и передаёт управление фрагменту текста, если логическое значение истинно.

Собственно встроенных синтаксических конструкций в языке немного:

    посылка сообщения объекту с возможной передачей ему других объектов;
    присваивание объекта переменной;
    возвращение объекта из метода;

и несколько синтаксических конструкций для определения объектов-литералов и временных переменных.

Аналогом механизма обмена сообщениями Smalltalk является сеть интернет: можно представить каждый объект как веб-сервер, отвечающий на запросы. При этом, сервер на запросы может просто выдавать заранее предопределённый ответ, например веб-страницу, расположенную по определённому пути; может перенаправить запрос-сообщение другому объекту, аналог — прокси-сервер; может изменить запрос по определённым правилам, аналог — техника url rewriting, и конечно же, может сформировать абсолютно новую страницу, соответствующую данным, переданным с сообщением. Если для реакции на сообщение у объекта нет предопределённого метода, то среда вызывает у получателя метод \#doesNotUnderstand:, так же, как веб-сервер возвращает страницу с сообщением об ошибке, если задан несуществующий путь к веб-странице.

Краткий обзор синтаксических элементов:

Отдельно стоящей парой символов | окружается список имён переменных, которые будут временными. Символ : при передаче сообщения ставится после имени сообщения или его аргумента, перед передаваемым с ним значением, а символы [ и ] ограничивают блок команд, а точнее — литерал анонимной функции. Но их можно, для начала, воспринимать их как аналог фигурных скобок { и } в Си-подобных языках. В начале такой анонимной функции до символа | можно перечислить требуемые ею аргументы. Её результатом будет последнее вычисленное ею выражение. Символ . завершает отдельную команду, символ ; — разделяет сообщения, которые нужно последовательно передать одному и тому же объекту. Пара символов := обозначает присваивание в переменную, имя которой расположено перед ней, объекта-литерала или объекта-ответа на сообщение, расположенного после неё.

Следующий пример, показывающий нахождение гласных в строке, иллюстрирует стиль Smalltalk.

| aString vowels |
aString := 'This is a string'.
vowels := aString select: [:aCharacter | aCharacter isVowel].

В последней строке примера объекту-строке посылается сообщение select: с аргументом — анонимным блоком кода, принимающим один аргумент, и возвращающим то, что вернёт обработчик события isVowel переданного этим аргументом объекта. При обработке сообщения select вызывается метод select: из класса Collection (одного из предков класса String, к которому относится объект, создаваемый строковым литералом во второй строке примера). Текст этого метода показан ниже:

select: aBlock
| newCollection |
newCollection := self species new.
self do: [:each |
    (aBlock value: each)
        ifTrue: [newCollection add: each]].
^newCollection

Он осуществляет принимает на вход анонимную функцию aBlock, создаёт новую коллекцию, аналогичную себе, и вызывает перебор своих элементов (это метод do:), выполняя переданный ему блок aBlock для каждого элемента; когда блок выполняется (в примере — aCharacter isVowel), он создаёт логическое значение, которому затем посылается сообщение ifTrue:. Если это значение true, то буква добавляется в возвращаемую строку. В конце созданная коллекция возвращается ответом на сообщение, на что указывает символ возвращения в качестве ответа ^. Из-за того что select: определён в абстрактном классе Collection, мы также можем использовать его ещё и так:

| rectangles aPoint|
rectangles := OrderedCollection
  with: (Rectangle left: 0 right: 10 top: 100 bottom: 200)
  with: (Rectangle left: 10 right: 10 top: 110 bottom: 210).
aPoint := Point x: 20 y: 20.
collisions := rectangles select: [:aRect | aRect containsPoint: aPoint].
