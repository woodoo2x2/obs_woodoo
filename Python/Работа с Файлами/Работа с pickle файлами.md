## Сериализация и десериализация

При изучении формата данных (и одноименного модуля в Python) `json` мы говорили о сериализации объектов.

Преобразование переменных программы (Python-объектов) в формат для хранения называется «сериализацией», а обратное преобразование — «десериализацией».

Сериализация объектов часто используется для:

- сохранения состояния программы (то есть некоторых её объектов) между запусками
- передачи данных между различными программами (например, по сети)

Главная идея состоит в том, что сериализованный формат — набор байт или строка, которую можно легко сохранить на диск или передать другой программе, в отличие от самого объекта. А значит, задача сохранения объекта/группы объектов при этом сводится к простой задаче сохранения набора байт или строки.

## [[Module pickle|Модуль pickle]]

Как уже было сказано, JSON — один из популярных форматов для сериализации, он текстовый, легковесный и легко читается человеком. С помощью встроенного модуля `json` можно сериализовать только встроенные типы данных:

- `bool`
- `dict`
- `int`
- `float`
- `list`
- `string`
- `tuple`
- `None`

Помимо сериализации в формат `json` мы также можем использовать бинарную сериализацию, то есть сериализацию в байты. Для этого в Python используется модуль `pickle`. Интерфейс взаимодействия с модулем `pickle` абсолютно такой же, как и для модуля `json`. Мы будем использовать четыре основных функции:

- `dump()`
- `load()`
- `dumps()`
- `loads()`

## Функции dump() и load()

Функция `dump()` модуля `pickle` принимает сериализуемый Python объект, сериализует его в бинарный, Python-зависимый формат, используя протокол `pickle`, и сохраняет его в открытый для записи бинарный файл.

Приведенный ниже код:

```python
import pickle

obj = {'Python': 1991, 'Java': 1995, 'C#': 2002}

with open('file.pkl', 'wb') as file:
    pickle.dump(obj, file)
```

создает файл `file.pkl`, содержащий бинарное представление объекта `obj` на основе протокола `pickle`.

Функция `load()` принимает файловый объект, читает из него сериализованные данные, десериализует их в Python-объект и возвращает полученный Python-объект.

Приведенный ниже код:

```python
import pickle

with open('file.pkl', 'rb') as file:     # используется файл полученный на предыдущем шаге
    obj = pickle.load(file)
    print(obj)
    print(type(obj))
```

выводит:

```no-highlight
{'Python': 1991, 'Java': 1995, 'C#': 2002}
<class 'dict'>
```

## Функции dumps() и loads()

Функция `dumps()` (обратите внимание на `s` в конце имени функции) выполняет такую же сериализацию, как и функция `dump()`. Но вместо того чтобы сохранять сериализованные данные в открытый для записи бинарный файл, она просто возвращает эти сериализованные данные.

Приведенный ниже код:

```python
import pickle

obj = {'Python': 1991, 'Java': 1995, 'C#': 2002}
binary_obj = pickle.dumps(obj)

print(binary_obj)
print(type(binary_obj))
```

выводит:

```no-highlight
b'\x80\x03}q\x00(X\x06\x00\x00\x00Pythonq\x01M\xc7\x07X\x04\x00\x00\x00Javaq\x02M\xcb\x07X\x02\x00\x00\x00C#q\x03M\xd2\x07u.'
<class 'bytes'>
```

Поскольку протокол `pickle` использует бинарный формат данных, функция `dumps()` возвращает объект типа `bytes`.

![](https://ucarecdn.com/2d8178f9-7e89-4c75-8455-b98f4f1c74d1/)Тип данных `bytes` — это неизменяемые последовательности отдельных байтов. Синтаксис для байтовых литералов в основном такой же, как и для строковых литералов, за исключением того, что добавляется префикс `b`.

Функция `loads()` (обратите внимание на `s` в конце имени функции) выполняет такую же десериализацию, как и функция `load()`. Но вместо того чтобы принимать файловый объект, она принимает объект типа `bytes`, содержащий сериализованные данные.

Приведенный ниже код:

```python
import pickle

obj = {'Python': 1991, 'Java': 1995, 'C#': 2002}
binary_obj = pickle.dumps(obj)

new_obj = pickle.loads(binary_obj)

print(new_obj)
```

выводит:

```no-highlight
{'Python': 1991, 'Java': 1995, 'C#': 2002}
```

Обратите внимание, что объекты `obj` и `new_obj` равны, то есть имеют одинаковое содержимое, однако объекты не являются идентичными. Мы создали идеальную копию, но это всё же копия.

Приведенный ниже код:

```python
import pickle

obj = {'Python': 1991, 'Java': 1995, 'C#': 2002}
binary_obj = pickle.dumps(obj)
new_obj = pickle.loads(binary_obj)

print(obj == new_obj)
print(obj is new_obj)       # проверка на идентичность
```

выводит:

```no-highlight
True
False
```

## Примечания

**Примечание 1.** Название модуля `pickle` переводится с английского на русский как мариновать. Название было взято из языка программирования [Modula-3](https://ru.wikipedia.org/wiki/%D0%9C%D0%BE%D0%B4%D1%83%D0%BB%D0%B0-3), который вдохновил многие функции Python. До официального релиза модуль `pickle` имел название `flatten`.

![](https://ucarecdn.com/d1142ead-8aeb-405f-9337-d18e09580387/)

**Примечание 2.** Модуль `pickle` может сериализовывать:

- все встроенные типы данных (`bool, int, float, complex, str, None`)
- cписки, кортежи, словари и множества, содержащие любую комбинацию встроенных типов данных
- cписки, кортежи, словари и множества, содержащие любую комбинацию списков, кортежей, словарей и множеств
- функции, классы и экземпляры классов

**Примечание 3.** Модуль `pickle` может сериализовывать обычные функции (объявленные с помощью  `def`), но не может сериализовывать лямбда-функции (объявленные с помощью `lambda`).

**Примечание 4.** Модуль `pickle` может сериализовывать функции из модуля `operator`.

**Примечание 5.** Модуль `pickle` не может сериализовывать генераторы, о которых мы будем говорить позже в рамках курса.

**Примечание 6.** Модули `pickle` и `json` делают практически одно и то же, по сути это одна и та же технология, только по-разному реализованная.

**Примечание 7.** Протокол `pickle` зависит от Python и не совместим с другими языками программирования. Если необходима совместимость с другими языками программирования, то следует использовать JSON сериализацию.

**Примечание 8.** Протокол `pickle` – это бинарный формат данных. Убедитесь, что открываете файлы `pickle` в бинарном режиме, иначе данные при записи будут повреждены. Формат данных JSON – текстовый, а не двоичный.

**Примечание 9.** Официальная документации по модулю `pickle` доступна по [ссылке](https://docs.python.org/3/library/pickle.html).

**Примечание 10.** Модуль `pickle` не защищен. Никогда не десериализуйте данные, полученные из ненадежного источника, так как они могут оказаться вредоносными и выполняющими произвольный код во время распаковки.

**Примечание 11.** Модуль `pickle` сериализует и десериализует данные быстрее чем модуль `json`.

**Примечание 12.** Хорошая статья (на английском языке) по модулю `pickle` доступна по [ссылке](https://realpython.com/python-pickle-module/).

**Примечание 13.** О встроенном типе данных `bytes` можно подробнее почитать [тут](https://docs-python.ru/tutorial/osnovnye-vstroennye-tipy-python/tip-dannyh-bytes-bajtovye-stroki/) и [тут](http://pythonlearn.ru/python-dlya-nachinayushhix/vse-chto-nuzhno-znat-o-bajtax-v-python/)