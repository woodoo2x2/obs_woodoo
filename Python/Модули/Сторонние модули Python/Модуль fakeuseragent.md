# Библиотека [fake_useragent](https://pypi.org/project/fake-useragent/)

Библиотека `fake_useragent` предоставляет удобный и эффективный способ для генерации фейковых значений `User-Agent`, что особенно полезно в задачах веб-скрапинга и автоматизации. Она облегчает процесс маскировки вашего скрипта под обычного пользователя, минимизируя риск блокировки со стороны сервера.

Установка библиотеки

```
pip install fake-useragent 
или 
pip3 install fake-useragent
```

импорт 

```
from fake_useragent import UserAgent
```

Экземпляр класса создаётся двумя способами. Оба эти способа будут работать одинаково.

```
ua = fake_useragent.UserAgent() 
# или 
ua = UserAgent()
```

 **Цикл с запросами**:

```
for x in range(10):
    fake_ua = {'user-agent': ua.random}
    response = requests.get(url=url, headers=fake_ua)
    print(response.text)
```

В этом цикле выполняются следующие действия:

- Генерируется новый `User-Agent` с помощью метода `.random` экземпляра класса `UserAgent`.
- Выполняется GET-запрос с этим `User-Agent`.
- Выводится текст ответа от сервера.

```
# Импортируем необходимые библиотеки
from fake_useragent import UserAgent
import requests
import time
from random import randint


# Функция для выполнения GET-запроса с подменой User-Agent
def make_request(url, headers):
    try:
        response = requests.get(url, headers=headers, timeout=10)
        if response.status_code == 200:
            return response.text
        else:
            return f"Ошибка: получен статус-код {response.status_code}"
    except Exception as e:
        return f"Произошла ошибка: {e}"


# Инициализация
url = "http://httpbin.org/user-agent"
ua = UserAgent()

# Цикл для выполнения 10 запросов с разными User-Agent и случайными задержками
for i in range(10):
    fake_ua = {'User-Agent': ua.random}  # Генерация случайного User-Agent
    print(f"Итерация {i + 1} с User-Agent: {fake_ua['User-Agent']}")

    # Выполнение запроса
    response_text = make_request(url, fake_ua)
    print(f"Ответ сервера: {response_text}")

    # Случайная задержка от 1 до 5 секунд
    sleep_time = randint(1, 5)
    print(f"Задержка на {sleep_time} секунд")
    time.sleep(sleep_time)
```

Давайте разберем этот код. 

1. **Функция `make_request`**: Эта функция принимает URL и заголовки, затем выполняет GET-запрос. Если статус-код ответа равен 200, функция возвращает текст ответа. В противном случае возвращает сообщение об ошибке.
    
2. **Инициализация переменных**: Задается URL и создается экземпляр класса `UserAgent`.
    
3. **Цикл запросов**: В цикле выполняются 10 итераций, в каждой из которых:
    
    - Генерируется новый `User-Agent`.
    - Вызывается функция `make_request` для выполнения GET-запроса.
    - Выводится текст ответа.
    - Происходит случайная задержка от 1 до 5 секунд.

### Дополнительное использование fake_useragent

#### Ограничение списка браузеров

Если вы хотите, чтобы были сгенерированы `User-Agent` только для определённых браузеров, вы можете передать их в аргументе `browsers` при создании экземпляра класса `UserAgent`. Например, для генерации `User-Agent` только для браузеров Edge и Chrome, вы можете использовать следующий код:

```python
from fake_useragent import UserAgent

ua = UserAgent(browsers=['edge', 'chrome'])
print(ua.random)
```

По умолчанию `fake_useragent` поддерживает следующие браузеры: 

1. `chrome` - для генерации `User-Agent` браузера Google Chrome.
2. `edge` - для генерации `User-Agent` браузера Microsoft Edge.
3. `firefox` - для генерации `User-Agent` браузера Mozilla Firefox.
4. `safari` - для генерации `User-Agent` браузера Apple Safari.

### Указание Операционных Систем через Аргумент `os`

Библиотека `fake_useragent` также предоставляет возможность ограничить набор операционных систем, для которых будут генерироваться значения `User-Agent`. Это можно сделать с помощью аргумента `os` при создании экземпляра класса `UserAgent`.

По умолчанию, `fake_useragent` поддерживает следующие операционные системы:

1. `windows` - для генерации `User-Agent` с операционной системой Windows.
2. `macos` - для macOS.
3. `linux` - для Linux.

Если вы, например, хотите генерировать `User-Agent` только для операционной системы Linux, вы можете сделать это следующим образом:

```
from fake_useragent import UserAgent
ua = UserAgent(os='linux')
print(ua.random)
```

В этом случае, свойство `.random` экземпляра класса `UserAgent` будет возвращать `User-Agent` только для Linux.

#### Примечания

- Этот функционал может быть особенно полезным, если вам необходимо имитировать запросы, исходящие только от определённых типов операционных систем.
- Сочетание аргументов `browsers` и `os` позволяет получить ещё более узкоспециализированный набор `User-Agent`.

### Аргумент min_percentage в библиотеке fake_useragent

Один из интересных аспектов библиотеки `fake_useragent` — возможность фильтрации `User-Agent` по их популярности с помощью аргумента `min_percentage`.

#### Что такое min_percentage?

Аргумент `min_percentage` представляет собой минимальный процент популярности `User-Agent`, который должен быть учтен при генерации. По умолчанию этот аргумент равен 0.0, что означает, что будут возвращены `User-Agent` всех уровней популярности.

#### Как это работает?

Когда вы задаете значение для `min_percentage`, библиотека будет возвращать только те `User-Agent`, доля использования которых равна или превышает указанный процент.

```
from fake_useragent import UserAgent
ua = UserAgent(min_percentage=1.3)
print(ua.random)
```

В этом примере свойство `.random` будет возвращать только те `User-Agent`, которые имеют минимальный процент популярности 1.3% или выше.

#### Зачем это нужно?

Этот параметр может быть полезен в различных сценариях:

1. **Маскировка под популярные браузеры**: Если ваша цель — максимально имитировать обычного пользователя, логично использовать самые популярные `User-Agent`.
    
2. **Уменьшение риска блокировки**: Сервера часто сканируют входящие запросы на наличие редких или подозрительных `User-Agent`. Использование популярных `User-Agent` может уменьшить вероятность блокировки.
    
3. **Специфические требования к парсингу**: В некоторых случаях сайты могут быть оптимизированы для определенных, наиболее популярных браузеров, и использование именно их `User-Agent` обеспечит наилучший результат парсинга.
#ПарсингPython 