[[CSV]] (**Comma Separated Values**) - один из ключевых форматов, который используется во многих областях, начиная от финансовых отчетов и заканчивая анализом данных. Понимание работы с CSV в Python не только расширит ваши навыки, но и позволит автоматизировать множество задач, связанных с данными.

Заказчикам на фриланс-биржах часто требуется сохранять результаты именно в одном из популярных форматов: **CSV** или **JSON**.

Формат данных в CSV выглядит так: `one;two;three` может иметь любой разделитель,

![](https://ucarecdn.com/b12fa808-fdd9-4d08-9a46-a3550d09abb0/)

Работа с модулем **CSV** очень проста, и нам понадобится запомнить лишь пару приемов для того, чтобы успешно применять его на практике.

Python предоставляет встроенную библиотеку csv, которая упрощает чтение и запись данных в формате CSV. Вот пример того, как вы можете прочитать данные из CSV-файла:

Для начала, нам нужно знать что любой список легко превратить в **CSV** ![](https://ucarecdn.com/7df3e988-00a1-4fbf-8514-59cad43ea019/)

```
import csv

lst = ['one', 'two', 'three']

with open('res.csv', 'w', newline='', encoding='utf-8-sig') as file:
    writer = csv.writer(file, delimiter=';')
    writer.writerow(lst)
```

Чтобы в **Excel** корректно открывалась кодировка, используйте `encoding='utf-8-sig'`.  
В результате выполнения этого кода будет создан файл `res.csv`, в который будет записан наш список `lst`, в каждой ячейке - элемент списка.

- `newline=''` - необходимо указывать всегда. Если не указать, то новые строки могут интерпретироваться  неправильно и весь документ “сползет”;
- `encoding='utf-8-sig'` - `open()` использует для открытия `.csv`  по умолчанию кодировку **unicode**. Чтобы получить файл с необходимой нам кодировкой, нужно явно указывать ее.

`writer = csv.writer(file, delimiter=';')` - в этой строке мы создали экземпляр класса **csv** и применили к нему метод `writer()`. У `writer()` есть метод `writerow()`, с помощью которого можно записывать список в соответствующий формат построчно. `delimiter='**;**'` указывает, каким будет разделитель между элементами списка, мы можем указать любой.


В этом уроке я хочу наглядно показать, как собрать информацию с [тренажера](http://parsinger.ru/html/mouse/3/3_11.html) и сохранить результат в формате `.csv`

```python
import csv
import requests
from bs4 import BeautifulSoup

# 1 ------------------------------------------------------
with open('res.csv', 'w', encoding='utf-8-sig', newline='') as file:
    writer = csv.writer(file, delimiter=';')
    writer.writerow([
        'Наименование', 'Артикул', 'Бренд', 'Модель',
        'Тип', 'Игровая', 'Размер', 'Разрешение','Подсветка',
        'Сайт производителя', 'В наличии', 'Цена'])
# 1 ------------------------------------------------------

# 2 ------------------------------------------------------
url = 'http://parsinger.ru/html/mouse/3/3_11.html'

response = requests.get(url=url)
response.encoding = 'utf-8'
soup = BeautifulSoup(response.text, 'lxml')
# 2 ------------------------------------------------------

# 3 ------------------------------------------------------
name = soup.find('p', id='p_header').text
article = soup.find('p', class_='article').text.split(': ')[1]
brand = soup.find('li', id='brand').text.split(': ')[1]
model = soup.find('li', id='model').text.split(': ')[1]
type = soup.find('li', id='type').text.split(': ')[1]
purpose = soup.find('li', id='purpose').text.split(': ')[1]
light = soup.find('li', id='light').text.split(': ')[1]
size = soup.find('li', id='size').text.split(': ')[1]
dpi = soup.find('li', id='dpi').text.split(': ')[1]
site = soup.find('li', id='site').text.split(': ')[1]
in_stock = soup.find('span', id='in_stock').text.split(': ')[1]
price = soup.find('span', id='price').text.split(' ')[0]
# 3 ------------------------------------------------------

# 4 ------------------------------------------------------
with open('res.csv', 'a', encoding='utf-8-sig', newline='') as file:
    writer = csv.writer(file, delimiter=';')
    writer.writerow([
        name, article, brand, model,
        type, purpose, light, size, dpi,
        site, in_stock, price])
# 4 ------------------------------------------------------
```

Я визуально разделил код на 4 части. 

1. В первом блоке мы создали файл `res.csv` и определили в нем первые 12 ячеек для заголовков. При просмотре в текстовом редакторе это будет выглядеть вот так:![](https://ucarecdn.com/219ffa90-d353-4d3b-b0e0-171991a954e7/)​ 
2. Когда мы откроем его в excel, это будет выглядеть вот так. Наличие заголовков это хорошая практика, но не обязательная.![](https://ucarecdn.com/04b63ec1-c3ca-4e2c-9b9e-a2aa2d2c6ac2/)
3. Вторая часть кода -  это стандартные запросы к сайту, которые вы уже использовали при выполнении задач;
4. Третья часть хорошо показывает, что мы получаем нужные нам элементы и храним их в переменных, которые в 4-м пункте мы передаем в метод `.writerow()`. Обратите внимание на то, что мы передаем список;
5. И в результате выполнения 4-го блока кода мы получаем готовый файл `.csv`, в котором будут красиво лежать наши данные.![](https://ucarecdn.com/84beb8db-32de-4f1a-bbe9-75cfc5c1bead/)Обратите внимание, что в 4-м блоке мы используем флаг `'a'` для того, чтобы дописать созданный в первом блоке файл. `‘a’` - "**append"** - дообавление в конец. Если флаг будет `'w',` - **"write"**, то файл перезапишется заново и заголовки мы не увидим.

В этом уроке, мы будем получать данные сразу с восьми карточек одновременно. Как говорится, следите за руками.

Мы хотим получить аккуратно отформатированные данные, лежащие в таблице **excel**, примерно вот так:

![](https://ucarecdn.com/f1d6bf94-b740-41c4-8974-f3b3e2eb0fa1/)

Откроем [тренажер](http://parsinger.ru/html/index3_page_2.html) и соберем с каждой карточки следующую информацию как на скриншоте ниже:

![](https://ucarecdn.com/77f86a5e-08fe-4ec0-8463-b202b0b55a72/)

Для начала посмотрим на структуру данной карточки, а конкретно на теги `<li>`. Мы видим,  что у всех необходимых нам элементов есть то, за что можно зацепиться. У каждого элемента есть  свой `class=''`, а у тегов `<li>` ничего нет, только родительский элемент `<div class='description'>` . По нему мы и будем получать наши элементы `<li>`, причем все и сразу.

Мы могли бы использовать код `soup.find('div', class_='description').find_all('li')`,  т.е., попросили бы наш интерпретатор найти блок `div` с классом `description` и в нем отыскать все теги `<li>`. Это отличный подход для одной карточки, а у нас их восемь. Это значит, что нам нужно искать все теги `div` с классом `description`  на странице одновременно.

![](https://ucarecdn.com/fc1671ba-e247-4eeb-8f59-984fe8e0117e/)

 Давайте посмотрим на код целиком:

- В переменной  `name` у нас будет храниться список наименований товаров;
- В переменной  `description` у нас будет храниться **список списков** описания товаров, которые находятся в `<li>`;
- В переменной  `price` у нас будет храниться список цен товаров.

Наша задача - объединить эти 3 списка в 1 список или кортеж, избегая вложенных списков. Если мы просто объединим эти три списка, мы получим![](https://ucarecdn.com/43a513df-cb37-4912-b65c-3a41752c1af0/)

Мы знаем, что модуль **CSV** может спокойно работать с вложенными списками. Но результат будет не тот, который мы ожидаем, - посмотрите на изображение ниже. Поэтому нам нужно извлечь вложенный список.![](https://ucarecdn.com/2985bf96-cd7a-4b1b-8f54-d48fbfa23fbe/)

Блок №4 в коде ниже, решает эту задачу. В результате выполнения блока №4 мы получаем новый список `flatten` , который выглядит как нужно ![](https://ucarecdn.com/f7934258-8c08-4a71-8420-6d54dd9e0afe/)

Такой список мы можем спокойно записать в файл, не опасаясь, что таблица уедет. Передадим список в метод `.writerow(result)` и полюбуемся результатом. Запустите данный код у себя в терминале.

```python
import csv
import requests
from bs4 import BeautifulSoup

# 1 ------------------------------------------------------
with open('res.csv', 'w', encoding='utf-8-sig', newline='') as file:
    writer = csv.writer(file, delimiter=';')
    writer.writerow([
        'Наименование', 'Цена', 'Бренд', 'Тип', 'Подключение', 'Игровая'])
# 1 ------------------------------------------------------

# 2 ------------------------------------------------------
url = 'http://parsinger.ru/html/index3_page_2.html'

response = requests.get(url=url)
response.encoding = 'utf-8'
soup = BeautifulSoup(response.text, 'lxml')
# 2 ------------------------------------------------------

# 3 ------------------------------------------------------
# Извлекаем имена товаров и убираем лишние пробелы
name = [x.text.strip() for x in soup.find_all('a', class_='name_item')]

# Извлекаем описание товаров и разбиваем на строки
description = [x.text.split('\n') for x in soup.find_all('div', class_='description')]

# Извлекаем цены товаров
price = [x.text for x in soup.find_all('p', class_='price')]
# 3 ------------------------------------------------------


# 4------------------------------------------------------
# Открываем файл для дополнительной записи данных
with open('res.csv', 'a', encoding='utf-8-sig', newline='') as file:
    writer = csv.writer(file, delimiter=';')
    for item, price, descr in zip(name, price, description):

        # Формируем строку для записи
        flatten = item, price, *[x.split(':')[1].strip() for x in descr if x]
        writer.writerow(flatten)

print('Файл res.csv создан')
```

 Этот код создаёт [файл](https://stepik.org/media/attachments/lesson/701336/res.csv).  
![](https://ucarecdn.com/572df8e0-556b-47ac-8a86-ac157d546e8e/)

#### Блок кода 1:

Этот блок кода отвечает за создание нового CSV-файла и запись в него строки заголовков. Строка заголовков состоит из названий столбцов, таких как `"Наименование"`, `"Цена"`, `"Бренд"` и так далее.

#### Блок кода 2:

В этом блоке происходит запрос веб-страницы с интернета и её последующий парсинг. Здесь используются библиотеки `requests` для скачивания страницы и `BeautifulSoup` из пакета `bs4` для парсинга HTML-кода страницы.

#### Блок кода 3:

Здесь извлекаются определённые данные с веб-страницы. С помощью `BeautifulSoup` код находит все нужные элементы на странице — имена товаров, их описания и цены, — и сохраняет их в соответствующие списки.

#### Блок кода 4:

Этот блок кода отвечает за запись извлечённых данных в ранее созданный CSV-файл. Для каждого товара формируется строка, состоящая из его имени, цены и характеристик, которая затем записывается в файл. После успешного завершения всех операций выводится сообщение о том, что файл успешно создан.



#ПарсингPython 