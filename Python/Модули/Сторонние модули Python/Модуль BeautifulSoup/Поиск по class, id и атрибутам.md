# Поиск по `class`, `id`, поиск по атрибутам

## Поиск по `class`

Поиск по `class` аналогичен поиску по `id`, но с некоторыми особенностями в синтаксисе.

Будем использовать наш [тренажер](http://parsinger.ru/html/headphones/5/5_32.html).

Мы с вами хотим получить значение тега `<p>` с классом `'article'`

![](https://ucarecdn.com/1951b647-12f5-45d9-9d0b-56444e8c9e1f/)

```python
from bs4 import BeautifulSoup
import requests

# Задаем URL-адрес веб-страницы для парсинга
url = 'http://parsinger.ru/html/headphones/5/5_32.html'

# Отправляем GET-запрос к указанной странице
response = requests.get(url=url)

# Устанавливаем кодировку ответа сервера в UTF-8 для корректного отображения текста на кириллице
response.encoding = 'utf-8'

# Преобразуем текст ответа сервера в объект BeautifulSoup с использованием парсера 'lxml'
soup = BeautifulSoup(response.text, 'lxml')

# Ищем на странице тег <p> с классом 'article' и извлекаем из него текстовое содержимое
div = soup.find('p', class_='article').get_text()

# Выводим на экран текст, найденный внутри тега <p> с классом 'article'
print(div)
```

Вывод:

```
Артикул: 80387567
```

Стоит обратить внимание на использование нижнего подчеркивания после слова `class**_**`. Это сделано не случайно: такое наименование предотвращает конфликты с зарезервированными словами в Python. `class` является служебным словом, используемым для объявления классов, и его нельзя использовать в качестве имени переменной или атрибута. Важно помнить этот синтаксис при работе с BeautifulSoup.

Также обратите внимание на метод `.get_text()`. Мы применили его сразу после вызова метода `.find()`, что является хорошей практикой. Однако новички иногда пытаются применить метод `.get_text()` после вызова метода `.find_all()` и сталкиваются с ошибкой. Скорее всего, более внимательные разработчики уже догадались, почему это происходит: метод `.get_text()` нельзя применять к списку, который возвращается при вызове метода `.find_all()`.

## Поиск по `id`

На той же странице нашего [тренажера](http://parsinger.ru/html/headphones/5/5_32.html) присутствует тег `<p>` с `id='p_header'`. Давайте рассмотрим, как извлекать текст по `id`.

![](https://ucarecdn.com/95726fbb-d7d2-4e3b-99eb-ab4bacc0fbc3/)

```python
from bs4 import BeautifulSoup
import requests

# Задаем URL-адрес веб-страницы, с которой необходимо извлечь данные
url = 'http://parsinger.ru/html/headphones/5/5_32.html'

# Отправляем GET-запрос к указанной странице
response = requests.get(url=url)

# Устанавливаем кодировку ответа сервера в UTF-8, чтобы корректно отображать кириллический текст
response.encoding = 'utf-8'

# Преобразуем текст ответа сервера в объект BeautifulSoup с использованием парсера 'lxml'
soup = BeautifulSoup(response.text, 'lxml')

# Ищем на странице тег <p> с идентификатором 'p_header' и извлекаем из него текстовое содержимое
div = soup.find('p', id='p_header').get_text()

# Выводим на экран текст, найденный внутри тега <p> с идентификатором 'p_header'
print(div)
```

Вывод:

```
Наушники HP Pavilion Gaming 600
```

На самом деле, тут все выглядит точно так же, как и при работе с `class_=''`, только нам нужно указать, что мы ищем `id`.

## Поиск по атрибутам

У нас есть тег `span`, у которого есть атрибут `name='count'`. Давайте посмотрим, как извлечь текст по атрибуту.

![](https://ucarecdn.com/08ece996-b0d5-4c48-80b9-fee5b71afc40/)

```python
from bs4 import BeautifulSoup
import requests

# Задаем URL-адрес веб-страницы для парсинга
url = 'http://parsinger.ru/html/headphones/5/5_32.html'

# Отправляем GET-запрос к указанной странице
response = requests.get(url=url)

# Устанавливаем кодировку ответа сервера в UTF-8 для корректного отображения текста на кириллице
response.encoding = 'utf-8'

# Преобразуем текст ответа сервера в объект BeautifulSoup с использованием парсера 'lxml'
soup = BeautifulSoup(response.text, 'lxml')

# Ищем на странице элемент <span> с атрибутом 'name', значение которого равно 'count', и извлекаем его текстовое содержимое
div = soup.find('span', {'name': 'count'}).get_text()

# Выводим на экран извлеченное текстовое содержимое
print(div)
```

Вывод:

```
В наличии: 38
```

В реальных условиях поиск по атрибутам приходится использовать часто, и важно знать, что такие возможности у нас есть, и ими не стоит пренебрегать. Это особенно актуально, когда структура веб-страницы сложна или когда классы и идентификаторы элементов не предоставляют достаточной информативности. Атрибуты могут содержать полезную информацию, такую как данные для отслеживания, типы контента или другие метаданные, которые могут быть критически важными для вашей задачи. Поэтому грамотное использование методов поиска по атрибутам может значительно упростить и ускорить процесс извлечения данных с веб-страниц.

# **Обработка двойных классов с помощью BeautifulSoup**

Одной из распространенных задач при работе с веб-страницами является поиск элементов по их классам. Если у элемента несколько классов, возникает необходимость в правильной обработке таких случаев.

```
<!DOCTYPE html>
<html lang="ru">
<head>
    <title>Тестовая страница</title>
</head>
<body>
    <div class="class1 class2">Элемент 1</div>
    <div class="class1 class3">Элемент 2</div>
    <div class="class2 class3">Элемент 3</div>
</body>
</html>
```

### Извлечение элементов с двойными классами

Загрузим наш HTML-документ:

```
from bs4 import BeautifulSoup

html = """
<!DOCTYPE html>
<html lang="ru">
<head>
    <title>Тестовая страница</title>
</head>
<body>
    <div class="class1 class2">Элемент 1</div>
    <div class="class1 class3">Элемент 2</div>
    <div class="class2 class3">Элемент 3</div>
</body>
</html>
"""

soup = BeautifulSoup(html, 'html.parser')
```

Для поиска элементов с двойными классами можно использовать следующий синтаксис:

```python
elements = soup.find_all('div', class_='class1 class2')

# В нашем HTML-документе найдём один элемент 

[<div class="class1 class2">Элемент 1</div>]
```

Следует помнить, что порядок классов важен. Если вы ищете элементы с классами "**class1** **class2**", то элементы с классами "**class2** **class1**" не будут найдены.

Если порядок классов не важен, можно использовать CSS-селекторы:

```python
elements = soup.select('div.class2.class1')

# В нашем HTML-документе найдём тот же элемент

[<div class="class1 class2">Элемент 1</div>]
```

С использованием этого метода элементы будут найдены независимо от порядка классов.

Если нужно найти элементы, которые имеют хотя бы один из указанных классов.

```
elements = soup.find_all('div', class_=['class1', 'class2'])

# Найдём элементы, имеющие хотя бы один из искомых классов

[<div class="class1 class2">Элемент 1</div>, <div class="class1 class3">Элемент 2</div>, <div class="class2 class3">Элемент 3</div>]
```

