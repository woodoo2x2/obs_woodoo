## Модуль functools

В рамках прошлого курса мы рассматривали функцию `reduce()` из модуля `functools`. Помимо данной функции модуль `functools` предоставляет множество других полезных функций высшего порядка, которые можно использовать для кэширования, перегрузки, создания декораторов и в целом для того, чтобы делать код более функциональным.

### Функция partial()

**Частичное применение функций** — это техника, основанная на возможности возвращать функции из других функций. Предположим, мы написали функцию `multiply()`, которая перемножает два числа:

```python
def multiply(a, b):
    return a * b
```

Приведенный ниже код:

```python
print(multiply(2, 3))
```

выводит:

```no-highlight
6
```

Пусть нам теперь нужны функции, которые удваивают и утраивают некоторое число. Такие функции могут быть определены на основе уже существующей функции `multiply()` следующим образом:

```python
def double(num):
    return multiply(2, num)
 
def triple(num):
    return multiply(3, num)
```

Когда сценариев работы функции всего несколько, конечно, логичнее сделать, как показано выше, то есть явно определить новые функции. Но когда нужно написать очень много новых функций, то смысла переписывать один и тот же код столько раз нет. Здесь нам на помощь приходит частичное применение функций.

![](https://ucarecdn.com/28aae2c1-ccab-456f-a951-0b6aa2f6db23/)   Частичное применение позволяет на основе старой функции создать новую, которая "частично применена".

В Python для использования частичного применения используется функция `partial()` из модуля `functools`.

Сигнатура функции следующая: `partial(func, *args, **kwargs)`. Данная функция возвращает специальный `partial` объект, который при вызове вызывается как функция `func`, в которую дополнительно передаются позиционные аргументы `args` и именованные аргументы `kwargs`.

![](https://ucarecdn.com/69e3c936-056c-4684-bcc6-d445a77c15c7/)   Функция `partial()` возвращает `partial` объект, который при вызове ведет себя как функция.

Приведенный выше код можно переписать с использованием функции `partial()` в виде:

```python
from functools import partial

def multiply(a, b):
    return a * b

double = partial(multiply, 2)
triple = partial(multiply, 3)
```

В нашем случае `partial` объекты `double` и `triple` ведут себя как функция `multiply()`, которой в качестве первого аргумента передали число 22 в первом случае и 33 во втором.  

Приведенный ниже код:

```python
print(double(5))        # 2 * 5
print(triple(10))       # 3 * 10
```

выводит:

```
10
30
```

Обратите внимание на то, что мы зафиксировали только один аргумент, поэтому новые `partial` объекты теперь ожидают только один аргумент. Если мы попытаемся передать более одного аргумента, то получим ошибку.

Приведенный ниже код:

```no-highlight
print(double(5, 6))
```

приводит к возникновению ошибки:

```no-highlight
TypeError: multiply() takes 2 positional arguments but 3 were given
```

Мы можем также зафиксировать оба аргумента в функции `multiply()`.

Приведенный ниже код:

```python
​multiply_two_and_five = partial(multiply, 2, 5)

print(multiply_two_and_five())   # вызываем уже без аргументов
```

выводит:

```no-highlight
10
```

При формировании новой функции с использованием `partial()` мы можем передавать не только позиционные аргументы, но и именованные. Вспомним, что встроенная функция `int()`, помимо конвертируемого значения, также принимает именованный аргумент `base`, имеющий по умолчанию значение 1010. Данный аргумент отвечает за основание системы счисления конвертируемого значения.

Приведенный ниже код:

```python
print(int('123'))
print(int('123', base=5))
print(int('1001', base=2))
print(int('A12B', base=16))
```

выводит:

```no-highlight
123
38
9
41259
```

Зафиксировав значение именованного аргумента `base`, мы можем получить функцию `basetwo()`, которая переводит число из двоичной системы счисления в десятичную.

Приведенный ниже код:

```python
from functools import partial

basetwo = partial(int, base=2)

print(basetwo('101'))
print(basetwo('1000'))
print(basetwo('11111'))
```

выводит:

```no-highlight
5
8
31
```

![](https://ucarecdn.com/14687ba4-fd37-4d49-b317-35fadf6f335d/)Если другие аргументы передаются при вызове функции, то позиционные добавляются в конец, а именованные расширяются и перезаписываются.

### Объекты, возвращаемые функцией partial()

Как уже было сказано выше, функция `partial()` возвращает специальные `partial` объекты, которые при вызове ведут себя как функции. Такие объекты содержат три полезных атрибута:

- `func` — исходная функция
- `args` — зафиксированные позиционные аргументы (тип `tuple`)
- `keywords` — зафиксированные именованные аргументы (тип `dict`)

При необходимости к ним можно получить доступ с помощью стандартной точечной нотации.

Приведенный ниже код:

```python
from functools import partial

def pretty_print(text, symbol, count):
    print(symbol * count)
    print(text)
    print(symbol * count)

star_pretty_print = partial(pretty_print, 'Hi!!!', symbol='*')

star_pretty_print(count=7)

print(star_pretty_print.args)
print(star_pretty_print.keywords)

star_pretty_print.func('Исходная функция', symbol='~', count=20)
```

выводит:

```no-highlight
*******
Hi!!!
*******
('Hi!!!',)
{'symbol': '*'}
~~~~~~~~~~~~~~~~~~~~
Исходная функция
~~~~~~~~~~~~~~~~~~~~
```

### Функция update_wrapper()

Как несложно заметить, частичное применение с помощью функции `partial()` работает подобно декоратору. При этом у `partial` объекта нет явных атрибутов `__name__` и `__doc__` от начальной функции. Доступ к этим атрибутам возможен только через исходную функцию с помощью атрибута `func`.

Приведенный ниже код:

```python
from functools import partial

def multiply(a, b):
    '''Функция перемножает два числа и возвращает вычисленное значение.'''
    return a * b

double = partial(multiply, 2)

print(double.func.__name__)
print(double.func.__doc__)
```

выводит:

```no-highlight
multiply
Функция перемножает два числа и возвращает вычисленное значение.
```

С помощью функции `update_wrapper()` из модуля `functools` можно скопировать и добавить атрибуты `__name__` и `__doc__` из исходной функции в `partial` объект.

Приведенный ниже код:

```python
from functools import partial, update_wrapper

def multiply(a, b):
    '''Функция перемножает два числа и возвращает вычисленное значение.'''
    return a * b

double = partial(multiply, 2)

update_wrapper(double, multiply)   # копируем информацию из функции multiply в partial объект double

print(double.__name__)
print(double.__doc__)
```

выводит:

```no-highlight
multiply
Функция перемножает два числа и возвращает вычисленное значение.
```

## Примечания

**Примечание 1.** Документации по модулю `functools` доступна по [ссылке](https://docs.python.org/3/library/functools.html).

**Примечание 2.** Документация по функции `reduce()` доступна по [ссылке](https://docs-python.ru/standart-library/modul-functools-python/funktsija-reduce-modulja-functools/).

**Примечание 3.** Урок из прошлого курса по функции `reduce()` доступен по [ссылке](https://stepik.org/lesson/511145/step/1?unit=503343).

**Примечание 4.** Функция `partial()` возвращает `partial` объект, который при вызове ведет себя как функция.

Приведенный ниже код:

```python
from functools import partial

def multiply(a, b):
    return a * b

double = partial(multiply, 2)

print(type(double))
```

выводит:

```no-highlight
<class 'functools.partial'>
```

**Примечание 5.** Прочитать подробнее о функции `update_wrapper()` можно по [ссылке](https://docs-python.ru/standart-library/modul-functools-python/dekorator-update-wrapper-modulja-functools/).

**Примечание 6.** Декоратор `functools.wraps` уже изучался нами в рамках одного из прошлых уроков. Данный декоратор использует функцию `update_wrapper()` для копирования атрибутов `__name__` и `__doc__`.

**Примечание 7.** Исходный код модуля `functools` доступен по [ссылке](https://github.com/python/cpython/blob/7a4791e03613bfbdc0d3ddfabfc0b59e6a6f7358/Lib/functools.py).