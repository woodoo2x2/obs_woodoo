В следующих двух уроках остановимся на двух функциях для создания задач (объекты класса `Task`): 

- `asyncio.**create_task**()`
- `asyncio.**ensure_future**()`

`asyncio.**create_task**(**coro, *, name=None, context=None**)` — функция оборачивает `coro` в объект `Task`, т.е. она будет запланирована для выполнения в цикле событий.

- `**coro**`: Coroutines ([[Корутины]]) для оборачивания в `Task`. Это асинхронная функция, которую вы планируете выполнить.
- `**name**`: (_Необязательный_) Имя задачи. Может быть использовано для удобства отладки.
- `**context**`: (_Необязательный_) Контекст выполнения, который будет связан с задачей. Это может быть использовано для передачи контекстной информации между задачами.


`asyncio.**create_task()**` _была добавлена в Python 3.7. Для более ранних версий Python (3.5 и ниже) вы можете использовать `asyncio.**ensure_future()**`, который предлагает похожую функциональность._

### Особенности `asyncio.**create_task**()`

**1. При создании задача только планируется к выполнению, но не начинает выполняться сразу.** При создании задачи в цикле событий с помощью метода `asyncio.**create_task**(my_coroutine())` корутина `my_coroutine()` оборачивается в объект `Task` и планируется ее выполнение. Выполняться задача начнет при первом переключении контекста (`await`).

```python
import asyncio


async def my_coroutine():
    # Получаем имя текущей задачи.
    task = asyncio.current_task()
    task_name = task.get_name()

    print(f'Задача {task_name} запущена.')
    await asyncio.sleep(1)
    print(f'Задача {task_name} была выполнена.')


async def main():
    task = asyncio.create_task(my_coroutine(), name='my_task')
    print(f"Задача {task.get_name()} создана, но еще не запущена")
    await task
    print('Ожидание выполнения my_task окончено, управление было возвращено в main().\nmain() завершает свою работу.')


asyncio.run(main())
```

Вывод:

```python
Задача my_task создана, но еще не запущена
Задача my_task запущена.
Задача my_task была выполнена.
Ожидание выполнения my_task окончено, управление было возвращено в main().
main() завершает свою работу.
```

В данном коде также использован параметр `name` функции `asyncio.**create_task**()`, который очень удобен для мониторинга и отладки программы. 

_P.S. В коде использованы методы, работа которых будет объяснена в соответствующих темах далее, но общий принцип работы кода должен быть понятен._

**2. Созданную задачу нужно ожидать с ключевым словом `await`.** Важно помнить, что если вы не дождетесь завершения задачи с помощью `await`, обращение к ее еще не полученному результату может вызвать ошибку, или задача может быть отменена, когда цикл событий закроется. 

```python
import asyncio

async def my_coroutine():
    print(f"Корутина запустилась")
    await asyncio.sleep(2)
    print(f"Корутина завершена")  # данное сообщение выведено не будет! 

async def main():
    task = asyncio.create_task(my_coroutine())
    await asyncio.sleep(1)

asyncio.run(main())
```

В данном примере нет ожидания задачи с помощью `await`, поэтому задача начинает выполняться, но как только `main()` завершает работу, задача отменяется. Мы видим только одно сообщение от данной корутины: 

```
Корутина запустилась
```

**3. Задачи можно создать в любом количестве.** Их можно записать в переменные или в список. Все созданные задачи начнут выполняться немедленно при следующем проходе событийного цикла. Событийный цикл `asyncio` планирует выполнение этих задач и начинает их обработку как только доходит до них в своей внутренней очереди. Это происходит асинхронно, так что даже если одна задача заблокирована или ожидает ввода-вывода, другие задачи могут продолжать выполняться. Метод `asyncio.create_task()` также можно  использовать внутри циклов или list comprehension.

**4. Порядок создания задач с помощью `asyncio.create_task()` может не совпадать с порядком завершения задач.** `asyncio.**create_task()**` планирует выполнение корутины в цикле событий. Это означает, что если у вас есть несколько задач, они начнут выполняться в том порядке, в котором они были запланированы, но будут выполнены в том порядке, в котором будет возвращён ответ от **I**/**O** операции. Например, если это запросы к серверу, первая задача будет выполнена та, чей ответ придёт раньше.

```python
import asyncio


async def my_coroutine(i, delay):
    print(f"Корутина {i} запустилась")
    await asyncio.sleep(delay)
    print(f"Корутина {i} завершена")


async def main():
    task1 = asyncio.create_task(my_coroutine(1, 2))
    task2 = asyncio.create_task(my_coroutine(2, 1))
    await asyncio.gather(task1, task2)

asyncio.run(main())
```

Вывод: 

```
Корутина 1 запустилась
Корутина 2 запустилась
Корутина 2 завершена
Корутина 1 завершена
```

**5. Использование с `asyncio.run()`.** `asyncio.**create_task()**` должна использоваться в контексте асинхронной функции, которая затем запускается с помощью `asyncio**.run()**`. Это связано с тем, что `asyncio**.run()**` создает новый цикл событий и закрывает его по завершении. `asyncio.**create_task()**` создает задачу и планирует ее к выполнению в текущем цикле событий. Если задача создается вне активного цикла событий, будет вызвано исключение `RuntimeError`.

**6. Ошибка, вызванная в одной из корутин, не будет выброшена немедленно.** Если в корутине, которую вы запускаете как задачу, происходит исключение, оно не будет немедленно выброшено. Вместо этого оно будет сохранено и выброшено, когда вы попытаетесь получить результат задачи. Это означает, что вы должны быть готовы обрабатывать исключения при ожидании завершения задачи. 

**7. Задачи, созданные с помощью `asyncio.create_task()`, могут быть отменены.** Для этого можно использовать метод `cancel()`.  Более подробно также будем говорить об этом в следующих уроках.
