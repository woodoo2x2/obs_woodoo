## Числовые типы данных

В прошлых уроках мы изучили два числовых типа данных, представленных в Python:

- `int` – целое число;
- `float` – число с плавающей точкой (аналог вещественного числа в математике).

В Python есть три дополнительных числовых типа данных:

- `Decimal` – десятичное число, для выполнения точных расчетов;
- `Fraction` – число, представляющее собой [обыкновенную дробь](https://ru.wikipedia.org/wiki/%D0%94%D1%80%D0%BE%D0%B1%D1%8C_(%D0%BC%D0%B0%D1%82%D0%B5%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B0)#.D0.9E.D0.B1.D1.8B.D0.BA.D0.BD.D0.BE.D0.B2.D0.B5.D0.BD.D0.BD.D1.8B.D0.B5_.D0.B4.D1.80.D0.BE.D0.B1.D0.B8), с заданным числителем и знаменателем;
- `Complex` – комплексное число.

В этом уроке мы изучим числовой тип данных `Decimal`, аналог типа данных `float` на случай более точных вычислений.

## Тип данных float

Рассмотрим программный код:

```python
if 0.3 == 0.3:
    print('YES')
else:
    print('NO')
```

Результатом выполнения такого кода будет как и полагается `YES`.

А теперь рассмотрим программный код:

```python
num = 0.1 + 0.1 + 0.1

if num == 0.3:
    print('YES')
else:
    print('NO')
```

Вы будете удивлены, но результатом выполнения такого кода будет `NO`, так как на самом деле в переменной `num` хранится что-то типа 0.300000000000000040.30000000000000004.

Из-за ограничений в сохранении точного значения чисел, даже простейшие математические операции могут выдавать ошибочный результат. Поэтому, чтобы сравнивать два `float` числа мы должны использовать такой код:

```python
num = 0.1 + 0.1 + 0.1
eps = 0.000000001           # точность сравнения

if abs(num - 0.3) < eps:    # число num отличается от числа 0.3 менее чем 0.000000001
    print('YES')
else:
    print('NO')
```

Такой код выводит, как полагается, значение `YES`.

Не стоит сравнивать `float` числа с помощью оператора `==`. Для сравнения `float` чисел нужно использовать указанный выше код.

## Тип данных Decimal

Тип данных `Decimal` – это класс из стандартного модуля `decimal`. Он представляет собой число с плавающей точкой, как и `float`. Однако, `Decimal` имеет ряд существенных отличий от `float`.

Тип `Decimal` создан, чтобы операции над вещественными числами в компьютере выполнялись как в математике, и равенство 0.1+0.1+0.1==0.30.1+0.1+0.1==0.3 было верным.

Точность результатов арифметических действий очень важна для научных вычислений, в сфере финансов и бизнеса. Для таких задач тип данных `float` не подходит.

В Python тип данных `float` реализован по стандарту IEEE-754 как число с плавающей точкой двойной точности (6464 бита) с основанием экспоненты равным 22. Реализация таких чисел заложена прямо в железо любого современного процессора. Поэтому `float` в Python работает как аналогичный тип данных `double` в таких языках программирования как С#, С++, Java и т.д. И имеет такие же ограничения и «странности». Так как `float` поддерживается аппаратно, быстродействие при использовании этого типа данных сравнительно велико.

Тип данных `Decimal` – число с плавающей точкой с основанием экспоненты 1010. Он реализован по стандарту IBM: General Decimal Arithmetic Specification, в свою очередь основанному на стандартах IEEE.

Тип данных `Decimal` реализован программно, поэтому он в разы медленнее типа данных `float`, реализованного аппаратно. Сам тип данных `Decimal` написан на языке С.

Тип данных `Decimal` оперирует числами с произвольной – задаваемой программистом, но конечной точностью. По умолчанию точность составляет 2828 десятичных знаков.

Тип данных `Decimal` неизменяемый. Операции над ним приводят к созданию новых объектов, при этом старые не меняются.

Еще одно следствие того, что `Decimal` реализован программно – его можно на ходу настраивать, как угодно программисту. Для этого есть контекст – объект, содержащий настройки для выполнения операций. Операции, выполняемые в контексте, следуют заданным в нем правилам. Для `float` все правила фиксированы на аппаратном уровне.

Для типа данных `Decimal` можно настроить:

- точность выполнения операций в количестве десятичных знаков;
- режимы округления;
- режимы обработки исключительных ситуаций (деление на ноль, переполнение и т. д).

### Создание Decimal чисел

Создать `Decimal` число можно из обычного целого числа (`int`), из числа с плавающей точкой (`float`) или из строки (`str`).

Приведенный ниже программный код создает `Decimal` числа на основе целого числа и строки:

```python
from decimal import *

d1 = Decimal(1)
d2 = Decimal(567)
d3 = Decimal(-93)
d4 = Decimal('12345')
d5 = Decimal('52.198')

print(d1, d2, d3, d4, d5, sep='\n')
```

и выводит:

```no-highlight
1
567
-93
12345
52.198
```

При создании `Decimal` чисел из чисел с плавающей точкой (`float`) возникают проблемы, так как `float` числа округляются внутри до ближайшего возможного, а `Decimal` об этом ничего не знает и копирует содержимое `float`.

Приведенный ниже программный код создает `Decimal` число на основе числа с плавающей точкой:

```python
from decimal import *

num = Decimal(0.1)

print(num)
```

и выводит:

```no-highlight
0.1000000000000000055511151231257827021181583404541015625
```

![](https://ucarecdn.com/3e7b7509-26c9-47bd-bc88-c0f35aff5d19/)Не рекомендуется создавать `Decimal` числа из `float` чисел. В `Decimal` попадет уже неправильно округленное число. Создавать `Decimal` числа нужно из целых чисел, либо из строк!

###  Арифметические операции над Decimal числами

Тип данных `Decimal` отлично интегрирован в язык Python. С `Decimal` числами работают все привычные операции: сложение, вычитание, умножение, деление, возведение в степень.

Приведенный ниже код:

```python
from decimal import *

num1 = Decimal('5.2')
num2 = Decimal('2.3')

print(num1 + num2)
print(num1 - num2)
print(num1 * num2)
print(num1 / num2)
print(num1 // num2)
print(num1 ** num2)
```

выводит:

```no-highlight
7.5
2.9
11.96
2.260869565217391304347826087
2
44.34122533787992500412791298
```

Можно совершать арифметические операции над `Decimal` и целыми числами (миксовать `Decimal` и `int`), но не рекомендуется смешивать их с `float`.

Приведенный ниже код:

```python
from decimal import *

num = Decimal('5.2')

print(num + 1)
print(num - 10)
print(num * 2)
print(num ** 4)
```

выводит:

```no-highlight
6.2
-4.8
10.4
731.1616
```

### Математические функции

`Decimal` числа можно передавать как аргументы функциям, ожидающим `float`. Они будут преобразованы во `float`. К примеру, модуль `math`, оперирующий `float` числами, может работать и с `Decimal` числами.

Приведенный ниже код:

```python
from decimal import *
from math import *

num1 = Decimal('1.44')
num2 = Decimal('0.523')

print(sqrt(num1))
print(sin(num2))
print(log(num1 + num2))
```

выводит:

```no-highlight
1.2
0.4994813555186418
0.6744739152943241
```

Важно понимать, что результатом работы функции модуля `math` являются `float` числа, а не `Decimal`.

Тип данных `Decimal` содержит некоторые встроенные математические методы, возвращающие значения `Decimal`.

|Функция|Описание|
|---|---|
|`sqrt()`|вычисляет квадратный корень из `Decimal` числа|
|`exp()`|возвращает exex для `Decimal` числа|
|`ln()`|вычисляет натуральный логарифм (по основанию ee) `Decimal` числа|
|`log10()`|вычисляет десятичный логарифм (по основанию 1010) `Decimal` числа|

Приведенный ниже код:

```python
from decimal import *

num = Decimal('10.0')

print(num.sqrt())
print(num.exp())
print(num.ln())
print(num.log10())
```

выводит:

```no-highlight
3.162277660168379331998893544
22026.46579480671651695790065
2.302585092994045684017991455
1
```

Обратите внимание на количество знаков в записи чисел. Их 2828, что соответствует точности десятичного числа по умолчанию.

Тип данных `Decimal` также содержит полезный метод `as_tuple()` который возвращает кортеж из 33 элементов:

- `sign` – знак числа (00 для положительного числа и 11 для отрицательного числа);
- `digits` – цифры числа;
- `exponent` – значение экспоненты (количество цифр после точки, умноженное на −1−1),

Приведенный ниже код:

```python
from decimal import *

num1 = Decimal('-1.4568769017')
num2 = Decimal('0.523')

print(num1.as_tuple())
print(num2.as_tuple())
```

выводит:

```no-highlight
DecimalTuple(sign=1, digits=(1, 4, 5, 6, 8, 7, 6, 9, 0, 1, 7), exponent=-10)
DecimalTuple(sign=0, digits=(5, 2, 3), exponent=-3)
```

Приведенный ниже код:

```python
from decimal import *

num = Decimal('-1.4568769017')
num_tuple = num.as_tuple()

print(num_tuple.sign)
print(num_tuple.digits)
print(num_tuple.exponent)
```

выводит:

```no-highlight
1
(1, 4, 5, 6, 8, 7, 6, 9, 0, 1, 7)
-10
```

### Работа с контекстом Decimal чисел

Базовые параметры `Decimal` можно посмотреть в его **контексте**, выполнив функцию `getcontext()`.

Приведенный ниже код:

```python
from decimal import *

print(getcontext())
```

выводит:

```no-highlight
Context(prec=28, rounding=ROUND_HALF_EVEN, Emin=-999999, Emax=999999, capitals=1, clamp=0, 
flags=[], traps=[InvalidOperation, DivisionByZero, Overflow])
```

Мы видим здесь, что точность 2828 знаков, округление к ближайшему четному, пределы по экспоненте ± 999999± 999999, `capitals` – это про заглавную Е при печати, включенные ловушки – неправильная операция, деление на ноль, переполнение.

### Точность чисел

Контекстом в `Decimal` можно управлять, устанавливая свои значения. Например, чтобы управлять точностью `Decimal`, необходимо изменить параметр контекста `prec` (от англ. precision – точность). При этом точность вступает в силу только во время арифметических операций, а не при создании самих чисел.

Приведенный ниже код:

```python
from decimal import *

getcontext().prec = 3      # устанавливаем точность в 3 знака

num = Decimal('3.1415')

print(num)
print(num * 1)
print(num * 2)
print(num / 2)
```

выводит:

```no-highlight
3.1415
3.14
6.28
1.57
```

Обратите внимание на то, что точность вступает в силу только во время арифметических операций, а не при создании самих чисел.

### Округление чисел

Округляют числа `Decimal` с помощью метода `quantize()`. Этот метод в качестве первого аргумента принимает объект `Decimal`, указывающий на формат округления.

Приведенный ниже код:

```python
from decimal import *

getcontext().prec = 4                    # устанавливаем точность числа

num = Decimal('3.1415926535')

print(num.quantize(Decimal('1.000')))    #  округление до 3 цифр в дробной части  
print(num.quantize(Decimal('1.00')))     #  округление до 2 цифр в дробной части
print(num.quantize(Decimal('1.0')))      #  округление до 1 цифр в дробной части
```

выводит:

```no-highlight
3.142
3.14
3.1
```

Если точность округления установлена в 22 , а формат округления `Decimal('1.00')`, то возникнет ошибка.

Приведенный ниже код:

```python
from decimal import *

getcontext().prec = 2                    # устанавливаем точность округления

num = Decimal('3.1415926535')

print(num.quantize(Decimal('1.00')))     #  округление до 2 цифр в дробной части
```

приводит к возникновению ошибки:

```1c
decimal.InvalidOperation: [<class 'decimal.InvalidOperation'>]
```

Чтобы избежать ее, необходимо поменять точность округления на 33 и больше.

Помимо первого параметра, метод `quantize()` принимает в качестве второго параметра стратегию округления:

- `ROUND_CEILING` – округление в направлении бесконечности (Infinity);
- `ROUND_FLOOR` – округляет в направлении минус бесконечности (- Infinity);
- `ROUND_DOWN` – округление в направлении нуля;
- `ROUND_HALF_EVEN` – округление до ближайшего четного числа, число 6.56.5 округлится не до 77, а до 66;
- `ROUND_HALF_DOWN` – округление до ближайшего нуля;
- `ROUND_UP` – округление от нуля;
- `ROUND_05UP` – округление от нуля (если последняя цифра после округления до нуля была бы 0 или 5, в противном случае к нулю).

Приведенный ниже код:

```python
from decimal import *

num = Decimal('3.456')

print(num.quantize(Decimal('1.00'), ROUND_CEILING))
print(num.quantize(Decimal('1.00'), ROUND_FLOOR))
```

выводит:

```no-highlight
3.46
3.45
```

### Сравнение float и Decimal чисел

Выбор между типами данных `Decimal` и `float` – поиск компромисса в условиях конкретной задачи.

Если нужно считать очень много (симуляции, физика, графика, игры), имеет смысл отказаться от точности `Decimal` в пользу скорости и компактности хранения данных `float`. В бизнесе и финансах считать приходится не так много, но делать это нужно предельно точно, тут имеет смысл посмотреть в сторону `Decimal`.

|   |   |   |
|---|---|---|
|**Характеристика / тип**|**float**|**Decimal**|
|Реализация|аппаратная|программная|
|Размер|6464 бит|не ограничен|
|Основание экспоненты|22|1010|
|Скорость|✔️|❌|
|Настраиваемость|❌|✔️|
|Для финансов и бизнеса|❌|✔️|
|Для симуляций, визуализаций и игр|✔️|❌|
|Для высокоточных вычислений|❌|✔️|

## Примечания

**Примечание 1.** `Decimal` числа можно сравнивать между собой, как обычные числа, причем в отличие от `float` чисел допускается и точное равенство.

```python
from decimal import *

num = Decimal('0.1')
if num*3 == Decimal('0.3'):
    print('YES')
else:
    print('NO')
```

**Примечание 2.** Можно сортировать списки с `Decimal` числами и искать минимум и максимум среди них.

Приведенный ниже код:

```python
from decimal import *

s = '1.34 3.45 1.00 0.03 9.25'

numbers = [Decimal(i) for i in s.split()]

maximum = max(numbers)
minimum = min(numbers)

numbers.sort()

print(maximum)
print(minimum)
print(numbers)
```

выводит:

```no-highlight
9.25
0.03
[Decimal('0.03'), Decimal('1.00'), Decimal('1.34'), Decimal('3.45'), Decimal('9.25')]
```

**Примечание 3.** Подробнее о типе данных Decimal можно почитать в официальной документации [тут](https://docs.python.org/3.8/library/decimal.html), [тут](https://docs.python.org/3.8/library/decimal.html#decimal-objects) и [тут](https://www.python.org/dev/peps/pep-0327/).

**Примечание 4.** Подробная статья об устройстве `float` чисел на [хабре](https://habr.com/post/112953/).

**Примечание 5.** О стандарте `Decimal` чисел от IBM можно почитать [тут](http://speleotrove.com/decimal/decarith.html).

**Примечание 6.** Чтобы не писать каждый раз название типа, можно использовать следующий код:

```python
from decimal import Decimal as D

num1 = D('1.5') + D('3.2')
num2 = D('1.4') * D('2.58')

print(num1)
print(num2)
```