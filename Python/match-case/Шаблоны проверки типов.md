

Давайте теперь усложним наш шаблон и в первом блоке case будем перехватывать все строковые команды, то есть, те, которые записаны в виде строки. Сделать это можно следующим образом:

```py
cmd = "top"
 
match cmd:
    case str() as command:
        print(f"строковая команда: {command}")
    case _:  # wildcard
        print(f"другая команда")
```

Смотрите, после case записано str(). Мы привыкли такую запись воспринимать как создание или пустой строки или преобразование объекта в строку. Здесь же это не что иное, как проверка переменной cmd строковому типу. То есть, если переменная cmd является строкой, то только в этом случае выполнится этот блок case и будет создана переменная command, которая, как и ранее, ссылается на значение переменной cmd.

Обратите еще раз внимание на конструкцию «str() as command». Вначале идет проверка строкового типа переменной cmd, и если это так, то после ключевого слова as можно указать переменную, которая будет ссылаться на эту строку. Кстати, если нам нужна только проверка на строковый тип данных, то фрагмент «as command» можно не писать, например:

```py
match cmd:
    case str():
        print(f"строковая команда")
    case _:  # wildcard
        print(f"другая команда")
```

Или, вместо «as command» можно написать:
```py
match cmd:
    case str(command):
        print(f"строковая команда: {command}")
    case _:  # wildcard
        print(f"другая команда")
```

Но выглядит это несколько путанно, так как в Python мы привыкли воспринимать такую конструкцию «str(command)», как преобразование объекта в строку. Поэтому предпочтительнее, на мой взгляд, использовать ключевое слово as.

По аналогии можно проверять и другие типы данных, например:

```py
cmd = 10
 
match cmd:
    case str() as command:
        print(f"строковая команда: {command}")
    case int() as command:
        print(f"целочисленная команда: {command}")
    case bool() as command:
        print(f"булева команда: {command}")
    case _:  # wildcard
        print(f"другая команда")
```

При выполнении этой программы будет выполнен второй блок case, так как переменная cmd целочисленная. Однако, если мы ей присвоим булево значение, например:
```py
cmd = True
```
то снова отработает второй блок case, а не третий, как этого можно было бы ожидать. Почему так произошло? Я думаю, что многие из вас уже догадались, что проверка на тип данных в операторах case выполняется по принципу функции isinstance(), то есть, с учетом цепочки наследования типов. В частности, булевый тип наследуется от целочисленного, поэтому isinstance() и для целых чисел и для булевых значений возвращает True.

Разрешить эту проблему очень просто. Так как шаблоны в операторах case проверяются по порядку (сверху-вниз), то сначала следует поставить проверку на булевый тип, а потом на целочисленный:

```py
match cmd:
    case str() as command:
        print(f"строковая команда: {command}")
    case bool() as command:
        print(f"булева команда: {command}")
    case int() as command:
        print(f"целочисленная команда: {command}")
    case _:  # wildcard
        print(f"другая команда")
```
Тогда все проверки на тип данных будут проходить корректно. По аналогии мы можем делать проверку на любые типы данных, которые имеются в языке Python.