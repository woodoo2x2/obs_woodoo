

Вместо конкретных значений после оператора case можно записывать переменные. Например, так:

```py
cmd = "top"
 
match cmd:
    case command:
        print(f"команда: {command}")
```

В результате при выполнении блока case будет создана переменная command (если ранее ее не было в программе) и ссылаться на то же значение, что и переменная cmd, то есть, на строку «top». Поэтому при выполнении программы увидим на экране сообщение:

```py
команда: top
```

То есть, фактически, в блоке case выполняется присваивание:

```py
command = cmd
```
и выводится значение переменной command в консоль. Причем, этот блок case будет выполняться всегда при любых значениях переменной cmd. Потому что такой шаблон не делает никаких проверок, он просто создает переменную command и присваивает значение переменной, указанной после оператора match. Причем, если после этого case прописать еще какой-либо, например:
```py
match cmd:
    case command:
        print(f"команда: {command}")
    case "top":
        print("top")
```

то возникнет синтаксическая ошибка, связанная с тем, что первым указан блок case, перехватывающий все возможные варианты, и все другие case просто игнорируются. Поэтому такой общий шаблон можно указывать только последним:

```py
match cmd:
    case "top":
        print("top")
    case command:
        print(f"команда: {command}")
```

И если здесь вместо переменной command прописать нижнее подчеркивание, то получим уже знакомый нам блок default (отбойник), который перехватывает все, что не вошло в предыдущие блоки:

```py
match cmd:
    case "top":
        print("top")
    case _:
        print(f"другая команда")
```

#Балакирев/Python 