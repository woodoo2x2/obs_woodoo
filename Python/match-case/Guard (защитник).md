

Давайте сделаем еще один шаг усложнения наших шаблонов и предположим, что для целочисленных команд дополнительно нужно проверять, чтобы они были в диапазоне от 0 до 9 включительно. Для этого после определения переменной command можно прописать ключевое слово if и указать дополнительное условие. В нашем случае оно будет выглядеть так:
```py
match cmd:
    case str() as command:
        print(f"строковая команда: {command}")
    case bool() as command:
        print(f"булева команда: {command}")
    case int() as command if 0 <= command <= 9:
        print(f"целочисленная команда: {command}")
    case _:  # wildcard
        print(f"другая команда")
```

Теперь блок «case int() as command if 0 <= command <= 9» отработает только в том случае, если переменная cmd является целочисленной и значение переменной command (которая ссылается на переменную cmd) лежит в диапазоне [0; 9]. Причем, обратите внимание, оператор if будет отрабатывать после команды int(), то есть, после проверки на целый тип данных и после формирования переменной command. Поэтому если проверка дошла до if, то мы точно знаем, что определена переменная command и она имеет целочисленный тип. Проверка шаблона в case всегда выполняется строго слева-направо.

В конструкции match/case оператор if получил название guard (то есть, защитник). Условия в этом операторе можно прописывать по тем же правилам, что и в условных операторах if языка Python.

По аналогии можно прописать guard и для строковых команд, например, так:
```py
cmd = "c_top"
 
match cmd:
    case str() as command if len(command) < 10 and command[0] == 'c':
        print(f"строковая команда: {command}")
    case bool() as command:
        print(f"булева команда: {command}")
    case int() as command if 0 <= command <= 9:
        print(f"целочисленная команда: {command}")
    case _:  # wildcard
        print(f"другая команда")
```
Если же какая-либо переменная может принимать несколько разных типов, например, int и float, то их можно записать через оператор ‘|’ следующим образом:

```py
case int() | float() as command if 0 <= command <= 9:
```

И так далее, то есть здесь мы можем определять любые нужные нам условия в шаблонах оператора case.

Возможно, некоторым из вас на протяжении всего занятия не давал покоя вопрос, зачем все это нужно. У нас же в Python есть условные операторы `if/elif/else` и через них можно делать все те же самые проверки? Все верно. Конструкция `match/case`не дает нам ничего принципиально нового. Она лишь может упростить написание программного кода (при ее грамотном использовании), а также повысить читаемость текста программы. Это, наверное, главные причины, по которым данные операторы были добавлены в язык Python. Как мы дальше увидим, шаблоны в операторах case позволяют очень гибко, просто и удобно обрабатывать коллекции с данными, но об этом речь пойдет уже на следующем занятии.