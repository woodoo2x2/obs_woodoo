## Словари

В прошлых уроках мы изучили четыре типа коллекций в Python:

- [[Тип данных list|Списки]] – изменяемые коллекции элементов, индексируемые;
- [[Тип данных str|Строки]] – неизменяемые коллекции символов, индексируемые;
- [[Тип данных tuple|Кортежи]] – неизменяемые коллекции элементов, индексируемые;
- [[Тип данных set|Множества]] – изменяемые коллекции уникальных элементов, неиндексируемые.

Следующий тип – **словари** – изменяемые коллекции элементов **с произвольными индексами – ключами**. Если в списках элементы индексируются целыми числами, начиная с `0`, то в словарях — любыми ключами, в том числе в виде строк.

Как нам уже известно, списки — удобный и самый популярный способ хранения большого количества данных в одной переменной. Списки индексируют все хранящиеся в них элементы, что позволяет быстро обращаться к элементу, зная его индекс. 

Приведенный ниже код:

```python
languages = ['Python', 'C#', 'Java', 'C++']

print(languages[0])
print(languages[2])
```

выводит:

```no-highlight
Python
Java
```

Допустим, мы хотим хранить имя создателя каждого языка программирования. Это можно сделать несколькими способами.

**Способ 1.** Хранить еще один список, где по соответствующему индексу будет находиться имя создателя языка программирования.

Приведенный ниже код:

```python
languages = ['Python', 'C#', 'Java', 'C++']
creators = ['Гвидо ван Россум', 'Андерс Хейлсберг', 'Джеймс Гослинг', 'Бьёрн Страуструп']

print('Создателем языка', languages[0], 'является', creators[0])
```

выводит:

```no-highlight
Создателем языка Python является Гвидо ван Россум
```

Подход рабочий, но хранить данные в двух коллекциях не очень удобно.

**Способ 2.** Хранить список кортежей с парами значений "язык - имя создателя" в каждом.

Приведенный ниже код:

```python
languages = [('Python', 'Гвидо ван Россум'), 
             ('C#', 'Андерс Хейлсберг'), 
             ('Java', 'Джеймс Гослинг'), 
             ('C++', 'Бьёрн Страуструп')]

print('Создателем языка', languages[2][0], 'является', languages[2][1])
```

выводит:

```no-highlight
Создателем языка Java является Джеймс Гослинг
```

Тоже рабочий подход, однако не очень эффективный. Придется написать цикл `for` для поиска по всем элементам списка `languages` кортежа, первый элемент которого равен искомому (названию языка). Чтобы найти автора языка C++ , нужно будет в цикле пройти мимо Python, C# и Java. Не получится угадать заранее, что язык C++ лежит после них.

Приведенный ниже код:

```python
languages = [('Python', 'Гвидо ван Россум'), 
             ('C#', 'Андерс Хейлсберг'), 
             ('Java', 'Джеймс Гослинг'), 
             ('C++', 'Бьёрн Страуструп')]

for item in languages:
    if item[0] == 'C++':
        print('Создателем языка', item[0], 'является', item[1])
```

выводит:

```no-highlight
Создателем языка C++ является Бьёрн Страуструп
```

Списки индексируются целыми числами, но в этом случае удобно было бы находить информацию не по числу, а по строке — названию языка программирования. В списках строки не могут быть индексами, однако в словарях это возможно.

Словарь (тип данных `dict`), как и список, позволяет хранить много данных. В отличие от списка, в словаре для каждого элемента можно произвольно определить «индекс» — **ключ**, по которому он будет доступен. 

Словарь — реализация структуры данных "ассоциативный массив" или "хеш таблица". В других языках аналогичная структура называется `map`, `HashMap`, `Dictionary`.

### Создание словаря

Чтобы создать словарь, нужно перечислить его элементы – пары ключ-значение – через запятую в фигурных скобках, как и элементы множества. Первым указывается ключ, после двоеточия — значение, доступное в словаре по этому ключу.

Приведенный ниже код:

```python
languages = {'Python': 'Гвидо ван Россум', 
             'C#': 'Андерс Хейлсберг', 
             'Java': 'Джеймс Гослинг', 
             'C++': 'Бьёрн Страуструп'}
```

создает словарь, в котором ключом служит строка — название языка программирования, а значением — имя создателя языка.

### Обращение к элементу словаря

Извлечь значение элемента словаря можно, обратившись к нему по его ключу. Чтобы получить значение по заданному ключу, как и в списках, используем квадратные скобки `[]` , индексируем по ключу.

**Способ 3.** Приведенный ниже код:

```python
languages = {'Python': 'Гвидо ван Россум', 
             'C#': 'Андерс Хейлсберг', 
             'Java': 'Джеймс Гослинг', 
             'C++': 'Бьёрн Страуструп'}

print('Создателем языка C# является', languages['C#'])
```

выводит:

```no-highlight
Создателем языка C# является Андерс Хейлсберг
```

В отличие от списков, номеров позиций в словарях нет.

Приведенный ниже код:

```python
languages = {'Python': 'Гвидо ван Россум', 
             'C#': 'Андерс Хейлсберг', 
             'Java': 'Джеймс Гослинг', 
             'C++': 'Бьёрн Страуструп'}

print('Создателем языка C# является', languages[1])
```

приводит к возникновению ошибки `KeyError`.

Ошибка `KeyError` возникнет и при попытке извлечь значение по несуществующему ключу. В качестве ключа можно указать выражение: Python вычислит его значение и обратится к искомому элементу.

**Способ 4.** Приведенный ниже код:

```python
languages = {'Python': 'Гвидо ван Россум', 
             'C#': 'Андерс Хейлсберг', 
             'Java': 'Джеймс Гослинг', 
             'C++': 'Бьёрн Страуструп'}

print('Создателем языка C# является', languages['C' + '#'])
```

выводит:

```no-highlight
Создателем языка C# является Андерс Хейлсберг
```

### Создание словаря с помощью функции dict()

Если ключи словаря — строки без каких-либо специальных символов, то для создания словаря можно использовать функцию [[Функция dict()|dict()]].

Приведенный ниже код:

```python
info = dict(name = 'Timur', age = 28, job = 'Teacher')
```

создает словарь с тремя элементами, ключами которого служат строки `'name'`, `'age'`, `'job'`, а значениями –  `'Timur'`, `28`, `'Teacher'`.


### Пустой словарь

**Пустой словарь** можно создать двумя способами:

- с помощью пустых фигурных скобок;
- с помощью функции `dict()`.

Приведенный ниже код:

```python
dict1 = {}
dict2 = dict()


print(dict1)
print(dict2)
print(type(dict1))
print(type(dict2))
```

создает два пустых словаря и выводит:

```1c
{}
{}
<class 'dict'>
<class 'dict'>
```

Вспомните, что создать пустое множество можно, только используя функцию `set()` , потому что пустые фигурные скобки зарезервированы для создания словаря.

### Вывод словаря

Для вывода всего словаря можно использовать функцию `print()`:

```python
languages = {'Python': 'Гвидо ван Россум', 
             'C#': 'Андерс Хейлсберг', 
             'Java': 'Джеймс Гослинг'}

info = dict(name = 'Timur', age = 28, job = 'Teacher')

print(languages)
print(info)
```

Функция `print()` выводит на экран элементы словаря в фигурных скобках, разделенные запятыми:

```
{'Python': 'Гвидо ван Россум', 'C#': 'Андерс Хейлсберг', 'Java': 'Джеймс Гослинг'}
{'name': 'Timur', 'age': 28, 'job': 'Teacher'}
```

Начиная с версии Python 3.63.6, словари являются упорядоченными, то есть сохраняют порядок следования ключей в порядке их внесения в словарь.

Словари принципиально отличаются от списков по структуре хранения в памяти. Список — последовательная область памяти, то есть все его элементы (указатели на элементы) действительно хранятся в указанном порядке, расположены последовательно. Благодаря этому и можно быстро «прыгнуть» к элементу по его индексу. В словаре же используется специальная структура данных — [[Структура данных хеш-таблица]]. Она позволяет вычислять числовой хеш от ключа и использовать обычные списки, где в качестве индекса элемента берется этот хеш.

В рамках одного словаря каждый ключ уникален.

 Словари удобно использовать для хранения различных сущностей. Например, если нужно работать с информацией о человеке, то можно хранить все необходимые сведения, включающие такие разные сущности как "возраст", "профессия", "название города", "адрес электронной почты" в одном словаре  `info` и легко обращаться к его элементам по ключам:

```python
info = {'name': 'Timur',
        'age': 28,
        'job': 'Teacher',
        'city': 'Moscow',
        'email': 'timyr-guev@yandex.ru'}

print(info['name'])
print(info['email'])
```

![](https://ucarecdn.com/6868ea52-8412-4284-a63e-8e1a388a40ec/)

Создать словарь на основании двух списков (кортежей) можно с помощью встроенной функции-упаковщика [[Функция zip()|zip()]], о которой расскажем позже.

Приведенный ниже код:

```python
keys = ['name', 'age', 'job']
values = ['Timur', 28, 'Teacher']

info = dict(zip(keys, values))

print(info)
```

выводит (порядок элементов может отличаться):

```
{'name': 'Timur', 'age': 28, 'job': 'Teacher'}
```

 В случае несовпадения длины списков функция самостоятельно отсечет лишние элементы.