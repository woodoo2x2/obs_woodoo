В случае простейшего множественного наследования алгоритм построения [[MRO (Method Resolution Order)]] не вызывает трудностей, так как представляет собой поиск в глубину, слева направо, то есть сперва проверяется иерархия первого родительского класса, затем иерархия второго родительского класса, и так далее, с последующим исключением из полученной последовательности повторяющихся классов, кроме их последних включений.

Если мы попытаемся самостоятельно определить MRO класса `D` из нашей ромбовидной иерархии:

```python
class A:
    pass
        
class B(A):
    pass
        
class C(A):
    pass

class D(B, C):
    pass
```

то сперва укажем класс `D`, затем иерархию первого родительского класса `B`, а после иерархию второго родительского класса `C`:

```no-highlight
D, B, A, object, C, A, object
```

Затем исключим из полученной последовательности повторяющиеся классы, кроме их последних включений, и получим MRO класса `D`:

```no-highlight
D, B, C, A, object
```

Данный способ не является решением в общем виде, он может служить лишь подсказкой при простейшем множественном наследовании, когда иерархии родительских классов представлены в виде линейных структур. В общем же случае алгоритм построения MRO имеет более сложный вид.


