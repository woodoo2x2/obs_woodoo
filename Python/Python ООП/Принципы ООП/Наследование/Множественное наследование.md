

В предыдущих уроках мы познакомились с наследованием, или точнее с **одиночным наследованием**, при котором класс наследуется от одного другого класса. Помимо этого в Python реализовано **множественное наследование**, при котором класс наследуется от двух или более классов одновременно. В этом случае дочерний класс наследует все атрибуты и методы всех родительских классов.

Синтаксис множественного наследования практически ничем не отличается от одиночного. Единственная разница в том, что при определении дочернего класса в скобках мы указываем не один родительский класс, а несколько через запятую:

```python
class Parent1:                                       # первый родительский класс
    pass

class Parent2:                                       # второй родительский класс
    pass

class Child(Parent1, Parent2):                       # дочерний класс
    pass
```

Важно не путать множественное наследование с многоуровневым наследованием. При множественном наследовании класс определяется как наследник двух или более классов одновременно, при многоуровневом наследовании каждый класс цепочки определяется как наследник лишь одного класса:

![](https://ucarecdn.com/de28ee02-ff8c-49dd-8577-a7c3b8534843/)

Рассмотрим иерархию из уже знакомых нам классов `Cat` и `Dog`, к которой добавим их наследника в лице класса `CatDog`, описывающего мультипликационного персонажа — котопса:

```python
class Cat:
    def meow(self):
        return 'мяу'

class Dog:
    def bark(self):
        return 'гав'

class CatDog(Cat, Dog):
    pass
```

[![](https://ucarecdn.com/4a6deea7-cb43-4dcb-8b92-e1b323df1e93/)](https://stepik.org/media/attachments/lesson/841344/%D0%9B%D1%8E%D0%B1%D0%B8%D0%BC%D1%8B%D0%B9_%D0%BC%D1%83%D0%BB%D1%8C%D1%82%D0%B8%D0%BA_%D0%A2%D0%B8%D0%BC%D1%83%D1%80%D0%B0.mp4)

В классе `Cat` определен метод `meow()`, в классе `Dog` определен метод `bark()`, и класс `CatDog`, являясь их наследником, может пользоваться обоими этими методами.

Приведенный ниже код:

```python
class Cat:
    def meow(self):
        return 'мяу'

class Dog:
    def bark(self):
        return 'гав'

class CatDog(Cat, Dog):
    pass


catdog = CatDog()

print(catdog.meow())
print(catdog.bark())
```

выводит:

```no-highlight
мяу
гав
```

Функционально множественное наследование повторяет одиночное наследование. Мы получаем возможность в дочернем классе пользоваться атрибутами и методами всех указанных родительских классов с последующим их переопределением или расширением. Однако множественное наследование, в отличие от одиночного, является потенциальным источником ошибок, которые могут возникнуть из-за наличия одинаковых имен атрибутов и методов в родительских классах.

  При множественном наследовании класс может иметь неограниченное количество родительских классов.

В одиночном, а точнее в многоуровневом наследовании, иерархия классов представляет собой линейную структуру, в которой классы располагаются в том порядке, в котором наследуются друг от друга. И здесь ситуация, когда в нескольких родительских классах определен метод с одним и тем же именем, не является проблемой: текущим классом будет унаследован метод того родительского класса, который ближе к текущему в иерархии.

Приведенный ниже код:

```python
class Animal:
    def sound(self):
        pass
    
class Cat(Animal):
    def sound(self):
        return 'мяу'

class Kitten(Cat):
    pass


kitten = Kitten()

print(kitten.sound())
```

выводит:

```no-highlight
мяу
```

В случае множественного наследования иерархия классов представляет собой ветвистую структуру, а не линейную, и зачастую бывает не так просто определить, одноименный метод какого родительского класса будет унаследован текущим классом.

## Проблема ромбовидного наследования

Проблема ромбовидного наследования — это типичная проблема при множественном наследовании. Она заключается в двусмысленности, возникающей, когда два класса `B` и `C` наследуются от класса `A`, а другой класс `D` наследуется от классов `B` и `C`.

Описанную иерархию можно изобразить следующим образом:

![](https://ucarecdn.com/c6d9a8bb-fc8c-45c7-852e-086fb9faf270/-/crop/448x416/0,18/-/preview/)

В обозначениях Python она будет иметь вид:

```python
class A:
    pass

class B(A):
    pass

class C(A):
    pass

class D(B, C):
    pass
```

Указанная выше диаграмма иерархии классов `A, B, C` и `D` представляет собой ромб, именно поэтому неоднозначность, возникающую при подобном наследовании, называют проблемой ромбовидного наследования. Проблемой, потому что, например, если в классе `A` есть метод `method()`, который класс `B` или `C` переопределил (или они оба переопределили), то возникает вопрос, какую версию этого метода должен унаследовать класс `D`?

Рассмотрим одну из упомянутых ситуаций. Определим одноименный метод в классах `A, B` и `C` и проверим, какой из них будет унаследован классом `D`.

Приведенный ниже код:

```python
class A:
    def method(self):
        print('Метод класса A')
        
class B(A):
    def method(self):
        print('Метод класса B')
        
class C(A):
    def method(self):
        print('Метод класса C')

class D(B, C):
    pass


d = D()

d.method()
```

выводит:

```no-highlight
Метод класса B
```

В данной ситуации класс `D` унаследовал метод класса `B`, и этот выбор не является случайным. В Python проблема ромбовидного наследования решается с помощью [[MRO (Method Resolution Order)]].

 При недавнем рассмотрении [[Функция super()]] было упомянуто, что она предоставляет доступ ко всем классам в иерархии наследования, а не к конкретному родительскому классу. При поиске необходимого метода в этой иерархии функция `super()` использует MRO.

Приведенный ниже код:

```python
class A:
    pass
        
class B(A):
    pass
        
class C(A):
    def method(self):
        print('Метод класса C')

class D(B, C):
    def method(self):
        super().method()


d = D()

d.method()
```

выводит:

```no-highlight
Метод класса C
```

 Обратите внимание, что даже самое простое множественное наследование является ромбовидным, так как все классы в Python являются наследниками класса `object`:

```python
class A(object):
    pass

class B(object):
    pass

class C(A, B):
    pass
```


При множественном наследовании атрибуты класса ведут себя так же, как и методы, то есть наследуются дочерним классом со всеми вытекающими особенностями.

Приведенный ниже код:

```python
class Animal:
    en_name = 'animal'
    ru_name = 'животное'

class Cat(Animal):
    en_name = 'cat'
    ru_name = 'кот'

class Dog(Animal):
    en_name = 'dog'
    ru_name = 'собака'
    
class CatDog(Cat, Dog):
    pass


print(CatDog.en_name)
print(CatDog.ru_name)
```

выводит:

```no-highlight
cat
кот
```

Попытка создать класс, MRO которого невозможно определить, приводит к возбуждению исключения.

Приведенный ниже код:

```python
class A:
    pass

class B(A):
    pass

class C(A, B):
    pass
```

приводит к возбуждению исключения:

```no-highlight
TypeError: Cannot create a consistent method resolution
order (MRO) for bases A, B
```