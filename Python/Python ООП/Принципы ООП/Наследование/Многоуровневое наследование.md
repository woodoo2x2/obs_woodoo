
Факт неявного наследования каждого класса от класса `object` позволяет сделать вывод, что с помощью наследования мы можем выстраивать иерархии классов, то есть, например, класс `C` может быть наследником класса `B`, который, в свою очередь, является наследником класса `A`: 

```python
class A:
    pass

class B(A):
    pass

class C(B):
    pass
```

![](https://ucarecdn.com/83df7aa9-9e84-4f2c-8a23-23ca72be0e36/)

Такое наследование называется **многоуровневым**. В данном случае класс `C` унаследует как атрибуты и методы класса `B`, так и класса `A`.

Приведенный ниже код:

```python
class A:
    def method_A(self):
        print('Метод класса A')

class B(A):
    def method_B(self):
        print('Метод класса B')

class C(B):
    pass


c = C()

c.method_A()
c.method_B()
```

выводит:

```no-highlight
Метод класса A
Метод класса B
```

Однако нужно иметь в виду, что если класс `B` переопределит некоторые методы класса `A`, то классу `C` будет предоставлены именно переопределенные их версии.

Приведенный ниже код:

```python
class A:
    def method(self):
        print('Метод класса A')

class B(A):
    def method(self):
        print('Метод класса B')

class C(B):
    pass


c = C()

c.method()
```

выводит:

```no-highlight
Метод класса B
```

Здесь мы уже можем окончательно понять, что при обращении к методу сперва он ищется в исходном классе, а затем во всей иерархии классов снизу вверх. Например, при обращении к методу класса `C` цепочка поиска будет следующей:

```no-highlight
C --> B --> A --> object
```

Не забывайте, что все классы являются наследниками класса `object`, поэтому он обязательно присутствует в любой иерархии.

Интересной особенностью является тот факт, что класс [[Тип данных bool]] является наследником класса [[Тип данных int]].

Приведенный ниже код:

```python
print(issubclass(bool, int))
print(issubclass(int, bool))

print(isinstance(True, bool))
print(isinstance(True, int))
```

выводит:

```no-highlight
True
False
True
True
```

