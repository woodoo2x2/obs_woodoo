

Если атрибуты отображают некоторые характеристики, которые свойственны объектам определенного класса, то методы определяют их поведение. В Python существует несколько типов методов, но в этом уроке мы сосредоточимся только на **методах экземпляра класса**. Метод экземпляра — это функция, которая определена внутри класса, принадлежит объекту этого класса и имеет доступ к атрибутам объекта.

   Как правило, названия методов экземпляра являются глаголами и соответствуют соглашению Snake case.

Рассмотрим пустой класс `Cat`, определим внутри него методы экземпляра `say()` и `eat()` и попробуем применить их к конкретному объекту.

Приведенный ниже код:

```python
​class Cat:
    def say(self):
        print('Мяу')

    def eat(self):
        print('Мням')


cat = Cat()

cat.say()
cat.eat()
```

выводит:

```python
Мяу
Мням
```

Обратите внимание, что за исключением того, что эти определения методов появляются в классе, они похожи на любое другое определение функции в Python. Они начинаются со строки заголовка, после которой идет выделенный отступом блок кода. Также следует заметить, что каждый метод имеет параметр `self`.

Параметр `self` требуется в каждом методе экземпляра. Метод оперирует атрибутами конкретного объекта, и когда метод исполняется, он должен знать, атрибутами какого объекта он должен оперировать. Именно здесь на первый план выходит параметр `self`. Когда метод вызывается, Python делает так, что параметр `self` ссылается на конкретный объект, который его вызвал в данный момент и которым вызванный метод должен оперировать.

  Параметр `self` часто называют **контекстным объектом**.

Иными словами, привычные нам вызовы методов через точечную нотацию:

```python
class Cat:
    def say(self):
        print('Мяу')

    def eat(self):
        print('Мням')


cat = Cat()

cat.say()
cat.eat()
```

Python преобразует в следующее:

```python
class Cat:
    def say(self):
        print('Мяу')

    def eat(self):
        print('Мням')


cat = Cat()

Cat.say(cat)
Cat.eat(cat)
```

поэтому оба приведенных выше кода являются эквивалентными и выводят:

```python
Мяу
Мням
```

Методы экземпляра доступны всем экземплярам соответствующего класса, поэтому мы можем создать несколько объектов класса `Cat`, и все они будут иметь общий функционал.

Приведенный ниже код:

```python
​class Cat:
    def say(self):
        print('Мяу')

    def eat(self):
        print('Мням')


cat1 = Cat()
cat2 = Cat()

cat1.say()
cat2.eat()
```

выводит:

```no-highlight
​Мяу
Мням
```

Важно отметить, что параметр `self` — это обычная переменная, она может называться по-другому, но так категорически не рекомендуется делать. Соглашение об имени контекстного объекта — самое строгое из всех соглашений в мире Python. Если нарушить это соглашение, другие программисты просто не будут понимать ваш код. Кроме того, некоторые текстовые редакторы подсвечивают слово `self` определенным цветом, что довольно удобно.

Таким образом, при создании собственных методов экземпляра следует помнить о двух моментах:

- метод должен быть определен внутри класса (добавляется уровень отступов)
- метод всегда должен иметь хотя бы один параметр, и первый по счету параметр должен называться `self`

В примере выше методы `say()` и `eat()`, помимо экземпляра класса, не принимали никаких аргументов. Однако методы являются функциями, поэтому мы без проблем можем расширить их функционал, например, добавив дополнительный параметр.

Приведенный ниже код:

```python
class Cat:
    def say(self, sound):
        print(sound)

    def eat(self, meal):
        print(f'{meal} - это очень вкусно!')


cat1 = Cat()
cat2 = Cat()

cat1.say('Мяу')
cat1.eat('Молоко')

cat2.say('Мяяяу!')
cat2.eat('Рыба')
```

выводит:

```no-highlight
Мяу
Молоко - это очень вкусно!
Мяяяу!
Рыба - это очень вкусно!
```

Применение метода к объекту преобразуется в вызов функции, путем обращения к ней через соответствующий класс и передачи ей в качестве аргумента объекта, который этот метод вызвал.

Приведенный ниже код:

```python
nums = [1, 2, 3]
text = 'beegeek'

nums.append(4)
text = text.lower()
```

эквивалентен следующему коду:

```python
nums = [1, 2, 3]
text = 'beegeek'

list.append(nums, 4)
text = str.lower(text)
```

Это достаточно удобно использовать, если нам требуется воспользоваться методом как функцией.

Приведенный ниже код:

```python
names = ['timur', 'arthur', 'dima']

print(*map(str.title, names))
```

выводит:

```no-highlight
Timur Arthur Dima
```