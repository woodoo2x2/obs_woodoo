

Ранее мы упоминали, что доступ к атрибутам объекта должны иметь только методы этого объекта. Такой подход защищает атрибуты от случайного повреждения. Однако во всех рассмотренных ранее классах атрибуты не являлись защищенными, ведь внешний код с легкостью мог получить к ним доступ .

В классических языках программирования (C++, Java, C#) доступ к атрибутам реализуется с помощью ключевых слов `protected` (защищенный), `private` (приватный) и `public` (публичный):

- доступ к защищенным атрибутам возможен только внутри этого класса, а также внутри унаследованных от него классов
- приватные атрибуты недоступны извне — с ними можно работать только внутри этого класса
- публичные атрибуты доступны для работы снаружи

С точки зрения разграничения доступа к атрибутам Python является особенным языком — в нем отсутствует механизм, который мог бы запретить внешнему коду взаимодействовать с атрибутами объекта или класса. Вместо этого создатели Python предложили следующий ряд соглашений:

- если имя атрибута начинается с одного нижнего подчеркивания (`_name`), то он считается **защищенным**
- если имя атрибута начинается с двух нижних подчеркиваний (`__name`), то он считается **приватным**

В Python все атрибуты являются публичными по умолчанию. Любой атрибут объекта может быть доступен за пределами класса, независимо от того, является он публичным, защищенным или приватным.

Приведенный ниже код:

```python
class Cat:
    def __init__(self, name):
        self.name = name


cat = Cat('Кемаль')
print(cat.name)

cat.name = 'Роджер'
print(cat.name)
```

выводит:

```no-highlight
Кемаль
Роджер
```

Как мы видим, никаких проблем не возникает ни при обращении к атрибутам, ни при их изменении. Аналогичное поведение наблюдается и с защищенными атрибутами, то есть атрибутами, имя которых начинается с одного символа нижнего подчеркивания.

Приведенный ниже код:

```python
class Cat:
    def __init__(self, name):
        self._name = name


cat = Cat('Кемаль')
print(cat._name)

cat._name = 'Роджер'
print(cat._name)
```

выводит:

```no-highlight
Кемаль
Роджер
```

Иными словами, это больше вопрос ответственности программиста — он не должен работать за пределами класса с атрибутами, имена которых начинаются с нижнего подчёркивания.

Несколько иначе себя ведут приватные атрибуты. Если мы предварим имя атрибута двумя нижними подчеркиваниями, то есть сделаем его приватным, то код за пределами класса не сможет получить к нему доступ напрямую.

Приведенный ниже код:

```python
class Cat:
    def __init__(self, name):
        self.__name = name


cat = Cat('Кемаль')

print(cat.__name)
```

приводит к возбуждению исключения:

```no-highlight
AttributeError: 'Cat' object has no attribute '__name'
```

На первый взгляд может показаться, что для внешнего кода приватного атрибута действительно не существует, однако если мы посмотрим на содержимое словаря атрибутов объекта, то увидим, что на самом деле приватный атрибут лишь получил другое имя.

Приведенный ниже код:

```python
class Cat:
    def __init__(self, name):
        self.__name = name


cat = Cat('Кемаль')

print(cat.__dict__)
```

выводит: 

```no-highlight
{'_Cat__name': 'Кемаль'}
```

Дело в том, что, делая атрибут приватным, на самом деле мы лишь неявно изменяем его имя. Такое поведение называется **искажением имени**.

Любой атрибут вида `__name` текстуально заменяется на `_class__name`, где `class` — это имя текущего класса.

Таким образом, возможность обратиться к приватному атрибуту, а также изменить его значение все же остается.

Приведенный ниже код:

```python
class Cat:
    def __init__(self, name):
        self.__name = name


cat = Cat('Кемаль')

cat._Cat__name = 'Роджер'

print(cat.__dict__)
```

выводит:

```no-highlight
{'_Cat__name': 'Роджер'}
```

Физически механизм ограничения доступа к атрибутам в Python реализован слабо, лишь на уровне соглашения, поэтому ответственность за соблюдение данного соглашения ложится на плечи программистов.

Искажение имени приватного атрибута происходит лишь при его установке внутри класса. 

Приведенный ниже код:

```python
class Cat:
    def __init__(self, name):
        self.__name = name


cat = Cat('Кемаль')

cat.__age = 1

print(cat.__dict__)
```

выводит:

```python
{'_Cat__name': 'Кемаль', '__age': 1}
```