

Многие встроенные типы поддерживают операции сложения, вычитания, умножения и деления с помощью операторов `+, -, *, /, //` и `%`.

Приведенный ниже код:

```python
num1 = 50
num2 = 20

print(num1 + num2)
print(num1 - num2)
print(num1 * num2)
print(num1 / num2)
print(num1 // num2)
print(num1 % num2)
```

выводит:

```no-highlight
70
30
1000
2.5
2
10
```

Чтобы разрешить выполнять с экземплярами нашего класса различные арифметические операции, нам требуется определить в классе соответствующие магические методы:

- `__add__()` — определяет поведение для сложения (оператор `+`)
- `__sub__()` — определяет поведение для вычитания (оператор `-`)
- `__mul__()` — определяет поведение для умножения (оператор `*`)
- `__truediv__()` — определяет поведение для обычного деления (оператор `/`)
- `__floordiv__()` — определяет поведение для целочисленного деления (оператор `//`)
- `__mod__()` — определяет поведение для деления по модулю (оператор `%`)

Рассмотрим класс `PiggyBank`, описывающий копилку. Определим в классе магический метод `__add__()`, который позволит складывать экземпляр класса `PiggyBank` с целым числом, характеризующим количество монет. Результатом такой операции будет новый экземпляр класса `PiggyBank` с увеличенным количеством монет.

Приведенный ниже код:

```python
class PiggyBank:
    def __init__(self, coins):
        self.coins = coins                     # количество монет в копилке

    def __repr__(self):
        return f'PiggyBank({self.coins})'

    def __add__(self, other):
        return PiggyBank(self.coins + other)


bank1 = PiggyBank(10)
bank2 = bank1 + 5
bank3 = bank1 + 15

print(bank1)
print(bank2)
print(bank3)
```

выводит:

```no-highlight
PiggyBank(10)
PiggyBank(15)
PiggyBank(25)
```

Обратите внимание, что результатами арифметических операций являются новые объекты того же класса.

Так как арифметические операции реализуются с помощью магических методов, мы можем сделать их более функциональными. Например, мы можем определить сложение экземпляров класса `PiggyBank` не только с целыми числами, но и с другими экземплярами класса `PiggyBank`.

Приведенный ниже код:

```python
class PiggyBank:
    def __init__(self, coins):
        self.coins = coins

    def __repr__(self):
        return f'PiggyBank({self.coins})'

    def __add__(self, other):
        if isinstance(other, int):
            return PiggyBank(self.coins + other)
        elif isinstance(other, PiggyBank):
            return PiggyBank(self.coins + other.coins)
        return NotImplemented


bank1 = PiggyBank(10)
bank2 = bank1 + 5
bank3 = bank1 + bank2

print(bank1)
print(bank2)
print(bank3)
```

выводит:

```no-highlight
PiggyBank(10)
PiggyBank(15)
PiggyBank(25)
```

Аналогичным образом мы можем реализовать любую необходимую арифметическую операцию, определив в классе соответствующий магический метод.


Определив в классе магический метод `__pow__()`, можно выполнять операцию возведения в степень с помощью оператора `**`.
Определив в классе магический метод `__divmod__()`, можно передавать экземпляры класса во встроенную функцию `divmod()`

 Помимо арифметических операций, в Python существуют операции двоичного сдвига и логические операции. Как и прежде, они реализуются с помощью соответствующих магических методов:

- `__lshift__()` — определяет поведение для двоичного сдвига влево (оператор `<<`)
- `__rshift__()` — определяет поведение для двоичного сдвига вправо (оператор `>>`)
- `__and__()` — определяет поведение для двоичного И (оператор `&`)
- `__or__()` — определяет поведение для двоичного ИЛИ (оператор `|`)
- `__xor__()` — определяет поведение для двоичного XOR, (оператор `^`)
Все приведенные выше методы также имеют отраженные версии ([[Отраженные арифметические операции]]).

После реализации в классе операторов сложения появляется возможность складывать экземпляры этого класса с помощью [[Функция sum()]].

Приведенный ниже код:

```py
class PiggyBank:
    def __init__(self, coins):
        self.coins = coins

    def __repr__(self):
        return f'PiggyBank({self.coins})'

    def __add__(self, other):
        if isinstance(other, int):
            return PiggyBank(self.coins + other)
        elif isinstance(other, PiggyBank):
            return PiggyBank(self.coins + other.coins)
        return NotImplemented

    def __radd__(self, other):
        return self.__add__(other)


banks = [PiggyBank(10), PiggyBank(20), PiggyBank(30)]

print(sum(banks))
```

выводит:

```no-highlight
PiggyBank(60)
```