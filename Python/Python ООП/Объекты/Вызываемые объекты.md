

C самого начала изучения Python мы используем функции, как встроенные, так и написанные самостоятельно. Отличительной особенностью функций является то, что их можно вызывать с помощью круглых скобок `()`, передавая необходимый набор аргументов, если это требуется.

Приведенный ниже код:

```python
def add(a, b):
    return a + b

mul = lambda a, b: a * b

print(add(1, 2))                           # вызываем собственную функцию
print(mul(1, 2))                           # вызываем собственную лямбда функцию
print(len([1, 2, 3]))                      # вызываем встроенную функцию
```

выводит:

```no-highlight
3
2
3
```

Любая функция является вызываемой, то есть представляет собой объект, который можно вызвать. Однако не только функции являются вызываемыми. Например, если мы вызовем встроенную функцию [[Функция map()]], то в качестве результата получим [[Объект]] типа `map`.

Приведенный ниже код:

```python
numbers = map(abs, [-1, 2, -3, 4, -5])

print(numbers)
print(type(numbers))
```

выводит (адрес может отличаться):

```no-highlight
<map object at 0x0000028C708A6C80>
<class 'map'>
```

Что дает нам заключить, что на самом деле `map()` является не функцией, а [[Класс|классом]].

Приведенный ниже код:

```no-highlight
print(map)
```

выводит:

```no-highlight
<class 'map'>
```

Дело в том, что зачастую мы не совсем четко используем слово "функция", так как мыслим в терминах **утиной типизации**. Мы называем `map()` функцией, потому что она ведет себя как функция (мы можем ее вызвать с помощью круглых скобок). Но корректнее будет назвать `map()` **вызываемым объектом**.

Утиная типизация — это концепция, характерная для языков программирования с динамической типизацией, согласно которой конкретный класс объекта не важен, а важны лишь свойства и методы, которыми этот объект обладает.

Таким образом, и функции, и классы в Python являются вызываемыми объектами.

Функции и классы являются вызываемыми, однако мы можем создать собственные вызываемые объекты, реализовав в классе магический метод [[Магический метод __call__()]]. Данный метод позволяет экземплярам класса вести себя так, как будто они функции, то есть мы можем вызывать их, передавать их в функции, которые ожидают в качестве аргумента функцию, и так далее.

Чтобы проверить, является ли объект вызываемым, нужно проверить у него наличие метода `__call__()`.

Приведенный ниже код:

```python
print(hasattr(int, '__call__'))
print(hasattr(len, '__call__'))
print(hasattr(1, '__call__'))
```

выводит:

```no-highlight
True
True
False
```

Однако на практике для этого используется встроенная [[Функция callable()]], которая возвращает `True`, если переданный объект является вызываемым, или `False` в противном случае.

Приведенный ниже код:

```python
print(callable(int))
print(callable(len))
print(callable(1))
```

выводит:

```no-highlight
True
True
False
```
[[Замыкания]] — это особый вид функции. Она определена в теле другой функции и создаётся каждый раз во время её выполнения. Синтаксически это выглядит как функция, находящаяся целиком в теле другой функции. При этом вложенная функция содержит ссылки на локальные переменные внешней функции. Каждый раз при выполнении внешней функции происходит создание нового экземпляра внутренней функции, с новыми ссылками на переменные внешней функции.