

Как уже говорилось ранее, при сравнении двух объектов с помощью оператора `==` Python автоматически вызывает метод [[Магические методы __eq__() и __ne__()|__eq__]] у первого объекта, передавая методу в качестве аргумента второй. Однако если мы попробуем вызвать метод `__eq__()` у объекта, в классе которого данный метод не реализован, вместо значений `True` или `False` мы получим значение `NotImplemented`.

Приведенный ниже код:

```python
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y


p1 = Point(1, 2)
p2 = Point(1, 2)

print(p1.__eq__(p2))
```

выводит:

```no-highlight
NotImplemented
```

Дело в том, что когда мы пытаемся сравнить два объекта с помощью оператора `==`, например, `p1` и `p2`, Python сначала вызывает метод `__eq__()` у первого объекта `p1`, и если метод возвращает значение `True` или `False`, оно становится результатом сравнения. Но если метод возвращает константу `NotImplemented`, Python вызывает метод `__eq__()` у второго объекта `p2`. Аналогично, если метод второго объекта возвращает значение `True` или `False`, оно становится результатом сравнения, однако если метод вновь возвращает `NotImplemented`, результатом сравнения становится значение `False`, так как `p1` не знает, как сравнивать себя с `p2`, как и `p2` не знает, как сравнивать себя с `p1`.

Именно константу `NotImplemented` рекомендуется возвращать в методе `__eq__()`, если сравнение для объектов каких-либо типов не определено.

Приведенный ниже код:

```python
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __eq__(self, other):
        if isinstance(other, Point):
            return self.x == other.x and self.y == other.y
        return NotImplemented


p1 = Point(1, 2)
p2 = Point(1, 2)

print(p1 == p2)
print(p1 == None)
print(p1 == (1, 2))
```

выводит:

```no-highlight
True
False
False
```