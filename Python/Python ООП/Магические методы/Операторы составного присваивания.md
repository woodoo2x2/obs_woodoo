

Помимо основных арифметических операторов (`+, -, *` и т.д.), в Python есть операторы составного присваивания (`+=, -=, *=`  и т.д.). Главным отличием данных операторов является то, что первые всегда создают новый объект, в то время как вторые изменяют исходный объект, если он принадлежит изменяемому типу данных.

Приведенный ниже код:

```python
nums = [1, 2, 3]
print(id(nums), nums)

nums = nums + [4, 5, 6]
print(id(nums), nums)
```

выводит (адреса могут отличаться):

```no-highlight
1912325834112 [1, 2, 3]
1912378506496 [1, 2, 3, 4, 5, 6]
```

В то время как приведенный ниже код:

```python
nums = [1, 2, 3]
print(id(nums), nums)

nums += [4, 5, 6]
print(id(nums), nums)
```

выводит (адреса могут отличаться):

```no-highlight
2891153376640 [1, 2, 3]
2891153376640 [1, 2, 3, 4, 5, 6]
```

 Поведение операторов составного присваивания определяется соответствующими магическими методами:

- `__iadd__()` — определяет поведение для сложения (оператор `+=`)
- `__isub__()` — определяет поведение для вычитания (оператор `-=`)
- `__imul__()` — определяет поведение для умножения (оператор `*=`)
- `__itruediv__()` — определяет поведение для обычного деления (оператор `/=`)
- `__ifloordiv__()` — определяет поведение для целочисленного деления (оператор `//=`)
- `__imod__()` — определяет поведение для деления по модулю (оператор `%=`)

Префикс `i` в названиях методов составного присваивания является сокращением слова inplace (на месте).

Рассмотрим класс `PiggyBank`, описывающий копилку. Определим в классе магический метод `__add__()`, который позволит складывать экземпляр класса `PiggyBank` с целым числом, характеризующим количество монет. Результатом такой операции будет новый экземпляр класса `PiggyBank` с увеличенным количеством монет. Также определим в классе магический метод `__iadd__()`, реализующий аналогичную операцию сложения с целым числом, однако результатом которой будет исходный измененный объект, так как экземпляры класса `PiggyBank` являются изменяемыми.

Приведенный ниже код:

```python
class PiggyBank:
    def __init__(self, coins):
        self.coins = coins                         # количество монет в копилке

    def __repr__(self):
        return f'PiggyBank({self.coins})'

    def __add__(self, other):
        return PiggyBank(self.coins + other)       # создаем и возвращаем новый объект

    def __iadd__(self, other):
        self.coins += other
        return self                                # возвращаем измененный объект


bank = PiggyBank(10)

bank += 10
bank += 5

print(bank)
```

выводит:

```no-highlight
PiggyBank(25)
```

Аналогичным образом мы можем реализовать любую необходимую арифметическую операцию с помощью оператора составного присваивания, определив в классе соответствующий магический метод. И если экземпляры класса являются изменяемыми, результатом такой операции должен являться измененный исходный экземпляр.

Если в классе не определены магические методы с префиксом `i`, но определены их основные версии (без префикса `i`), то операторами составного присваивания пользоваться можно. Однако результатами таких арифметических операций всегда будут новые объекты. Это удобно в том случае, когда экземпляры класса являются неизменяемыми.

Приведенный ниже код:

```python
class PiggyBank:
    def __init__(self, coins):
        self.coins = coins

    def __repr__(self):
        return f'PiggyBank({self.coins})'

    def __add__(self, other):
        print('Вызов метода __add__()')
        return PiggyBank(self.coins + other)

    def __iadd__(self, other):
        print('Вызов метода __iadd__()')
        self.coins += other
        return self


bank = PiggyBank(10)

bank += 10

print(bank)
```

выводит:

```no-highlight
Вызов метода __iadd__()
PiggyBank(20)
```

В то время как приведенный ниже код:

```python
class PiggyBank:
    def __init__(self, coins):
        self.coins = coins

    def __repr__(self):
        return f'PiggyBank({self.coins})'

    def __add__(self, other):
        print('Вызов метода __add__()')
        return PiggyBank(self.coins + other)


bank = PiggyBank(10)

bank += 10                       # вызовы методов с префиксом i делигируются их основным версиям

print(bank)
```

выводит:

```no-highlight
Вызов метода __add__()
PiggyBank(20)
```

Для неизменяемых объектов арифметические операции с операторами составного присваивания равнозначны обычным арифметическим операциям и являются, по сути, лишь краткой записью.

Приведенный ниже код:

```python
num = 10
print(id(num), num)

num += 5                         # создается новый объект, так как исходный является неизменямым
print(id(num), num)
```

выводит (адреса могут отличаться):

```no-highlight
2275079553552 10
2275079553712 15
```

Таблица всех операторов составного присваивания:

|Составной оператор|Магический метод|
|---|---|
|`+=`|`__iadd__()`|
|`-=`|`__isub__()`|
|`*=`|`__imul__()`|
|`/=`|`__itruediv__()`|
|`//=`|`__ifloordiv__()`|
|`%=`|`__imod__()`|
|`**=`|`__ipow__()`|
|`<<=`|`__ilshift__()`|
|`>>=`|`__irshift__()`|
|`&=`|`__iand__()`|
|`^=`|`__ixor__()`|
|`\|=`|`__ior__()`|