[[Дескрипторы|Дескриптор]] — это объект, для которого определены методы протокола дескриптора `__get__(), __set__()` и `__delete__()`, реализующие поведение при доступе к объекту как к атрибуту. При получении значения дескриптора вызывается метод `__get__()`, при изменении значения вызывается метод `__set__()`, а при удалении вызывается метод `__delete__()`. Определяя в классе данные методы, мы можем создавать собственные дескрипторы.

Вернемся к классу `Cat`, описывающему кошку, экземпляры которого имеют атрибут `name`, содержащий имя:

```python
class Cat:
    def __init__(self, name):
        self.name = name
```

Под корректным именем мы понимаем любую непустую строку, поэтому хотим, чтобы при его установке или изменении присутствовала проверка на корректность. Мы можем решить данную проблему с помощью функции [[Функция property()]], однако теперь попробуем сделать это с помощью собственного дескриптора `NonEmptyString`:

```python
class NonEmptyString:
    def __init__(self, attr):
        self._attr = attr

    def __get__(self, obj, cls):
        if self._attr in obj.__dict__:
            return obj.__dict__[self._attr]
        else:
            raise AttributeError('Атрибут не существует')

    def __set__(self, obj, value):
        if isinstance(value, str) and len(value) > 0:
            obj.__dict__[self._attr] = value
        else:
            raise ValueError('Некорректное значение')
        
    def __delete__(self, obj):
        del obj.__dict__[self._attr]
```

Рассмотрим методы дескриптора. Метод `__init__()` имеет параметр `attr`, целью которого является получение имени, за которым будет закреплен дескриптор. Метод `__get__()` возвращает из словаря`__dict__` объекта `obj` значение атрибута `attr`, если он там есть. То есть при обращении к дескриптору как к атрибуту мы будем получать значение необходимого атрибута объекта. Метод `__set__()` изменяет значение атрибута `attr` в словаре`__dict__` объекта `obj`, предварительно проверяя устанавливаемое значение на корректность. То есть при изменении значения дескриптора с помощью оператора присваивания `=` мы будем изменять значение атрибута объекта. Метод `__delete__()` удаляет из словаря объекта атрибут `attr`.

В методах протокола дескрипторов необходимо напрямую обращаться к словарю объекта `__dict__`, чтобы избежать исключения `RecursionError`, так как иные обращения к атрибуту будут перехватываться протоколом дескрипторов.

Приведенный ниже код:

```python
class NonEmptyString:
    def __init__(self, attr):
        self._attr = attr

    def __get__(self, obj, cls):
        if self._attr in obj.__dict__:
            return obj.__dict__[self._attr]
        else:
            raise AttributeError('Атрибута не существует')

    def __set__(self, obj, value):
        if isinstance(value, str) and len(value) > 0:
            obj.__dict__[self._attr] = value
        else:
            raise ValueError('Некорректное значение')
        
    def __delete__(self, obj):
        del obj.__dict__[self._attr]

class Cat:
    name = NonEmptyString('name')

    def __init__(self, name):
        self.name = name


cat = Cat('Кемаль')
print(cat.name)

cat.name = 'Роджер'
print(cat.name)

del cat.name
print(hasattr(cat, 'name'))
```

выводит:

```no-highlight
Кемаль
Роджер
False
```

Для большей наглядности мы можем добавить в методы протокола дескриптора вывод некоторого сообщения, чтобы проследить за тем, когда эти методы вызываются.

Приведенный ниже код:

```python
class NonEmptyString:
    def __init__(self, attr):
        self._attr = attr

    def __get__(self, obj, cls):
        print('Вызов метода __get__()')
        if self._attr in obj.__dict__:
            return obj.__dict__[self._attr]
        else:
            raise AttributeError('Атрибута не существует')

    def __set__(self, obj, value):
        print('Вызов метода __set__()')
        if isinstance(value, str) and len(value) > 0:
            obj.__dict__[self._attr] = value
        else:
            raise ValueError('Некорректное значение')
        
    def __delete__(self, obj):
        print('Вызов метода __delete__()')
        del obj.__dict__[self._attr]

class Cat:
    name = NonEmptyString('name')

    def __init__(self, name):
        self.name = name


cat = Cat('Кемаль')

cat.name
cat.name = 'Роджер'
del cat.name
```

выводит:

```no-highlight
Вызов метода __set__()
Вызов метода __get__()
Вызов метода __set__()
Вызов метода __delete__()
```

Обратите внимание на первый вызов метода `__set__()`, он происходит внутри метода `__init__()` при инициализации экземпляра класса. В строке `self.name = name` выполняется обращение к дескриптору `name`, что влечет за собой вызов метода `__set__()`, уже внутри которого объекту устанавливается атрибут `name` со значением `Кемаль`. Важно понимать, что в строке `self.name = name` мы обращаемся именно к дескриптору и вызываем его методы, а не просто устанавливаем объекту новый атрибут.

Также следует отметить, что дескрипторы являются атрибутами класса и создаются единожды при определении класса. Это значит, что все экземпляры класса используют один и тот же дескриптор. Поэтому дескрипторы внутренне не хранят значения атрибутов, но они хранят имена атрибутов, с помощью которых могут получить доступ к значениям этих атрибутов.

Свойства, как и другие дескрипторы, являются атрибутами класса.
