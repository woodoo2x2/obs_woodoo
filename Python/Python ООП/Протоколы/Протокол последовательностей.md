

 **последовательности** — коллекции, элементы которых пронумерованы индексами и расположены в строгом порядке. В Python существует несколько типов, подходящих под это определение, и несмотря на то что они имеют ряд различий между собой, все они могут обрабатываться одинаково. Поэтому если объект ведет себя как последовательность, то мы считаем его последовательностью, независимо от его типа. Или более формально: если объект удовлетворяет протоколу последовательности, то он является последовательностью.

**Утиная типизация** заключается в том, что, вместо проверки типа чего-либо в Python, мы склонны проверять, какое поведение оно поддерживает: если что-то похоже на утку и крякает как утка, то это утка.

Итак, последовательностью считается объект, поддерживающий следующие операции:

- индексация
- срезы
- проверка на принадлежность (оператор `in`)
- наличие длины
- итерирование

К уже знакомым нам последовательностям можно отнести такие типы как [[Тип данных list]], [[Тип данных str]], [[Тип данных tuple]] и range. Если мы рассмотрим, например, типы `list` и `str`, то отметим, что списки являются изменяемыми, а строки нет. Также списки в качестве элементов могут содержать объекты произвольных типов, в то время как строки, по сути, представляют собой коллекции символов. Однако и списки, и строки, являются последовательностями, так как удовлетворяют протоколу последовательности.

Объект типа `range` отличается тем, что не хранит явно все элементы последовательности в памяти. Он хранит только начальное значение, конечное значение и шаг последовательности.

Объект считается последовательностью, если он ведет себя как последовательность. Поэтому мы можем создавать собственные классы, определяя в них все операции последовательности путем добавления соответствующих магических методов, таким образом превращая их экземпляры в последовательности.

Последовательности бывают изменяемые и неизменяемые, и вторые несколько проще, так как не поддерживают добавление и удаление элементов, то есть в них определено меньшее количество магических методов, поэтому мы начнем именно с них.

Для реализации протокола неизменяемой последовательности необходимо определить следующие магические методы:

- [[Магический метод __len__()]] — определяет поведение при передаче в [[Функция len()]], возвращает количество элементов в последовательности
- [[Магический  метод __getitem__()]] — определяет поведение при доступе к элементу, используя синтаксис `self[key]` 
- [[Магический метод __iter__()]] — определяет поведение при передаче в [[Функция iter()]], возвращает итератор для последовательности
-[[ Магический метод __contains__()]] — определяет поведение при проверке на принадлежность с помощью оператора `in` (`not in`)

Рассмотрим класс `Order`, описывающий список покупок, экземплярами которого являются неизменяемые последовательности.

Приведенный ниже код:

```python
class Order:
    def __init__(self, cart, customer):
        self.cart = list(cart)                  # список покупок
        self.customer = customer                # имя покупателя

    def __len__(self):
        return len(self.cart)

    def __getitem__(self, key):
        if not isinstance(key, int):
            raise TypeError('Индекс должен быть целым числом')
        if key < 0 or key >= len(self.cart):
            raise IndexError('Неверный индекс')
        return self.cart[key]

    def __contains__(self, item):
        return item in self.cart

    def __iter__(self):
        yield from self.cart


order = Order(['банан', 'яблоко', 'лимон'], 'Кемаль')

print(len(order))
print(order[1])
print('дыня' in order)
print('лимон' in order)
print(*order, sep=', ')
```

выводит:

```no-highlight
3
яблоко
False
True
банан, яблоко, лимон
```

Обратите внимание, что метод `__getitem__()` в качестве аргумента `key` принимает индекс, а метод `__contains__()` в качестве аргумента `item` принимает объект, наличие которого требуется проверить.

Для реализации протокола изменяемой последовательности необходимо к вышеуказанным методам добавить следующие магические методы:

- [[Магический метод __setitem__()]] — определяет поведение при присваивании значения элементу, используя синтаксис `self[key] = value`
- [[Магический метод __delitem__()]] — определяет поведение при удалении элемента с помощью оператора `del`

Приведенный ниже код:

```python
class Order:
    def __init__(self, cart, customer):
        self.cart = list(cart)
        self.customer = customer

    def check_key(self, key):                   # отдельный метод для проверки индекса на корректность
        if not isinstance(key, int):
            raise TypeError('Индекс должен быть целым числом')
        if key < 0 or key >= len(self.cart):
            raise IndexError('Неверный индекс')
        return key

    def __len__(self):
        return len(self.cart)

    def __getitem__(self, key):
        key = self.check_key(key)
        return self.cart[key]

    def __contains__(self, item):
        return item in self.cart

    def __iter__(self):
        yield from self.cart

    def __setitem__(self, key, value):
        key = self.check_key(key)
        self.cart[key] = value

    def __delitem__(self, key):
        key = self.check_key(key)
        del self.cart[key]


order = Order(['банан', 'яблоко', 'лимон'], 'Кемаль')

print(*order, sep=', ')

order[1] = 'ананас'
del order[2]

print(*order, sep=', ')
```

выводит:

```no-highlight
банан, яблоко, лимон
банан, ананас
```

Обратите внимание, что метод `__setitem__()` сперва принимает индекс (`key`), а после устанавливаемое значение (`value`).

Срезы последовательностей

Помимо доступа к элементам по индексам, последовательности поддерживают срезы, синтаксис которых нам уже хорошо знаком.

Приведенный ниже код:

```python
nums = [1, 2, 3, 4, 5]

print(nums[1:])
print(nums[:3])
print(nums[1:3])
print(nums[1:4:2])
```

выводит:

```no-highlight
[2, 3, 4, 5]
[1, 2, 3]
[2, 3]
[2, 4]
```

Перед тем как разобраться, как на самом деле работают срезы в Python, следует поговорить о встроенной функции [[Функция slice()]], которая возвращает специальный объект типа `slice`. Данный объект напоминает объект типа `range`, он также имеет начальное значение, конечное значение и шаг.

Приведенный ниже код:

```python
slice1 = slice(10)                              # start=None, stop=10, step=None  
slice2 = slice(1, 10)                           # start=1, stop=10, step=None
slice3 = slice(1, 10, 2)                        # start=1, stop=10, step=2

print(slice1)
print(slice2)
print(slice3)
```

выводит:

```no-highlight
slice(None, 10, None)
slice(1, 10, None)
slice(1, 10, 2)
```

Синтаксис создания объектов типа `slice` полностью совпадает с синтаксисом создания `range` объектов. Неуказанные значения при создании `slice` объекта принимают значение [[None (NoneType)]].

Срезы в Python реализуются с помощью `slice` объектов. Именно они автоматически создаются и указываются в качестве индексов, когда мы используем синтаксис срезов.

Приведенный ниже код:

```python
nums = [1, 2, 3, 4, 5]

print(nums[slice(1, None, None)])               # равнозначно nums[1:]
print(nums[slice(3)])                           # равнозначно nums[:3]
print(nums[slice(1, 3)])                        # равнозначно nums[1:3]
print(nums[slice(1, 4, 2)])                     # равнозначно nums[1:4:2]
```

выводит:

```no-highlight
[2, 3, 4, 5]
[1, 2, 3]
[2, 3]
[2, 4]
```

У каждого `slice` объекта имеются атрибуты `start, stop` и `step`, в которых содержатся начальное значение, конечное значение и шаг соответственно.

Приведенный ниже код:

```python
slice1 = slice(10)                              # start=None, stop=10, step=None  
slice2 = slice(1, 10)                           # start=1, stop=10, step=None
slice3 = slice(1, 10, 2)                        # start=1, stop=10, step=2

print(slice1.start, slice1.stop, slice1.step)
print(slice2.start, slice2.stop, slice2.step)
print(slice3.start, slice3.stop, slice3.step)
```

выводит:

```no-highlight
None 10 None
1 10 None
1 10 2
```

Таким образом, чтобы реализовать возможность использовать срезы, требуется лишь обработать ситуацию, когда в магические методы, работающие с индексами (`__getitem__(), __setitem__(), __delitem__()`), передается объект типа `slice`.

Приведенный ниже код:

```python
class Order:
    def __init__(self, cart, customer):
        self.cart = list(cart)
        self.customer = customer

    def __len__(self):
        return len(self.cart)

    def __getitem__(self, key):
        if isinstance(key, slice):
            return Order(self.cart[key], self.customer)
        if not isinstance(key, int):
            raise TypeError('Индекс должен быть целым числом')
        if key < 0 or key >= len(self.cart):
            raise IndexError('Неверный индекс')
        return self.cart[key]

    def __contains__(self, item):
        return item in self.cart

    def __iter__(self):
        yield from self.cart


order1 = Order(['банан', 'яблоко', 'лимон', 'дыня', 'грейпфрут'], 'Кемаль')
order2 = order1[1:]
order3 = order1[2:4]
order4 = order1[1:5:2]

print(*order2, sep=', ')
print(*order3, sep=', ')
print(*order4, sep=', ')
```

выводит:

```no-highlight
яблоко, лимон, дыня, грейпфрут
лимон, дыня
яблоко, дыня
```

Аналогичным образом можно реализовать методы `__setitem__()` и `__delitem__()`, чтобы пользоваться срезами и в них.

 Чтобы определить поведение при передаче в [[Функция reversed()]], используется [[Магический метод __reversed__()]].

Приведенный ниже код:

```python
class Order:
    def __init__(self, cart, customer):
        self.cart = list(cart)
        self.customer = customer

    def __len__(self):
        return len(self.cart)

    def __getitem__(self, key):
        if not isinstance(key, int):
            raise TypeError('Индекс должен быть целым числом')
        if key < 0 or key >= len(self.cart):
            raise IndexError('Неверный индекс')
        return self.cart[key]

    def __contains__(self, item):
        return item in self.cart

    def __iter__(self):
        yield from self.cart

    def __reversed__(self):
        return reversed(self.cart)


order = Order(['банан', 'яблоко', 'лимон'], 'Кемаль')

print(*order, sep=', ')
print(*reversed(order), sep=', ')
```

выводит:

```no-highlight
банан, яблоко, лимон
лимон, яблоко, банан
```

Неуказанные значения при создании `slice` объекта принимают значение `None`. Так происходит из-за того, что заранее неизвестно, к последовательности какой длины он будет применяться. Конечно, мы можем самостоятельно обрабатывать неуказанные значения, однако удобнее воспользоваться методом `indices()`. Данный метод принимает в качестве аргумента длину последовательности, к которой будет применяться срез, и возвращает кортеж из трех целых чисел, представляющих конечные значения `start, stop` и `step`.

Приведенный ниже код:

```python
slice1 = slice(10)                              # start=None, stop=10, step=None  
slice2 = slice(1, 10)                           # start=1, stop=10, step=None
slice3 = slice(1, 10, 2)                        # start=1, stop=10, step=2

print(slice1.indices(5))
print(slice2.indices(50))
print(slice3.indices(8))
```

выводит:

```no-highlight
(0, 5, 1)
(1, 10, 1)
(1, 8, 2)
```

Не забывайте, что если в классе определен магический метод `__len__()`, но не определен магический метод `__bool__()`, то именно `__len__()` будет использоваться для всех логических приведений.

Приведенный ниже код:

```python
class MyClass:
    def __len__(self):
        return 0


print(bool(MyClass()))
```

выводит:

```no-highlight
False
```

Реализовав в классе магические методы `__getitem__()` и `__len__()` мы можем передавать его экземпляры в функцию `choice()` модуля `random`. 

Приведенный ниже код:

```python
from random import choice

class Order:
    def __init__(self, cart, customer):
        self.cart = list(cart)
        self.customer = customer

    def __len__(self):
        return len(self.cart)

    def __getitem__(self, key):
        if not isinstance(key, int):
            raise TypeError('Индекс должен быть целым числом')
        if key < 0 or key >= len(self.cart):
            raise IndexError('Неверный индекс')
        return self.cart[key]

    def __iter__(self):
        print('Вызов метода __iter__()')
        yield from self.cart


order = Order(['банан', 'яблоко', 'лимон'], 'Кемаль')

print(choice(order))
print(choice(order))
```

выводит две случайные покупки, например:

```no-highlight
лимон
банан
```

1. При вызове итерации (например, в цикле `for` или при передаче в функцию, ожидающую итерируемый объект), интерпретатор проверяет, есть ли у объекта метод `__iter__`. Если метод `__iter__` определен, он будет использоваться для создания итератора. Если метод `__iter__` отсутствует, интерпретатор переходит ко второму шагу.
    
2. Интерпретатор вызывает метод `__len__` для получения длины последовательности объекта. Это позволяет интерпретатору знать, сколько элементов должно быть в итераторе.
    
3. Интерпретатор создает временный итератор, используя метод `__getitem__`. Он начинает с индекса 0 и последовательно вызывает метод `__getitem__` с инкрементированным индексом, пока индекс не станет больше или равен длине объекта, полученной из метода `__len__`. Полученные элементы передаются в итерационный контекст, где их можно использовать в цикле или внутри функции.
    
4. Если при итерации метод `__getitem__` возвращает элементы до последнего элемента объекта, интерпретатор прекращает дальнейшую итерацию и выходит из цикла или функции.