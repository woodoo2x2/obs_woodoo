

В языке Python под **итерируемым объектом** подразумевают объект, который можно итерировать, то есть проходиться по нему, перебирая каждый элемент раз за разом. К примеру, уже известные нам списки ([[Тип данных list]]), строки ([[Тип данных str]]), кортежи ([[Тип данных tuple]]), множества ([[Тип данных set]]) и словари ([[Тип данных dict]]) являются итерируемыми, поскольку мы можем перебирать каждый элемент этих объектов.

Если подходить более формально, в Python существуют два типа итерируемых объектов:

1. [[Итератор]]
2. [[Коллекции и последовательности]]

**Итератор** — специальный объект, который выдает свои элементы по одному за раз.

Если итератор передать во встроенную функцию [[Функция next()]], то эта функция вернет его следующий элемент. При этом сам итератор так же сдвинется на следующий элемент. При следующем вызове функция `next()` вернет следующий элемент и т.д. Если же в итераторе элементов больше не осталось, то вызов функции `next()` приведет к возбуждению исключения `StopIteration`.

**Коллекция** — объект, хранящий набор значений одного или различных типов, позволяющий обращаться к этим значениям, а также применять специальные функции и методы, зависящие от типа коллекции.

Также среди коллекций можно выделить те, элементы которых пронумерованы индексами и расположены в строгом порядке. Такие коллекции называются **последовательностями**. Например, списки, строки и кортежи являются последовательностями, а множества и словари нет.

Коллекции не являются итераторами сами по себе, но позволяют создать итератор на своей основе.

Для того чтобы создать итератор на основе некоторой коллекции, достаточно вызвать встроенную функцию [[Функция iter()]], передав ей нужную коллекцию в качестве аргумента.

Например, список не является итератором, но на его основе можно создать сколько угодно итераторов, каждый из которых будет перебирать элементы списка от первого до последнего.




**У всех итерируемых объектов** есть [[Магический метод __iter__()]], который преобразует итерируемый объект в итератор. Встроенная функция `iter()` вызывает за кулисами именно этот магический метод.

Приведенный ниже код:

```python
words = ['hello', 'beegeek', 'python']

iterator = iter(words)                    # равнозначно words.__iter__()

print(type(words))
print(type(iterator))
```

выводит:

```no-highlight
<class 'list'>
<class 'list_iterator'>
```

**У всех итераторов** есть магический метод [[Магический метод  __next__()]], который обеспечивает выдачу очередного элемента. Встроенная функция `next()` вызывает за кулисами именно этот магический метод. 

Приведенный ниже код:

```python
words = ['hello', 'beegeek', 'python']

iterator = iter(words)                    # равнозначно words.__iter__()

print(next(iterator))                     # равнозначно iterator.__next__()
print(next(iterator))                     # равнозначно iterator.__next__()
```

выводит:

```
hello
beegeek
```

  Когда элементы в итераторе закончились, очередной вызов функции `next()` возбуждает исключение `StopIteration`.

Если объект итератором не является, то есть у него нет магического метода `__next__()`, то вызов функции `next()` приведет к ошибке.

Приведенный ниже код:

```python
words = ['hello', 'beegeek', 'python']

print(next(words))
```

приводит к возбуждению исключения:

```
TypeError: 'list' object is not an iterator
```

**У всех итераторов** есть и метод `__iter__()`, который возвращает сам итератор (сам себя). Таким образом, любой итератор является итерируемым объектом, но не наоборот, не любой итерируемый объект является итератором.

Приведенный ниже код:

```python
words = ['hello', 'beegeek', 'python']

iterator1 = iter(words)                   # равнозначно words.__iter__()
iterator2 = iter(iterator1)               # равнозначно iterator1.__iter__()

print(iterator1 is iterator2)
```

выводит:

```no-highlight
True
```

Таким образом, если функции `iter()` передается итератор, то она возвращает его же. Если же функции `iter()` передать итерируемый объект, не являющийся итератором (например, список), то она вернет совсем другой объект – итератор на основе этого итерируемого объекта.

Возникает вопрос, для чего итераторы содержат магический метод `__iter__()`. Все дело в том, что цикл `for` ожидает, что у объекта, по которому идет итерирование, есть не только магический метод `__next__()`, но и `__iter__()`. Задача метода `__iter__()` – превращать итерируемый объект в итератор. Если в цикл `for` передается уже итератор, то метод `__iter__()` этого объекта должен возвращать сам объект.

Если циклу `for` передается не итератор, а итерируемый объект, то его метод `__iter__()` должен возвращать не сам объект, а итератор на основе этого итерируемого объекта.

Получается, в итераторах метод `__iter__()` нужен лишь для совместимости. Ведь если `for` работает как с итераторами, так и с итерируемыми объектами, но последние требуют преобразования к итератору, и `for` вызывает `__iter__()` без оценки того, что ему передали, то требуется, чтобы оба – итератор (`iterator`) и итерируемый объект (`iterable`) – поддерживали этот метод. С точки зрения наличия в классе метода `__iter__()` итераторы можно считать подвидом итерируемых объектов.


 Итерируемый объект (`iterable`) и итератор (`iterator`) – это протоколы, правила.

 Особенности итерируемых объектов и итераторов:

1. любой объект, не вызывающий исключение `TypeError` при передаче в функцию `iter()`, — итерируемый объект
2. любой объект, не вызывающий исключение `TypeError` при передаче в функцию `next()`, — итератор
3. любой объект, возвращающий сам себя при передаче в функцию `iter()`, — итератор

 После реализации в классе метода `__iter__()`, экземпляры данного класса можно преобразовывать в коллекции с помощью встроенных функций `list(), set(), tuple()` и `str()`.

 Встроенная функция `iter()` преобразует итерируемый объект в итератор. Именно в таком виде функция используется в большинстве случаев.

```python
iter(iterable) -> iterator
```

Однако мы можем использовать функцию `iter()` в еще одном полезном сценарии:

```python
iter(callable, sentinel) -> iterator
```

Если функции `iter()` передается два аргумента, то первый аргумент `callable` должен являться функцией, а второй аргумент `sentinel` — некоторым стоп-значением. В этом случае, созданный итератор будет вызывать указанную функцию `callable` и проверять полученное значение на равенство со значением `sentinel`. Если полученное значение равно `sentinel`, то возбуждается исключение `StopIteration`, иначе итератор выдает значение, полученное из функции `callable`.

Например, с помощью функции `iter()` мы можем создать бесконечный итератор, генерирующий единственное значение — `0`.

Приведенный ниже код:

```python
zero_iterator = iter(int, -1)

for i in range(5):
    print(next(zero_iterator))

print(type(zero_iterator))
```

выводит:

```no-highlight
0
0
0
0
0
<class 'callable_iterator'>
```

Функция `int()`, которую мы передаем в качестве первого аргумента в функцию `iter()`, всегда возвращает значение `0`, при этом вторым аргументом (стоп-значением) является `-1`, которое не будет возвращено никогда. Таким образом, мы построили бесконечный итератор, генерирующий единственное нулевое значение.

