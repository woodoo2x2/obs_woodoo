

Методы класса, как следует из названия, тесно связаны с классом, в котором они определены. В отличие от методов экземпляра, имеющих обязательный  [[Параметр self]], указывающий на экземпляр класса, методы класса имеют обязательный [[Параметр cls]], который указывает на сам класс. Такие методы имеют возможность менять состояние класса, что в свою очередь отражается на всех экземплярах данного класса. Однако менять состояние конкретного объекта, как это делают методы экземпляра, они не могут, так как имеют доступ лишь к классу.

Присутствие параметра `cls` в методе класса обязательное. Мы не обязаны называть его `cls`, однако строго рекомендуется действовать согласно общепринятой практике.

Для создания методов класса используется [[Декоратор @classmethod]].

Приведенный ниже код:

```python
class MyClass:
    @classmethod
    def my_classmethod(cls):
        print('Это метод класса')
        print(cls)


MyClass.my_classmethod()
```

создает в классе `MyClass` метод класса `my_classmethod()` и выводит:

```no-highlight
Это метод класса
<class '__main__.MyClass'>
```

Как мы видим, метод класса `my_classmethod()` действительно имеет доступ лишь к классу `MyClass`.

Зачастую методы класса используются для добавления альтернативного способа создания экземпляров класса. Рассмотрим следующее определение класса `Cat`:

```python
class Cat:
    def __init__(self, breed, name):
        self.breed = breed                                   # порода кошки
        self.name = name                                     # имя кошки
```

Экземпляры данного класса имеют два атрибута — породу и имя. Скажем, мы заметили, что очень часто имеем дело с кошками британской породы и решили, что было бы удобно создавать объекты класса `Cat`, указывая лишь имя, а в качестве породы по умолчанию устанавливая `Британский`. Для этого мы можем реализовать метод класса, который принимает лишь имя кошки и возвращает объект класса `Cat` британской породы с указанным именем.

Приведенный ниже код:

```python
class Cat:
    def __init__(self, breed, name):
        self.breed = breed
        self.name = name

    @classmethod
    def british(cls, name):
        return cls('Британский', name)                       # равнозначно Cat('Британский', name)


cat = Cat.british('Кемаль')

print(cat.breed, cat.name)
```

 выводит:

```no-highlight
Британский Кемаль
```

На самом деле мы уже не раз сталкивались с методами класса, например, когда изучали такие типы данных как [[Тип данных dict]] и [[Модуль datetime]].

Приведенный ниже код:

```python
from datetime import datetime

cats = dict.fromkeys(['Кемаль', 'Роджер'])                   # словарь со значениями по умолчанию
dt = datetime.strptime('12.10.2022', '%d.%m.%Y')             # дата на основе строки

print(cats)
print(dt)
```

выводит:

```no-highlight
{'Кемаль': None, 'Роджер': None}
2022-10-12 00:00:00
```

Методы класса и [[Статические методы|статические методы]] можно вызывать не только через класс, но и через экземпляр класса.

Приведенный ниже код:

```python
class MyClass:
    @classmethod
    def my_classmethod(cls):
        print('Это метод класса')
        print(cls)

    @staticmethod
    def my_staticmethod():
        print('Это статический метод')


obj = MyClass()

obj.my_classmethod()
obj.my_staticmethod()
```

выводит:

```no-highlight
Это метод класса
<class '__main__.MyClass'>
Это статический метод
```