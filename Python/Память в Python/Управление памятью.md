## Управление памятью

Управление памятью — это процесс выделения, распределения и координации памяти таким образом, чтобы все программы работали правильно и могли оптимально получать доступ к различным системным ресурсам. Управление памятью также включает в себя и очистку памяти от объектов, которые больше не нужны.

Существует два типа управления памятью:

- ручное управление памятью
- автоматическое управление памятью

Ручное управление памятью включает в себя, как правило, три этапа:

1. запрос памяти у операционной системы
2. работа с ней
3. возвращение памяти обратно в операционную систему

Ручной подход управления позволяет работать с памятью максимально эффективно. Мы точно знаем, сколько памяти нам выделено, зачем мы ее используем, и т.д. Однако помимо преимуществ такой подход имеет и ряд недостатков. Ключевой из них — сложность. Управлять памятью вручную — сложно и тяжело, поскольку легко забыть вернуть память обратно операционной системе, в результате чего возникает утечка: программа держит неиспользуемую память просто так, не давая применять ее для решения других задач.

Автоматическое управление памятью берет на себя самый сложный этап — возвращение памяти обратно операционной системе, когда она уже не требуется. Восстановленная память может использоваться другими объектами. Это пусть и немного менее эффективно, но позволяет сильно сократить трудозатраты на управление памятью и повысить надежность этого процесса.

К языкам с ручным управлением памяти относятся: C, C++, Pascal и многие другие. 

К языкам с автоматическим управлением памяти относятся: Python, C#, Java, Ruby, JavaScript и многие другие.

## Механизм памяти в Python

Python — это язык с автоматическим управлением памятью. Причем для управления ею он использует несколько механизмов. При запуске Python программы создается новый [процесс](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81_(%D0%B8%D0%BD%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B0)), в рамках которого операционная система выделяет пул ресурсов, включая [виртуальное адресное пространство](https://ru.wikipedia.org/wiki/%D0%92%D0%B8%D1%80%D1%82%D1%83%D0%B0%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F_%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D1%8C). В эту память загружается интерпретатор Python вместе со всеми необходимыми ему для работы данными, включая код нашей программы.

Оставшаяся свободная виртуальная память используется для хранения Python объектов. Для управления этой памятью в Python используется специальный механизм, который называется **аллокатор**. Он используется каждый раз, когда нам нужно создать новый объект.

Обычно мы в своих программах не оперируем большими объектами. Большая часть наших данных — это числа, строки и т.д., они занимают не такой уж большой объем в расчёте на одно значение. Но зато мы создаем их достаточно часто. И это приводило бы к проблемам, если бы Python абсолютно все такие вызовы транслировал в операционную систему. Системный вызов на выделение памяти — штука трудозатратная, зачастую связанная с переходом в контекст ядра операционной системы. Поэтому одна из главных задач аллокатора Python — оптимизация количества системных вызовов.

![](https://ucarecdn.com/6f4a4378-4b95-40e0-ab4d-012371d07590/)Для больших объектов (больше 512512 байт) Python выделяет память напрямую у ОС. Обычно таких объектов не очень много в рамках программы, и создаются они нечасто. Поэтому накладные расходы на создание таких объектов напрямую в оперативную память не так высоки.

Аллокатор для малых объектов (не больше 512512 байт) использует три уровня абстракции:

- **блок** — кусок памяти, используемый для хранения одного объекта
- **пул** — кусок памяти, содержащий блоки (обычно одна [страница](https://ru.wikipedia.org/wiki/%D0%A1%D1%82%D1%80%D0%B0%D0%BD%D0%B8%D1%87%D0%BD%D0%B0%D1%8F_%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D1%8C) виртуальной памяти размером 44 килобайта)
- **арена** — большой непрерывный кусок памяти, содержащий пулы (обычно содержит несколько страниц виртуальной памяти и имеет размер 256256 килобайт)

![](https://ucarecdn.com/30069dde-5042-4c7e-8306-73529389ca4a/)

### Блок

Блок — это кусок памяти, который может содержать только один Python объект фиксированного размера. Размер блока может варьироваться от 88 до 512512 байт и должен быть кратен восьми. Все блоки в конкретном пуле имеют одинаковый размер и находятся в одном классе размера, который и определяет размер блока. Градация в приведенной ниже таблице взята прямо из [комментариев](https://github.com/python/cpython/blob/7d6ddb96b34b94c1cbdf95baa94492c48426404e/Objects/obmalloc.c#L603) в исходном коде:

|Запрос памяти в байтах|Размер блока в байтах|Индекс класса размера|
|---|---|---|
|1-8|8|0|
|9-16|16|1|
|17-24|24|2|
|25-32|32|3|
|33-40|40|4|
|41-48|48|5|
|...|...|...|
|505-512|512|63|

Таким образом, если необходимы:

- 66 байт, то данные будут помещены в блок размером 88 байт
- 4242 байта, то данные будут помещены в блок размером 4848 байт
- 505505 байтов, то данные будут помещены в блок размером 512512 байт
- и т.д.

### Пул

Пулы состоят из блоков одного размера. Каждый пул работает по принципу двухсвязного списка с другими пулами того же размера. Поэтому алгоритм может с легкостью найти необходимое место для требуемого размера блока даже среди множества пулов. Размер пула равен 44 килобайта.

![](https://ucarecdn.com/c5168aae-6b72-4faa-b373-9f2bf9712d5c/)Ограничение пула фиксированным размером блоков помогает с [фрагментацией](https://ru.wikipedia.org/wiki/%D0%94%D0%B8%D0%BD%D0%B0%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5_%D1%80%D0%B0%D1%81%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5_%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D0%B8#:~:text=%D0%94%D1%80%D1%83%D0%B3%D0%B0%D1%8F%20%D0%BF%D1%80%D0%BE%D0%B1%D0%BB%D0%B5%D0%BC%D0%B0%20%E2%80%94%20%D1%8D%D1%82%D0%BE%20%D0%BF%D1%80%D0%BE%D0%B1%D0%BB%D0%B5%D0%BC%D0%B0%20%D1%84%D1%80%D0%B0%D0%B3%D0%BC%D0%B5%D0%BD%D1%82%D0%B0%D1%86%D0%B8%D0%B8%20%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D0%B8). Если объект уничтожается, аллокатор может заполнить это пространство новым объектом того же размера.

Для эффективного управления пулами Python использует дополнительный список, который называется `usedpools`. Он хранит указатели на пулы, сгруппированные по классам. Как мы уже знаем, все пулы с одинаковым размером блока связаны между собой с помощью двухсвязного списка. Чтобы перебрать их, нам просто нужно знать начало списка. Если пулов такого размера нет, то при первом запросе памяти будет создан новый пул.

![](https://ucarecdn.com/c52b81ba-217c-4b0a-9126-b7c86ac45c55/)

Пулы находятся в трех состояниях:

- используемый (used) — частично заполненный, какие-то блоки заняты, какие-то свободны
- полный (full) — полностью заполненный, все блоки заняты 
- пустой (empty) — все блоки свободны и доступны для записи (хранятся в списке пустых пулов `freepools`)

![](https://ucarecdn.com/53b61d46-913d-4298-b2ee-0d805de8c553/)

Используемый пул содержит блоки, в которые можно записать какую-то информацию. Блоки полного пула все распределены и уже содержат данные. Пустые пулы не содержат данных и могут быть разбиты на какие угодны классы размера при необходимости.

Допустим, нашему коду необходимо 88 байт. Если в списке используемых пулов нет пулов с классом размера в 88 байт, то новый пустой пул инициализируется, как хранящий блоки по 88 байт. Затем пустой пул добавляется в список используемых пулов и может быть использован при следующих запросах.

Заполненный пул освобождает некоторые блоки, когда эта информация в них уже не нужна. Этот пул добавится в список используемых в соответствии со своим классом размера.

![](https://ucarecdn.com/d0eca2a2-b4f0-411e-a477-167736348472/)Обратите внимание, что пулы и блоки не выделяют память напрямую, вместо этого они используют уже выделенное пространство в аренах.

### Арена

Арена – это кусок памяти размером в 256256 килобайт, который обеспечивает память для 6464 пулов.

![](https://ucarecdn.com/06c0d7ea-d2ae-4d36-973c-318071159cef/)

Арены, в отличие от пулов, не имеют явных разделений на состояния. Они сами по себе организованы в двухсвязный список `usable_arenas`. Этот список отсортирован по количеству свободных пулов. Чем меньше свободных пулов, тем ближе арена к началу списка.

![](https://ucarecdn.com/5c8fe219-8046-4cef-b714-4770ada6b360/)

Это означает, что наиболее полная арена будет выбрана для записи еще большего количества данных. Такое расположение арен позволяет снизить объем потребляемой программой памяти. Дело в том, что в некоторых случаях, когда память освобождается, она все еще остается недоступной операционной системе. Процесс Python держит ее распределенной и использует ее позже для новых данных. Полное освобождение памяти возвращает память в пользование операционной системе.  
  
Арены — единственные области, которые могут быть полностью освобождены. Таким образом мы понимаем, что те арены, которые находятся в списке ближе к пустому состоянию, должны быть освобождены. В таком случае, область памяти может быть действительно полностью освобождена, и соответственно общий объем памяти Python программы будет уменьшен.

## Примечания

**Примечание 1.** Все сказанное в уроке относится к эталонной реализации Python, которая называется CPython. В других реализациях аллокатор может иметь отличия.

**Примечание 2.** Исходный код аллокатора доступен по [ссылке](https://github.com/python/cpython/blob/7d6ddb96b34b94c1cbdf95baa94492c48426404e/Objects/obmalloc.c).

**Примечание 3.** Языки с ручным управлением памятью работают гораздо быстрее языков с автоматическим управлением памятью. Это цена, которую приходится платить за простоту написания программ.

**Примечание 4.** Урок использует материалы статьи с [хабра](https://habr.com/ru/company/domclick/blog/530804/).

**Примечание 5.** Хорошая статья на английском языке о механизме управления памятью в Python доступна по [ссылке](https://rushter.com/blog/python-memory-managment/).

**Примечание 6.** Для лучшего понимания механизма работы памяти рекомендуем посмотреть видео.

![](https://youtu.be/D0vbuIDOV4c)