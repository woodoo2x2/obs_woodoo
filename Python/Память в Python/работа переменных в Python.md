## Переменные в C и C++

Возьмём код, который определяет переменную `num`:

```cpp
int num = 101;
```

Исполнение этой строки кода проходит через несколько этапов:

1. выделение достаточного количества памяти для числа
2. присвоение этому месту в памяти значения 101101
3. отображение, что `num` указывает на это значение

Упрощённо память может выглядеть так:

![](https://ucarecdn.com/07dbf636-51af-4454-a404-c10678dfa38b/)

Здесь переменная `num` имеет виртуальный адрес `0x7f1` и значение 101101. Если позднее нам захочется изменить значение `num`, это можно сделать так:

```cpp
num = 102;
```

Этот код присваивает переменной `num` новое значение `102`, тем самым перезаписывая предыдущее значение. Это означает, что переменная `num` изменяема. Обновлённая схема памяти для нового значения:

![](https://ucarecdn.com/bc01938c-5818-47ed-b112-7b95c7adaea8/)

Обратите внимание, что расположение `num` в памяти не поменялось, только само значение. Это говорит о том, что `num` — это место в памяти, а не просто имя. Можно сказать, что переменная `num` владеет местом в памяти. По сути, `num` — это пустая коробка, которая может содержать лишь одно целое число (тип `int`).

Когда мы присваиваем `num` какое-то значение, мы тем самым помещаем значение в коробку, принадлежащую `num`. При этом создать новую переменную `num1` можно следующим образом:

```cpp
int num1 = num;
```

Этот код создаёт новую коробку под названием `num1` и копирует в неё значение из `num`. Теперь схема памяти выглядит так:

![](https://ucarecdn.com/89745fa1-3021-4a6f-a6a9-ba11c1f18c7a/)

Обратите внимание на местоположение `num1` — `0x7f5`. Хотя в `num1` и было скопировано значение `num`, однако переменная `num1` владеет новым адресом в памяти. Следовательно, мы можем перезаписывать значение `num1`, не влияя на `num`:

```cpp
num1 = 103;
```

Теперь схема памяти выглядит так:

![](https://ucarecdn.com/20fb3aaa-f71d-42cf-afbb-c042974d2633/)

Таким образом мы изменили значение переменной `num1`, но не ее местоположение. Кроме того, мы никак не повлияли на исходную переменную `num`.

С переменными в Python совершенно иная ситуация.

## Переменные в Python

В Python нет переменных, как таковых, вместо них имена. Мы можем использовать термин переменные, однако важно понимать разницу между переменными и именами.

Давайте возьмём эквивалентный код из вышеприведённого примера на С (С++) и напишем его на Python:

```python
num = 101
```

Как и в C (С++), исполнение этой строки кода проходит через несколько этапов:

1. создаётся специальный объект `PyObject`
2. заполняется его поле `Type`, которое указывает на тип
3. заполняется его поле `Value`, которое указывает на значение
4. создаётся имя `num`
5. имя `num` начинает указывать на созданный `PyObject`
6. счётчик ссылок (поле `Reference Count`) объекта `PyObject` увеличивается на 11

![](https://ucarecdn.com/937edd6e-95e4-4bfd-aa0c-b79f1d18aa6f/)   Подробнее о счётчике ссылок (поле `Reference Count`) будет рассказано в уроке по сборщику мусора.

Если говорить о памяти, то это может выглядеть таким образом:

![](https://ucarecdn.com/b01146b7-1cf7-4cd4-870a-25d803dadc57/)

Как мы видим, схема памяти в Python отличается от схемы в С (С++), показанной выше. Вместо того чтобы `num` владел блоком памяти, в котором хранится значение `101`, этой памятью владеет `PyObject` объект.

Таким образом, в Python имя `num` не владеет напрямую каким-либо адресом в памяти.

Для присвоения нового значения имени `num` мы используем следующий код:

```python
num = 101
num = 102
```

Исполнение этой строки кода проходит через несколько этапов:

- создаётся новый `PyObject`
- заполняется его поле `Type`, которое указывает на тип
- заполняется его поле `Value`, которое указывает на значение
- имя `num` указывает на новый `PyObject`
- счётчик ссылок (поле `Reference Count`) нового `PyObject` увеличивается на 11
- счётчик ссылок (поле `Reference Count`) старого `PyObject` уменьшается на 11

Теперь схема памяти выглядит так:

![](https://ucarecdn.com/c04dcb3a-83ce-41f3-bd70-2a72f6aeeaa8/)

Картинка выше демонстрирует, что `num` указывает на объект и не владеет областью памяти напрямую. Также мы видим, что строка кода `num = 101` является не присваиванием, а, скорее, привязкой (binding) имени `num` к объекту.

Кроме того, предыдущий объект (содержавший значение `101`) теперь находится в памяти со счётчиком ссылок, равным 00, и подлежит удалению с помощью сборщика мусора, о котором будет рассказано позже.

Мы можем ввести новое имя `num1`:

```python
num = 101
num = 102
num1 = num
```

В памяти появится новое имя `num1`, но не новый объект:

![](https://ucarecdn.com/4acbdee6-7850-409d-9fb7-0d0ad5ecd38e/)

Мы видим, что новый Python объект не создан, создано только новое имя, которое указывает на тот же объект. Кроме того, счётчик ссылок объекта увеличился на 11.

![](https://ucarecdn.com/e13bcb55-13be-47b0-8762-480147db7c0e/)   В Python мы не присваиваем переменные, а привязываем имена к объектам.

## Примечания

**Примечание 1.** Выступление спикера Ned Batchelder на PyCon 2015 о работе переменных доступно по [ссылке](https://www.youtube.com/watch?v=_AEJHKGk9ns). Текстовая версия доклада на [русском](https://techrocks.ru/2021/06/07/names-and-values-in-python/) и [английском](https://nedbatchelder.com/text/names.html) языках.

**Примечание 2.** Хорошая статья о работе переменных в Python на [русском](https://habr.com/ru/company/otus/blog/666858/) и [английском](https://www.pythonmorsels.com/pointers/) языках.

**Примечание 3.** [PyObject](https://github.com/python/cpython/blob/v3.7.3/Include/object.h#L101) определяется как C структура, которая характерна для CPython (стандартной реализации), и представляет базовую структуру всех объектов Python.

**Примечание 4.** Подробнее о модели данных в Python можно прочитать в официальной документации по [ссылке](https://docs.python.org/3/reference/datamodel.html).