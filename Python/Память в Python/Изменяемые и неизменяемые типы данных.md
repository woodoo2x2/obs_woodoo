## Изменяемые и неизменяемые типы данных

Типы данных в Python делятся на две категории:

- изменяемые (`list, set, dict, ...`)
- неизменяемые (`int, float, bool, tuple, str, ...`)

Приведенный ниже код:

```python
data = 'beegeek'
data[0] = 'B'

print(data)
```

приводит к возникновению ошибки:

```no-highlight
TypeError: 'str' object does not support item assignment
```

поскольку строки (тип `str`) являются неизменяемыми.

![](https://ucarecdn.com/1007da0f-af2b-4d86-9af6-5475a59e3721/)Не забывайте, что все строковые методы возвращают новые объекты, а не изменяют исходные. Аналогичным образом работают методы других неизменяемых типов данных.

Приведенный ниже код:

```python
data = ['b', 'e', 'e', 'g', 'e', 'e', 'k']
data[0] = 'B'

print(data)
```

выводит:

```no-highlight
['B', 'e', 'e', 'g', 'e', 'e', 'k']
```

поскольку списки (тип `list`) являются изменяемыми.

## Изменение объектов VS оператор присваивания

В Python существует два типа изменения:

- присвоение переменной нового значения
- непосредственное изменение объекта

Приведенный ниже код:

```python
nums = [1, 2, 3]

print(nums)
print(id(nums))

nums = [1, 2, 3] + [4]

print(nums)
print(id(nums))
```

всегда выводит различные идентификаторы (числа могут отличаться от запуска к запуску программы):

```no-highlight
[1, 2, 3]
2130653012352
[1, 2, 3, 4]
2130653007680
```

так как мы не изменяем исходный список, а создаем новый и присваиваем его прежней переменной.

Приведенный ниже код:

```python
nums = [1, 2, 3]

print(id(nums))
print(nums)

nums.append(4)

print(id(nums))
print(nums)
```

всегда выводит равные идентификаторы (числа могут отличаться от запуска к запуску программы):

```no-highlight
2675065348480
[1, 2, 3]
2675065348480
[1, 2, 3, 4]
```

так как мы единожды создаем список, а после изменяем его, добавляя в него новый элемент.

Таким образом, в первом случае мы изменяем переменную, то есть изменяем то, на какой объект она ссылается. Во втором случае мы изменяем сам объект, на который может ссылаться любое количество переменных.

Важно понимать, что во время изменения объекта, мы изменяем именно объект, а не переменные. Другими словами, если какая-либо другая переменная указывает на объект, который мы изменили, эта переменная также отразит это изменение, но не потому что изменилась переменная, а потому что изменился объект, на который она ссылается.

Приведенный ниже код:

```python
nums1 = [1, 2, 3]
nums2 = nums1

nums1.append(4)

print(nums1)
print(nums2)
```

выводит

```no-highlight
[1, 2, 3, 4]
[1, 2, 3, 4]
```

![](https://ucarecdn.com/d0fd2994-7af0-402c-85ea-08073d06236b/)Оператор присваивания в Python не создает копию объекта, он лишь связывает имя переменной с объектом. Для неизменяемых объектов это обычно не имеет значения, но для работы с изменяемыми объектами часто требуется создавать реальные копии.

## Примечания

**Примечание 1.** Кортежи (тип `tuple`) являются неизменяемыми, однако если элементами кортежа являются изменяемые объекты, то мы можем изменить эти объекты.

Приведенный ниже код:

```python
data = (1, 'bee', [1, 2, 3], {'a': 1})

print(data)

data[2][2] = 30
data[3]['b'] = 2

print(data)
```

выводит:

```no-highlight
(1, 'bee', [1, 2, 3], {'a': 1})
(1, 'bee', [1, 2, 30], {'a': 1, 'b': 2})
```

При этом важно понимать: меняются объекты, являющиеся элементами кортежа, а не кортеж. Кортеж лишь содержит ссылки на эти объекты, которые остаются прежними при изменении самих объектов.

**Примечание 2.** Python по-разному обрабатывает сложение списков с помощью операторов `+` и `+=`.

Приведенный ниже код:

```python
nums1 = [1, 2, 3]
nums2 = nums1

nums1 = nums1 + [4, 5]

print(nums1)
print(nums2)
```

выводит:

```no-highlight
[1, 2, 3, 4, 5]
[1, 2, 3]
```

В данном случае оператор `+` создал новый список `[1, 2, 3, 4, 5]`, который был присвоен переменной `nums1`, при этом `nums2` по-прежнему указывает на старый список `[1, 2, 3]`.

Приведенный ниже код: 

```python
nums1 = [1, 2, 3]
nums2 = nums1

nums1 += [4, 5]

print(nums1)
print(nums2)
```

выводит:

```no-highlight
[1, 2, 3, 4, 5]
[1, 2, 3, 4, 5]
```

В данном случае оператор `+=` изменил текущий список, и эти изменения также видны в `nums2`. По сути, оператор `+=` для списков работает как списочный метод `extend()`.

**Примечание 3.** Считается плохой практикой использование изменяемых типов данных в качестве значений параметров по умолчанию, так как значение по умолчанию для параметра создается единожды при определении функции (обычно при загрузке модуля) и становится атрибутом (свойством) функции. Поэтому если значением по умолчанию является изменяемый объект, то его изменение повлияет на каждый следующий вызов функции.

Приведенный ниже код:

```python
def append(element, seq=[]):
    seq.append(element)
    return seq

print(append(10))
print(append(5))
print(append(1))
print(append(3))
```

выводит:

```no-highlight
[10]
[10, 5]
[10, 5, 1]
[10, 5, 1, 3]
```

Для решения проблемы можно использовать константу `None` в качестве значения параметра по умолчанию, а в теле функции устанавливать нужное значение:

Приведенный ниже код:

```python
def append(element, seq=None):
    if seq is None:
        seq = []
    seq.append(element)
    return seq

print(append(10))
print(append(5))
print(append(1))
```

выводит:

```
[10]
[5]
[1]
```