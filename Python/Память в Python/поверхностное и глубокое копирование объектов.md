

1. Создание копий объектов
2. [[Module copy]]
3. Поверхностное копирование
4. Глубокое копирование

**Аннотация.** Урок посвящен созданию копий объектов и работе с модулем `copy`.

## Создание копий объектов

Как мы уже знаем, оператор присваивания в Python не создает копию объекта, он лишь связывает имя переменной с объектом. Для неизменяемых объектов это обычно не имеет значения, но для работы с изменяемыми объектами часто требуется создавать реальные копии.

Приведенный ниже код:

```python
data1 = [1, 2, 3]
data2 = data1
data1.append(4)

print(id(data1), data1)
print(id(data2), data2)
```

всегда выводит равные идентификаторы (числа могут отличаться от запуска к запуску программы):

```no-highlight
2371294168448 [1, 2, 3, 4]
2371294168448 [1, 2, 3, 4]
```

Поскольку списки (тип `list`) являются изменяемыми, то изменения в `data1`, также видны в `data2`.

Для создания реальных копий объектов в Python используют модуль `copy`.



### Поверхностное копирование

**Поверхностное копирование** создает отдельный новый объект, но вместо копирования дочерних элементов в новый объект, оно просто копирует ссылки на их адреса памяти.

Приведенный ниже код:

```python
import copy

data1 = [1, 2, 3]
data2 = copy.copy(data1)
data1.append(4)

print(id(data1), data1)
print(id(data2), data2)
```

всегда выводит разные идентификаторы (числа могут отличаться от запуска к запуску программы):

```no-highlight
2072210867584 [1, 2, 3, 4]
2072250543808 [1, 2, 3]
```

так как переменная `data2` ссылается на новый объект, который представляют копию списка `[1, 2, 3]`. В данном примере элементами списка являются целые числа (неизменяемый тип `int`), поэтому изменение одного списка не отражается на другом. Если бы элементами списка были бы изменяемые типы, то поверхностное копирование скопировало бы лишь ссылки на их адреса памяти. Следовательно, любое изменение элементов одного объекта отразилось бы также и на элементах другого объекта.

Приведенный ниже код:

```python
import copy

data1 = [[1, 2, 3], [4, 5, 6]]
data2 = copy.copy(data1)

data1.append([7, 8, 9])

print(id(data1), data1)
print(id(data2), data2)
```

выводит (числа могут отличаться от запуска к запуску программы):

```no-highlight
2320743120512 [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
2320753594368 [[1, 2, 3], [4, 5, 6]]
```

В то время как приведенный ниже код:

```python
import copy

data1 = [[1, 2, 3], [4, 5, 6]]
data2 = copy.copy(data1)

data1[0].append(7)
data2[1].append(8)

print(id(data1), data1)
print(id(data2), data2)
```

выводит (числа могут отличаться от запуска к запуску программы):

```no-highlight
2088862020160 [[1, 2, 3, 7], [4, 5, 6, 8]]
2088872808384 [[1, 2, 3, 7], [4, 5, 6, 8]]
```

Изменения затронули оба списка, потому что оба они содержат ссылки на один и тот же вложенный объект. Так работает поверхностное копирование.

![](https://ucarecdn.com/123c2640-4c6d-4f36-a0e6-07b9a83b8dc7/)Поверхностное копирование создает отдельный новый объект, но вместо того чтобы копировать дочерние элементы в новый объект, оно просто копирует ссылки на их адреса памяти.

### Глубокое копирование

**Глубокое копирование** создает новую и отдельную копию всего объекта со своим уникальным адресом памяти. Это означает, что любые изменения, внесенные вами в новую копию объекта, не будут отражаться в исходной, и наоборот.

Приведенный ниже код:

```python
import copy

data1 = [[1, 2, 3], [4, 5, 6]]
data2 = copy.deepcopy(data1)

data1[0].append(7)
data2[1].append(8)

print(id(data1), data1)
print(id(data2), data2)
```

выводит (числа могут отличаться от запуска к запуску программы):

```no-highlight
2001097388608 [[1, 2, 3, 7], [4, 5, 6]]
2001108045760 [[1, 2, 3], [4, 5, 6, 8]]
```

![](https://ucarecdn.com/0e4c08d0-2b75-4ca0-8ae8-009703a16571/)При глубоком копировании временные затраты на создание копии, очевидно выше чем при создании поверхностной копии. Если копируемый объект имеет сложную вложенную структуру, то глубокое копирование может тратить много времени.

## Примечания

**Примечание 1.** У списков, множеств и словарей есть метод `copy()`, создающий их **поверхностную копию**.

Приведенный ниже код:

```python
data1 = [1, 2, 3, 4]
data2 = [[1, 2], [3, 4]]

new_data1 = data1.copy()
new_data2 = data2.copy()

print(data1 is new_data1, data1 == new_data1)
print(data2 is new_data2, data2 == new_data2)

new_data1[0] = 100
new_data2[0][0] = 100

print(data1)
print(data2)
```

выводит:

```no-highlight
False True
False True
[1, 2, 3, 4]
[[100, 2], [3, 4]]
```

![](https://ucarecdn.com/157b959d-acf2-4d7e-854b-c6de1fea3a5e/)   Оператор `is` проверяет, ссылаются ли две переменные на один объект, оператор `==` проверяет равенство значений.

**Примечание 2.** Встроенные функции, используемые при создании коллекций (`list, set, dict, ...`), также могут быть использованы для создания поверхностной копии объектов.

Приведенный ниже код:

```python
data1 = [1, 2, 3, 4]
data2 = {'a': 1, 'b': 2}
data3 = {1, 2, 3, 4}

new_data1 = list(data1)
new_data2 = dict(data2)
new_data3 = set(data3)

print(data1 is new_data1, data1 == new_data1)
print(data2 is new_data2, data2 == new_data2)
print(data3 is new_data3, data3 == new_data3)
```

выводит:

```no-highlight
False True
False True
False True
```

**Примечание 3.** Поверхностную копию списка также можно создать с помощью среза всего списка.

Приведенный ниже код:

```python
data = [1, 2, 3, 4]

new_data = data[:]

print(data is new_data, data == new_data)
```

выводит:

```no-highlight
False True
```

Однако не стоит забывать, что такая копия является поверхностной.

Приведенный ниже код:

```python
data = [[1, 2], [3, 4]]

new_data = data[:]

data[0][0] = 10
new_data[1][1] = 40
 
print(data)
print(new_data)
```

выводит:

```no-highlight
[[10, 2], [3, 40]]
[[10, 2], [3, 40]]
```

**Примечание 4.** Документация модуля `copy` на [русском](https://docs-python.ru/standart-library/modul-copy-python/) и [английском](https://docs.python.org/3/library/copy.html) языках.

**Примечание 5.** Для определения размера объектов встроенных типов можно использовать функцию `getsizeof()` модуля `sys`. Данная функция возвращает размер объекта в байтах.

Приведенный ниже код:

```python
import sys

print(sys.getsizeof(10))
print(sys.getsizeof(True))
print(sys.getsizeof(None))
print(sys.getsizeof(''))
print(sys.getsizeof('beegeek'))
```

выводит (на 64-х разрядном компьютере):

```no-highlight
28
28
16
51
56
```

Обратите внимание на то, что с помощью функции `getsizeof()` нельзя вычислять размер сложных объектов, содержащих вложенные структуры (списки списков и т.д.). Для того чтобы правильно определять размер абсолютно любого объекта (включая пользовательские) в Python используется функция `asizeof()` модуля `asizeof`, который находится в библиотеке `pympler`. Документация по библиотеке `pympler` доступна по [ссылке](https://pympler.readthedocs.io/en/latest/). По [ссылке](https://coderzcolumn.com/tutorials/python/pympler-monitor-memory-usage-by-python-objects) можно посмотреть на примеры использования данной библиотеки.