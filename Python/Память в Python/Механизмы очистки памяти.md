## Механизмы очистки памяти

Как мы уже знаем, язык Python является языком с автоматически управляемой памятью, то есть программисту, пишущему код на Python, не нужно беспокоиться о работе с памятью, в частности заниматься ее освобождением. Как только данные программы (объекты в Python) больше не нужны, Python автоматически освобождает память, которую они занимали. Несмотря на это, понимание того, как работает механизм очистки памяти, может помочь писать более качественный и производительный код.

Стандартный интерпретатор Python использует сразу два механизма очистки памяти:

- подсчет ссылок
- сборщик мусора (Garbage Collector, GC)

### Подсчет ссылок

Алгоритм подсчета ссылок — это один из самых простых механизмов очистки памяти. Объекты удаляются как только на них больше нет ссылок.

Каждый объект в Python унаследован от базового класса `PyObject`, который содержит специальное поле `Reference Count (ob_refcnt)`, в котором хранится количество ссылок на данный объект. Как только кто-то начинает ссылаться на объект, значение этого поля увеличивается на единицу. Если по какой-то причине ссылка пропадает, то это поле уменьшается на один. При этом если счетчик ссылок для определенного объекта достигает нуля, то интерпретатор запускает процесс уничтожения объекта. Если удаленный объект содержал ссылки на другие объекты, то эти ссылки также удаляются. Таким образом, удаление одного объекта может повлечь за собой удаление других.

![](https://ucarecdn.com/485eac75-3abf-4193-9b54-4ee2d8124988/)   Механизм подсчета ссылок работает в режиме реального времени.

Приведенный ниже код:

```python
nums = [1, 2, 3]
```

создает объект, у которого поле `Reference Count (ob_refcnt)` равно 11.

![](https://ucarecdn.com/505465d4-ffab-42ec-b670-3ef7390963d5/)

Приведенный ниже код:

```python
nums = [1, 2, 3]
nums1 = nums
```

создает объект, у которого поле `Reference Count (ob_refcnt)` равно 22.

![](https://ucarecdn.com/9cd7432d-d557-480e-9dbb-3e877e8d920c/)

Четыре основных сценария, **увеличивающих** количество ссылок на объект:

- создание нового объекта и присвоение его переменной
- присвоение уже существующего объекта переменной
- передача объекта в функцию в качестве аргумента
- добавление объекта в список, множество, словарь и т.д.

Четыре основных сценария, **уменьшающих** количество ссылок на объект:

1. удаление объекта из области видимости функции после ее завершения
2. удаление переменной с помощью оператора `del`
3. переприсваивание переменной нового значения
4. удаление объекта из списка, множества, словаря и т.д.

Для получения количества ссылок на заданный объект используется функция `getrefcount()` из модуля `sys`.

Приведенный ниже код:

```python
import sys

nums = [1, 2, 3] 

print(sys.getrefcount(nums))
```

выводит:

```no-highlight
2
```

Когда мы вызываем функцию `getrefcount()` для получение количества ссылок на объект, мы увеличиваем количество ссылок на объект на один, так как передаем `nums` в качестве аргумента в функцию. Поэтому счетчик ссылок равен 22. Это означает, что и переменная `nums`, и функция `getrefcount()` ссылаются на один и тот же список `[1, 2, 3]`.

Можно поэкспериментировать и написать такой код:

```python
import sys

nums = [1, 2, 3]                            # ссылка 1
nums1 = nums                                # ссылка 2
nums2 = nums1                               # ссылка 3
temp = [4, 5, 6, nums, nums1, nums2]        # ссылка 4, 5, 6
print(sys.getrefcount(nums))                # ссылка 7
```

который выводит число 77.

Алгоритм подсчета ссылок очень простой и эффективный, но у него есть один большой недостаток. Он не умеет определять **циклические ссылки**.

Приведенный ниже код:

```no-highlight
nums1 = [1, 2, 3]
nums2 = [4, 5]

nums1.append(nums2)
nums2.append(nums1) 
```

создает циклические ссылки, так как `nums1` содержит ссылку на `nums2`, в то время как `nums2` содержит ссылку на `nums1`. Таким образом, счетчики ссылок у `nums1` и `nums2` никогда не будут равны нулю.

Приведенный ниже код:

```no-highlight
nums = [1, 2, 3]
nums.append(nums)
```

также создает циклическую ссылку, так как `nums` содержит ссылку на себя самого.

Именно из-за этого в Python существует дополнительный механизм очистки памяти — сборщик мусора (Garbage Collector, GC), который следит за объектами с потенциальными циклическими ссылками.

![](https://ucarecdn.com/3ed7f418-3828-49b3-9e05-e69cb0bc8d9b/)В Python алгоритм подсчета ссылок является фундаментальным и не может быть отключен, тогда как сборщик мусора (GC) опционален и может быть отключен.

### Сборщик мусора

В отличие от алгоритма подсчета ссылок, сборщик мусора не работает в режиме реального времени и запускается периодически. Каждый запуск сборщика создаёт микропаузы в работе программы, поэтому Python использует различные [эвристики](https://ru.wikipedia.org/wiki/%D0%AD%D0%B2%D1%80%D0%B8%D1%81%D1%82%D0%B8%D0%BA%D0%B0) для определения частоты запуска сборщика мусора.

Сборщик мусора разделяет все объекты на 33 поколения (нулевое, первое и второе). Новые объекты попадают в нулевое поколение. Если новый объект выживает в процессе сборки мусора, то он перемещается в следующее поколение. Чем старше поколение, тем реже оно сканируется на сборку мусора. Так как новые объекты зачастую имеют очень маленький срок жизни (являются временными), то имеет смысл проверять их чаще, чем те, которые уже прошли через несколько этапов сборки мусора.

В каждом поколении есть специальный порог срабатывания, при достижении которого срабатывает процесс сборки мусора. Если сразу несколько поколений преодолели порог, то выбирается наиболее старшее поколение, так как сборка мусора в старших поколениях включает в себя также сборку мусора и в младших поколениях.

![](https://ucarecdn.com/f4e7baf7-8d02-4702-84ca-3d2b549e4196/)​​   Дополнительно прочитать про сборку мусора можно на вики по [ссылке](https://ru.wikipedia.org/wiki/%D0%A1%D0%B1%D0%BE%D1%80%D0%BA%D0%B0_%D0%BC%D1%83%D1%81%D0%BE%D1%80%D0%B0).

Для взаимодействия со сборщиком мусора используется модуль `gc`.

Наиболее полезные функции модуля:

- `gc.enable()`: включает сборщика мусора (по умолчанию он включен)
- `gc.disable()`: отключает сборщика мусора
- `gc.isenabled()`: возвращает `True`, если сборщик мусора включен, или `False` в противном случае
- `gc.collect()`: запускает сборщика мусора на всех трех поколениях. Функция имеет необязательный аргумент `generation` (целое число от 00 до 22), указывающий номер поколения, в котором нужно запустить сборщика мусора

## Примечания

**Примечание 1.** Документация по модулю `gc` доступна по [ссылке](https://docs.python.org/3/library/gc.html).

**Примечание 2.** Исходный код сборщика мусора доступен по [ссылке](https://github.com/python/cpython/blob/051295a8c57cc649fa5eaa43526143984a147411/Modules/gcmodule.c#L94).

**Примечание 3.** Счетчик ссылок подвержен проблемам в многопоточной среде, которые могут приводить к некорректности обновления этого счетчика из разных потоков и, следовательно, к удалению объектов, на которые еще существуют ссылки. Чтобы этого избежать, CPython использует [GIL — Global Interpreter Lock](https://ru.wikipedia.org/wiki/%D0%93%D0%BB%D0%BE%D0%B1%D0%B0%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F_%D0%B1%D0%BB%D0%BE%D0%BA%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0_%D0%B8%D0%BD%D1%82%D0%B5%D1%80%D0%BF%D1%80%D0%B5%D1%82%D0%B0%D1%82%D0%BE%D1%80%D0%B0). Каждый раз, когда происходит работа с памятью, GIL — как глобальная блокировка — препятствует выполнению этих действий одновременно из двух потоков. Он гарантирует, что сначала отработает один, потом другой.

![](https://ucarecdn.com/65a671ca-8d30-4ccc-bcbb-468e9dbcfcd8/)

Почитать подробнее про GIL можно по [ссылке](https://habr.com/ru/company/wunderfund/blog/586360/).

**Примечание 4.** Количество ссылок на определенный объект иногда может оказаться заметно больше, чем кажется на первый взгляд.

Приведенный ниже код:

```python
import sys

print(sys.getrefcount(0))     # число 0
print(sys.getrefcount(1))     # число 1
print(sys.getrefcount(''))    # пустая строка
print(sys.getrefcount(()))    # пустой кортеж
```

может выводить:

```no-highlight
164
84
58
1257
```

Дело в том, что многие неизменяемые объекты уже используются, например, в реализациях встроенных функций и типов данных. Объекты, относящиеся к изменяемым типам данных данной особенности не подвержены, так как изменение такого объекта в одной части программы привело бы к его изменению в другой части программы.

Приведенный ниже код:

```python
import sys

print(sys.getrefcount([]))       # пустой список
print(sys.getrefcount({}))       # пустой словарь
print(sys.getrefcount(set()))    # пустое множество
```

выводит:

```no-highlight
1
1
1
```

**Примечание 5.** Прочитать статью о том, как Instagram стал работать быстрее после отключения сборщика мусора, можно по [ссылке](https://habr.com/ru/company/wunderfund/blog/328404/).

**Примечание 6.** При отображении объектов, содержащих циклические ссылки, используется специальная нотация в виде троеточия.

Приведенный ниже код:

```python
nums = [1, 2, 3]
nums.append(nums)

print(nums) 
```

выводит:

```no-highlight
[1, 2, 3, [...]]
```

**Примечание 7.** Помимо обычных ссылок на объект в Python существуют слабые ссылки, которые не увеличивают счетчик ссылок и тем самым не препятствуют удалению объекта. Для работы со слабыми ссылками используется модуль `weakref`, подробнее о котором можно почитать на [русском](https://docs-python.ru/standart-library/modul-weakref-python/) и [английском](https://docs.python.org/3/library/weakref.html) языках.

**Примечание 8.** Визуализировать граф всех Python объектов можно с помощью модуля [objgraph](https://mg.pov.lt/objgraph/). Данный модуль позволяет создавать изображения наподобие следующего:

![image](https://habrastorage.org/getpro/habr/post_images/3d8/355/be9/3d8355be99fea997cae6aff7fd7fb6b2.svg)

**Примечание 9.** [PyObject](https://github.com/python/cpython/blob/v3.7.3/Include/object.h#L101) определяется как C структура, которая характерна для CPython (стандартной реализации), и представляет базовую структуру всех объектов Python.