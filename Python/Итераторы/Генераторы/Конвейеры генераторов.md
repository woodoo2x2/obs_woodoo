Конвейеры генераторов

Как мы уже знаем, у итераторов есть замечательная особенность: их можно комбинировать. Это позволяет вместо огромных циклов с перемешанными этапами обработки писать небольшие блоки, которые стыкуются друг с другом. К примеру, мы часто использовали встроенные функции `filter()` и `map()`, для того чтобы сначала отфильтровать данные, а затем их преобразовать.

Приведенный ниже код:

```python
numbers = [1, 2, -9, 8, 3, -4, -2, -1, 0, 2, 91, 69]

odd_numbers = filter(lambda num: num % 2, numbers)

abs_odd_numbers = map(abs, odd_numbers)

print(*abs_odd_numbers)
```

выводит:

```no-highlight
1 9 3 1 91 69
```

Генераторы являются итераторами, поэтому мы можем компоновать их, создавая тем самым так называемые конвейеры (цепочки) генераторов.

Приведенный ниже код:

```python
def integers(n):
    for i in range(1, n + 1):
        yield i

def evens(iterable):
    for i in iterable:
        if not i % 2:
            yield i

def squared(iterable):
    for i in iterable:
        yield i * i

def negated(iterable):
    for i in iterable:
        yield -i

chain = negated(squared(evens(integers(10))))

print(*chain)
```

выводит:

```no-highlight
-4 -16 -36 -64 -100
```

Самое главное в конвейерах генераторов это то, что обработка данных происходит по одному элементу за раз. Между этапами обработки в цепочке нет буферизации: генератор целых чисел выдает единственное значение, скажем, 44. Это активирует генератор четных чисел, который обрабатывает это значение, и поскольку оно четное, передает его на следующий этап в виде числа 4. Далее активируется генератор квадратов, который обрабатывает значение 4 и передает его на следующий этап как 42=16. Далее активируется генератор инвертирования знака, который изменяет знак числа 16 на противоположный и порождает значение −16.

Мы можем продолжать расширять эту цепочку генераторов, чтобы построить конвейер обработки со многими шагами. Он по-прежнему будет работать эффективно и может быть легко изменен, поскольку каждый шаг в цепочке представляет собой отдельную генераторную функцию.

Конвейеры данных выглядят еще нагляднее, если они построены на основе генераторных выражений.

Приведенный ниже код:

```python
n = 10

integers = (i for i in range(1, n + 1))
evens = (i for i in integers if not i % 2)
squared = (i * i for i in evens)
negated = (-i for i in squared)

print(*negated)
```

полностью аналогичен примеру выше.

Читабельность кода повышается за счет того, что вместо цикла с перемешанными этапами обработки данных, мы пишем небольшие блоки, отвечающие за конкретные задачи, которые стыкуются друг с другом.

Мы можем использовать и генераторные функции и генераторные выражения для построения конвейеров обработки данных. При проектировании конвейеров генераторов один генератор вкладывается в другой.

 Генераторы — невероятно мощная программная конструкция. Они позволяют писать потоковый код с меньшим количеством промежуточных данных. Кроме того, они более эффективно используют память и ЦП.

Программный код:

```python
def something():
    result = []
    for ... in ...:
        result.append(x)
    return result
```

можно заменить на:

```python
def iter_something():
    for ... in ...:
        yield x
```

При этом, если действительно нужны возможности списка (тип `list`), то можно написать: 

```python
def something():
    return list(iter_something())
```