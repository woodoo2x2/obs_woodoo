

**У всех итерируемых объектов** есть магический метод [[Магический метод __iter__()]], который преобразует итерируемый объект в итератор. Встроенная  [[Функция iter()]] вызывает за кулисами именно этот магический метод.

Приведенный ниже код:

```python
words = ['hello', 'beegeek', 'python']

iterator = iter(words)      # за кулисами вызывается метод words.__iter__()

print(type(words))
print(type(iterator))
```

выводит:

```1c
<class 'list'>
<class 'list_iterator'>
```

**У всех итераторов** есть  [[Магический метод __next__()]], который обеспечивает выдачу очередного элемента. Встроенная функция [[Функция next()]] вызывает за кулисами именно этот магический метод. 

Приведенный ниже код:

```python
words = ['hello', 'beegeek', 'python']

iterator = iter(words)      # за кулисами вызывается метод words.__iter__()

print(next(iterator))       # за кулисами вызывается метод iterator.__next__()
print(next(iterator))       # за кулисами вызывается метод iterator.__next__()
```

выводит:

```no-highlight
hello
beegeek
```

  Когда элементы в итераторе закончились, очередной вызов функции `next()` возбуждает исключение `StopIteration`.

Если объект итератором не является, то есть у него нет магического метода `__next__()`, то вызов функции `next()` приведет к ошибке.

Приведенный ниже код:

```python
words = ['hello', 'beegeek', 'python']

print(next(words))
```

приводит к возникновению исключения:

```no-highlight
TypeError: 'list' object is not an iterator
```

**У всех итераторов** также есть и метод `__iter__()`, который возвращает сам итератор (сам себя). Таким образом, любой итератор является итерируемым объектом, но не наоборот, не любой итерируемый объект является итератором.

Приведенный ниже код:

```python
words = ['hello', 'beegeek', 'python']

iterator1 = iter(words)          # за кулисами вызывается метод words.__iter__()
iterator2 = iter(iterator1)      # за кулисами вызывается метод iterator1.__iter__()

print(iterator1 == iterator2)
```

выводит:

```no-highlight
True
```

Таким образом, если функции `iter()` передается итератор, то она возвращает его же. Если же функции `iter()` передать итерируемый объект, не являющийся итератором (например, список), то она вернет совсем другой объект – итератор на основе этого итерируемого объекта.

Возникает вопрос, для чего итераторы содержат магический метод `__iter__()`. Все дело в том, что цикл `for` ожидает, что у объекта, по которому идет итерирование, есть не только магический метод `__next__()`, но и `__iter__()`. Задача метода `__iter__()` – превращать итерируемый объект в итератор. Если в цикл `for` передается уже итератор, то метод `__iter__()` этого объекта должен возвращать сам объект.

Если циклу `for` передается не итератор, а итерируемый объект, то его метод `__iter__()` должен возвращать не сам объект, а итератор на основе этого итерируемого объекта.

Получается, в итераторах метод `__iter__()` нужен лишь для совместимости. Ведь если `for` работает как с итераторами, так и итерируемыми объектами, но последние требуют преобразования к итератору, и `for` вызывает `__iter__()` без оценки того, что ему передали, то требуется, чтобы оба – итератор (`iterator`) и итерируемый объект (`iterable`) – поддерживали этот метод. С точки зрения наличия в классе метода `__iter__()` итераторы можно считать подвидом итерируемых объектов.

![](https://ucarecdn.com/6d97deae-aee6-4738-b5c8-64b28668deb2/)

