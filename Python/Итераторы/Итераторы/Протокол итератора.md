

Теперь формализуем протокол итератора :

1. чтобы получить итератор, мы должны передать функции [[Функция iter()]] итерируемый объект
2. далее мы передаём итератор функции [[Функция next()]]
3. когда элементы в итераторе закончились, вызов функции `next()` возбуждает исключение `StopIteration`

Особенности:

1. любой объект, передаваемый функции `iter()` без исключения `TypeError` — итерируемый объект
2. любой объект, передаваемый функции `next()` без исключения `TypeError` — итератор
3. любой объект, передаваемый функции `iter()` и возвращающий сам себя — итератор

  Любой итерируемый объект реализует протокол итератора.

## Особенность функции iter()

Встроенная функция `iter()`, как мы уже знаем, преобразует итерируемый объект в итератор. Именно в таком виде функция используется в большинстве случаев.

```no-highlight
iter(iterable) -> iterator
```

Однако мы можем использовать функцию `iter()` в еще одном полезном сценарии:

```no-highlight
iter(callable, sentinel) -> iterator
```

Если функции `iter()` передается два аргумента, то первый аргумент `callable` должен являться функцией, а второй аргумент `sentinel` — некоторым стоп-значением. В этом случае, созданный итератор будет вызывать указанную функцию `callable` и проверять полученное значение на равенство со значением `sentinel`. Если полученное значение равно `sentinel`, то возбуждается исключение `StopIteration`, иначе итератор выдает значение, полученное из функции `callable`.

Например, с помощью функции `iter()` мы можем создать бесконечный итератор, генерирующий единственное значение — 00.

Приведенный ниже код:

```python
zero_iterator = iter(int, -1)

for i in range(5):
    print(next(zero_iterator))

print(type(zero_iterator))
```

выводит:

```no-highlight
0
0
0
0
0
<class 'callable_iterator'>
```

Функция `int()`, которую мы передаем в качестве первого аргумента в функцию `iter()`, всегда возвращает значение 0, при этом вторым аргументом (стоп-значением) является −1, которое не будет возвращено никогда. Таким образом, мы построили бесконечный итератор, генерирующий единственное нулевое значение.

Мы также можем написать итератор, который генерирует неопределенное количество случайных чисел.

Приведенный ниже код:

```python
from random import choice

def test_iter():
    values = list(range(1, 11))
    return choice(values)

random_iterator = iter(test_iter, 2)

for num in random_iterator:
    print(num)
```

может вывести:

```no-highlight
1
3
3
9
4
3
5
```

Итератор `random_iterator` будет генерировать случайное число от 1 до 10 до тех пор, пока не будет возвращено число 2.

Одним из применений второго аргумента `sentinel` является чтение строк файла до тех пор, пока не будет достигнута строка `sentinel`.

Приведенный ниже код:

```python
with open('data.txt') as file:
    for line in iter(file.readline, ''):    # читаем, пока не попадется пустая строка 
        # Делаем что-то с line.
```

считывает строки текстового файл `data.txt` до тех пор, пока очередная строка не окажется пустой.

Итерируемый объект (`iterable`) и итератор (`iterator`) – это протоколы, правила.

