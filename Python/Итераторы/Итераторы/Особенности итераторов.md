

Как мы уже выяснили, [[Итератор]] — специальный объект, который выдает свои элементы по одному за раз.

Если итератор передать во встроенную [[Функция next()]], то эта функция вернет его следующий элемент. При этом сам итератор также сдвинется на следующий элемент. При следующем вызове функция `next()` вернет следующий элемент и т.д. Если же в итераторе элементов больше не осталось, то вызов функции `next()` приведет к возбуждению исключения `StopIteration`, а сам итератор становится совершенно бесполезным, так как опустошен.

Итераторы очень глубоко интегрированы в язык Python, и многие языковые конструкции позволяют их использовать.

### Цикл for

Самое простое, что можно сделать с итератором, — это его последовательный обход с помощью цикла `for`.

Приведенный ниже код:

```python
numbers = [-3, 6, 1, -90, 34, -25, 23, -21]

positive_numbers = map(abs, numbers)     # создаем объект итератора

for num in positive_numbers:             # обходим итератор циклом for
    print(num)
```

выводит:

```no-highlight
3
6
1
90
34
25
23
21
```

По сути, за кулисами цикл `for` вызывает встроенную функцию `next()`, передавая ей в качестве аргумента итератор `positive_numbers`. Функция `next()` последовательно возвращает значения итератора, применяя к ним функцию `abs()` до тех пор, пока не будет возвращено последнее значение, после чего возбуждается исключение `StopItеration`, и цикл `for` завершается. По мере вызова функции `next()` итератор `positive_numbers` опустошается и в конце концов становится совершенно бесполезным.

Приведенный ниже код:

```python
numbers = [-3, 6, 1, -90, 34, -25, 23, -21]

positive_numbers = map(abs, numbers)     # создаем объект итератора

for num in positive_numbers:             # обходим итератор циклом for
    print(num)

for num in positive_numbers:             # обходим пустой итератор, тело цикла выполнено не будет
    print(num)
```

выводит все тот же результат:

```no-highlight
3
6
1
90
34
25
23
21
```

поскольку после первого цикла `for` итератор `positive_numbers` становится пустым и его повторный обход ни к чему не приведет.

Обратите внимание на то, что цикл `for` сам перехватывает исключение `StopIteration`. Если самостоятельно вызвать функцию `next()` на пустом итераторе, мы получим исключение.

Приведенный ниже код:

```python
numbers = [-3, 6, 1, -90, 34, -25, 23, -21]

positive_numbers = map(abs, numbers)     # создаем объект итератора

for num in positive_numbers:             # обходим итератор циклом for
    print(num)

print(next(positive_numbers))            # пытаемся получить элемент из пустого итератора
```

приводит к возбуждению исключения `StopIteration`.

Преобразование в коллекцию

Помимо последовательного прохода по итератору с помощью цикла `for` мы можем использовать встроенные функции [[Функция list()]], [[Функция tuple()]] и т.д. для преобразования итератора в коллекцию.

Приведенный ниже код:

```python
numbers = [-3, 6, 1, -90, 34, -25, 23, -21]

positive_numbers = map(abs, numbers)                 # создаем объект итератора
positive_numbers_list = list(positive_numbers)       # преобразуем итератор в список

print(positive_numbers_list)
```

выводит:

```no-highlight
[3, 6, 1, 90, 34, 25, 23, 21]
```

Функция `list()` в данном случае преобразует итератор в список и за кулисами обходит итератор до конца, тем самым опустошая его.

Приведенный ниже код:

```python
numbers = [-3, 6, 1, -90, 34, -25, 23, -21]

positive_numbers = map(abs, numbers)                  # создаем объект итератора

positive_numbers_list1 = list(positive_numbers)       # преобразуем итератор в список
positive_numbers_list2 = list(positive_numbers)       # преобразуем пустой итератор в список

print(positive_numbers_list1)
print(positive_numbers_list2)
```

выводит:

```no-highlight
[3, 6, 1, 90, 34, 25, 23, 21]
[]
```

Так как получить элементы итератора возможно лишь единожды, второй список оказывается пустым.

### Оператор принадлежности in

Оператор принадлежности `in` работает и с итераторами. Проверка на вхождение осуществляется путем перебора всех элементов последовательно, и как только элемент обнаружен, поиск прекращается.

Приведенный ниже код:

```python
numbers = [4, 8, 15, 16, 23, 42]

iterator = iter(numbers)              # создаем итератор на основе списка

print(15 in iterator)
```

выводит:

```no-highlight
True
```

Однако тут нужно понимать, что по мере поиска итератор опустошается, поскольку оператор `in` за кулисами вызывает функцию `next()` для получения следующего элемента.

Приведенный ниже код:

```python
numbers = [4, 8, 15, 16, 23, 42]

iterator = iter(numbers)              # создаем итератор на основе списка

print(15 in iterator)
print(15 in iterator)
```

выводит:

```no-highlight
True
False
```

При этом после второй проверки на принадлежность итератор `iterator` полностью опустошается и последующие поиски по нему всегда будут приводить к результату `False`.

Приведенный ниже код:

```python
numbers = [4, 8, 15, 16, 23, 42]

iterator = iter(numbers)              # создаем итератор на основе списка

print(15 in iterator)
print(23 in iterator)
```

выводит:

```no-highlight
True
True
```

поскольку как только элемент 15 обнаружен, поиск прекращается, и в итераторе остается три числа 16,23,42

### Распаковка итератора

Мы также можем распаковывать содержимое итератора, автоматически опустошая его.

Приведенный ниже код:

```python
numbers = [4, 8, 15, 16, 23, 42]

iterator = iter(numbers)              # создаем итератор на основе списка

print(*iterator)
print(list(iterator))
```

выводит:

```no-highlight
4 8 15 16 23 42
[]
```

 Обратите внимание на то, что при итерировании циклом `for` по словарю мы получаем только ключи.

Приведенный ниже код:

```python
people = {'name': 'Timur', 'age': 29, 'gender': 'male', 'profession': 'teacher'}

for key in people:
    print(key)
```

выводит:

```no-highlight
name
age
gender
profession
```

Аналогично при распаковке словаря, мы получаем только ключи.

Приведенный ниже код:

```python
people = {'name': 'Timur', 'age': 29, 'gender': 'male', 'profession': 'teacher'}

print(*people)
```

выводит:

```no-highlight
name age gender profession
```

встроенные типы [[Тип данных list]], [[Тип данных tuple]], [[Тип данных set]], [[Тип данных dict]], [[Тип данных str]] не являются итераторами, хотя на их основе можно создавать итераторы.

Приведенный ниже код:

```python
numbers = [4, 8, 15, 16, 23, 42]

print(15 in numbers)
print(8 in numbers)
print(15 in numbers)
print(42 in numbers)
```

выводит:

```no-highlight
True
True
True
True
```

В то время как код:

```python
numbers = [4, 8, 15, 16, 23, 42]

iterator = iter(numbers)              # создаем итератор на основе списка

print(15 in iterator)
print(8 in iterator)
print(15 in iterator)
print(42 in iterator)
```

выводит:

```no-highlight
True
False
False
False
```


.
 Встроенные функции [[Функция max()]] и [[Функция min()]] также умеют работать с любыми итерируемыми объектами, включая итераторы.

Приведенный ниже код:

```python
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

squares = map(lambda num: num ** 2, numbers)
cubes = map(lambda num: num ** 3, numbers)

print(max(squares))
print(min(cubes))
```

выводит:

```no-highlight
100
1
```

Однако нужно быть очень аккуратным при использовании итераторов в функциях `max()` и `min()`. Дело в том, что для поиска максимального и минимального значения функции должны полностью обойти итератор. А значит, после их применения итераторы становятся пустыми.

Приведенный ниже код:

```python
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

squares = map(lambda num: num ** 2, numbers)
cubes = map(lambda num: num ** 3, numbers)

print(max(squares))
print(min(cubes))

print(list(squares))
print(list(cubes))
```

выводит:

```no-highlight
100
1
[]
[]
```

 Встроенные функции [[Функция all()]] и [[Функция any()]] также умеют работать с любыми итерируемыми объектами, включая итераторы.

 Функция [[Функция reduce()]]из модуля [[Модуль functools]] также работает с любыми итерируемыми объектами, включая итераторы. Функция `reduce()` обычно завершает цепочку итераторов и возвращает итоговый результат.

 Важно знать особенность встроенной функции [[Функция sorted()]]. Такая функция принимает в качестве аргумента любой итерируемый объект, а возвращает отсортированный [[list (Списки)|список]] состоящий из элементов итерируемого объекта. Именно список, а не итератор. Таким образом функция `sorted()` работает не лениво, а записывает все данные из итерируемого объекта в память компьютера.
 
Встроенная функция [[Функция open()]], открывающая файл, также возвращает итератор, который позволяет обойти содержимое файла, не загружая его целиком в память.

 Использование итераторов приводит к выигрышу с точки зрения потребляемой памяти. Однако при этом скорость программы замедляется.