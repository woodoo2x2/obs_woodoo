**Итератор** — специальный объект, который выдает свои элементы по одному за раз.

Если итератор передать во встроенную [[Функция next()]], то эта функция вернет его следующий элемент. При этом сам итератор также сдвинется на следующий элемент. При следующем вызове функция `next()` вернет следующий элемент и т.д. Если же в итераторе элементов больше не осталось, то вызов функции `next()` приведет к возникновению исключения `StopIteration`.

Преимущества итераторов

Основными преимуществами использования итераторов являются:

- однотипность работы с объектами разных типов
- ленивые вычисления и экономия потребляемой памяти
- комбинация множества итераторов для создания понятной и читабельной программы

 Однотипность работы с объектами разных типов

Итераторы позволяют разным объектам притворяться одинаковыми. Списки, кортежи, строки, множества, словари, объекты типа `range` имеют разные типы, но мы можем использовать любой из этих объектов:

- в цикле `for`
- в функциях высшего порядка [[Функция map()]], [[Функция filter()]], [[Функция reduce()]], [[Функция reversed()]]и т.д.
- для проверки наличия некоторого значения с помощью оператора принадлежности `in`
- для распаковки элементов с помощью `*` и т.д.

Цикл `for` в Python работает по следующему принципу:

- создает итератор на основе итерируемого объекта
- запрашивает очередной элемент из итератора с помощью функции `next()` и передает его в выполняемый блок кода (тело цикла)
- останавливается при получении исключения `StopIteration`

Благодаря этому, в цикл `for` можно передать и список, и кортеж, и строку, и объект типа `range`, и многие другие объекты, которые имеют свои итераторы.

По сути, приведенный ниже код:

```python
numbers = [1, 2, 3, 4]

for num in numbers:
    print(num)
```

за кулисами превращается в:

```python
numbers = [1, 2, 3, 4]

iterator = iter(numbers)           # создается итератор

while True:
    try:
        item = next(iterator)
        print(item)
    except StopIteration:
        break
```

Ленивые вычисления предполагают, что не нужно ничего делать до тех пор, пока в этом нет необходимости. Это не просто удобно, но и позволяет экономить память и время на вычисление.

Приведенный ниже код:

```python
numbers = range(5)             # 5 чисел в последовательности

for num in numbers:
    print(num)
```

выводит:

```no-highlight
0
1
2
3
4
```

Объекты типа `range` являются итерируемыми объектами. Цикл `for` создает на основе объекта `range` итератор, у которого запрашивает элементы по одному, пока не будет достигнут конец последовательности чисел. В нашем примере, пока не будет получено число 4.

Важно понимать, что объект типа `range` не хранит весь набор чисел. Он создает новое число (на лету) только тогда, когда оно потребуется, при этом старые значения не хранятся. Размер объектов `range` не зависит от количества чисел, которые предполагается перебрать, ведь нужно помнить только начальное и конечное значения последовательности, шаг и текущее значение.

Приведенный ниже код:

```python
from sys import getsizeof

numbers1 = range(5)                  # 5 чисел в последовательности
numbers2 = range(100000)             # 100000 чисел в последовательности
numbers3 = range(10000000000000)     # 10000000000000 чисел в последовательности

print(getsizeof(numbers1))
print(getsizeof(numbers2))
print(getsizeof(numbers3))
```

выводит (размер в байтах):

```no-highlight
48
48
48
```

Все объекты `range` имеют один и тот же размер в памяти — 48 байт. Такой подход позволяет создавать "большие" итераторы (даже бесконечные), не занимая много памяти.

Заметим, что мы можем преобразовать любой итерируемый объект в список. Однако при таком преобразовании все элементы итерируемого объекта будут записаны в память.

Приведенный ниже код:

```python
from sys import getsizeof

numbers1 = list(range(5))                  # 5 чисел в списке
numbers2 = list(range(100000))             # 100000 чисел в списке

print(getsizeof(numbers1))
print(getsizeof(numbers2))
```

выводит (размер в байтах):

```no-highlight
96
800056
```

Чем больше элементов в списке, тем больше памяти он занимает. Преобразование итерируемого объекта в список не всегда будет заканчиваться удачно.

Приведенный ниже код:

```python
from sys import getsizeof

numbers3 = list(range(10000000000000))     # 10000000000000 чисел в списке

print(getsizeof(numbers3))
```

приводит в возникновению исключения `MemoryError`. Python не позволяет нам создать такой большой список 

Объекты типа `range` являются ленивыми, преобразовывать их в списки стоит с особенной аккуратностью и только тогда, когда это действительно необходимо.


У итераторов есть замечательная особенность: их можно комбинировать. Это позволяет вместо огромных циклов с перемешанными этапами обработки писать небольшие блоки, которые стыкуются друг с другом.

Приведенный ниже код:

```python
sentence = 'In the face of ambiguity refuse the temptation to guess'

filter_iterator = filter(lambda word: len(word) > 4, sentence.split())   # фильтруем
map_iterator = map(lambda word: word.upper(), filter_iterator)           # преобразовываем
enumerate_iterator = enumerate(map_iterator, 1)                          # нумеруем

for index, value in enumerate_iterator:                                  # выводим
    print(f'{index}. {value}')
```

выводит:

```no-highlight
1. AMBIGUITY
2. REFUSE
3. TEMPTATION
4. GUESS
```

Обратите внимание на то, что все три объекта `filter_iterator, map_iterator, enumerate_iterator` являются итераторами. Они не хранят все данные в памяти, а создают и выдают их по мере того, как их запрашивают. Другими словами, при обращении к очередному элементу `enumerate_iterator` произойдет последовательное обращение сначала к элементу `map_iterator`, а затем к элементу `filter_iterator`.
  Имейте в виду, что от порядка, в котором комбинируются итераторы, зависит итоговый результат.
Важно понимать разницу между итерируемыми объектами и итераторами:

- `iterable` (итерируемый) — это свойство того, по кому будет происходить итерирование
- `iterator` (итерирующий) — это тот, кто ходит

Другими словами, `iterable` — сущность, по которой ходим, книга, которую листаем, а `iterator` — листающая сущность, палец,  который указывает на нужный лист в книге.