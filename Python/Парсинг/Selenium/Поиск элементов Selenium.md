# Поиск элементов [Selenium](https://www.selenium.dev/documentation/webdriver/elements/locators/)

Вспомним урок _[Поиск элементов на странице](https://stepik.org/lesson/694518/step/1?unit=694308)._ Перечитайте его, чтобы вспомнить содержание, и пусть он будет открыт во второй вкладке для подсказок.

Перед началом изучения этой темы необходимо понять, что такое локаторы, потому что с ними будем работать постоянно.

[**Локатор**](https://www.selenium.dev/documentation/test_practices/encouraged/locators/) - это способ идентификации элементов на странице. Это аргумент, передаваемый методам поиска элементов.

Локаторы играют очень важную роль при работе с **Selenium**. Они обеспечивают путь к веб-элементам, которые необходимы для автоматизации определенных действий, таких как клик, ввод, установка флага и др.

Для начала, импортируем класс `By` из модуля `selenium.webdriver.common.by`:

```
from selenium.webdriver.common.by import By
```

Выглядит класс `By` следующим образом.  
![](https://ucarecdn.com/b1fedf76-7a67-4777-99c3-5ac95062df12/)

Класс `By` — это, по сути, перечисление, которое содержит различные стратегии поиска элементов на веб-странице. Использование `By` позволяет сделать код более читаемым и поддерживаемым, так как это стандартизирует способы поиска элементов. 

- `**By.ID**` – Поиск элемента по уникальному идентификатору (`id`). Этот метод очень быстрый и надежный, но требует, чтобы у элемента был атрибут `id`.
    
    ```
    element = driver.find_element(By.ID, "some_id")
    ```
    
- `**By.CSS_SELECTOR**` – Поиск элемента или элементов, используя селекторы CSS. Это гибкий и мощный метод, который может выразить сложные критерии поиска.
    
    ```
    elements = driver.find_elements(By.CSS_SELECTOR, ".some_class")
    ```
    
- **`By.XPATH`** – Поиск элемента с помощью языка XPath. XPath позволяет создать более сложные запросы, но он менее читаемый и, возможно, будет работать медленнее, чем другие методы.
    
    ```
    element = driver.find_element(By.XPATH, "//div[@attribute='value']")
    ```
    
- `**By.NAME**` – Поиск элемента по атрибуту `name`. Этот метод хорошо подходит для форм.
    
    ```
    element = driver.find_element(By.NAME, "username")
    ```
    
- `**By.TAG_NAME**` – Поиск элемента по названию HTML-тега. Этот метод полезен, если нужно выбрать, например, все изображения на странице.
    
    ```
    images = driver.find_elements(By.TAG_NAME, "img")
    ```
    
- `**By.CLASS_NAME**` – Поиск элемента или элементов по классу. Этот метод полезен, если у элементов есть общий класс.
    
    ```
    buttons = driver.find_elements(By.CLASS_NAME, "btn")
    ```
    
- `**By.LINK_TEXT**` – Поиск элемента по точному тексту ссылки. Очень удобно, если текст уникален.
    
    ```
    element = driver.find_element(By.LINK_TEXT, "Continue")
    ```
    
- `**By.PARTIAL_LINK_TEXT**` – Поиск элемента по частичному тексту ссылки. Удобно, когда точный текст ссылки неизвестен или динамичен.
    
    ```
    element = driver.find_element(By.PARTIAL_LINK_TEXT, "Cont")
    ```
    

Локаторы используются с помощью двух универсальных методов - `find_element()`, который возвращает ровно один элемент, найденный первым, и `find_element**s**()`, который возвращает список найденных элементов. 

### `.find_element()`

Метод `find_element()` используется, когда вам нужно найти один конкретный элемент на странице. Он возвращает первый элемент, который соответствует заданным критериям поиска. Если элемент не найден, Selenium сгенерирует исключение `NoSuchElementException`.

```
# Ищем элемент с тегом img
elements = driver.find_element(By.TAG_NAME, 'img')
```

### `.find_elements()`

Метод `find_element**s**()` полезен, когда вы хотите получить список всех элементов, которые соответствуют заданным критериям. В отличие от `find_element()`, этот метод вернёт пустой список, если ничего не найдено, вместо того чтобы генерировать исключение.

```
# Ищем все элементы с классом some_class
elements = driver.find_elements(By.CLASS_NAME, 'some_class')
```

Пример кода с поиском элемента и клика по нему.`**.find_element(By.ID, "sale_button")**`

```python
import time
from selenium import webdriver
from selenium.webdriver.common.by import By

browser = webdriver.Chrome()
browser.get('http://parsinger.ru/html/watch/1/1_1.html')
button = browser.find_element(By.ID, "sale_button").click()

time.sleep(10)


```

Когда наш парсер отработает, мы бы хотели, чтобы он закрылся сам и тем самым корректно завершил свою работу. Но это может не произойти по множеству причин. Поэтому мы должны указать браузеру, что он должен закрыть окно после завершения работы, командой `driver.**quit()**`. Важно закрывать окно, потому что при создании `webdriver.Chrome()` создается процесс в **ОС**, который продолжит висеть. Команда `quit()` проще, чем закрывать окно браузера вручную, к тому же вы не будете засорять оперативную память.

Расставим таймауты в коде, чтобы видеть процесс выполнения кода и чтобы браузер не закрывался за мгновение.

```python
import time
from selenium import webdriver
from selenium.webdriver.common.by import By

driver= webdriver.Chrome()
driver.get('http://parsinger.ru/html/watch/1/1_1.html')
button = driver.find_element(By.ID, "sale_button")
time.sleep(2)
button.click()
time.sleep(2)
driver.quit()
```

Если ошибка произойдет во время выполнения кода до команды `.quit()` , сеанс **WebDriver** не будет закрыт должным образом, и файлы не будут удалены из памяти.

Для того, чтобы код гарантированно завершил свою работу командой  `driver.quit()`, используем конструкцию  `try/finally`. Весь код после `finally`: будет гарантированно выполнен.

```python
import time
from selenium import webdriver
from selenium.webdriver.common.by import By


try:
    driver= webdriver.Chrome()
    driver.get('http://parsinger.ru/html/watch/1/1_1.html')
    button = driver.find_element(By.ID, "sale_button")
    time.sleep(2)
    button.click()
    time.sleep(2)
finally:
    driver.quit()
```

Но есть еще третий способ, мой любимый, -  это менеджер контекста `with/as`. С этим способом нам вообще не нужно думать о том, когда закрывать браузер, менеджер контекста делает это за нас в тот момент, когда это нужно.

```python
import time
from selenium import webdriver
from selenium.webdriver.common.by import By

with webdriver.Chrome() as driver:
    driver.get('http://parsinger.ru/html/watch/1/1_1.html')
    button = driver.find_element(By.ID, "sale_button")
    time.sleep(2)
    button.click()
    time.sleep(2)
```

Выполните эти три примера у себя в терминале, чтобы посмотреть, как всё работает.

Самое время сказать, что вообще-то есть два похожих метода, которые часто путают новички: это `driver.close()` и `driver.quit()`. Сможете догадаться, чем они отличаются, не подглядывая в текст дальше?

`driver.close()` - закрывает текущее окно браузера, если во время работы вы открыли новое окно или вкладку.

`driver.quit()` - закрывает все окна, вкладки, процессы веб-драйвера, которые были запущены во время сессии.

**Некоторые проблемы WebDriver (из сети и личного опыта):**

- Поведение Selenium может отличаться в разных браузерах;
- Иногда возникают сложности с поиском элементов (XPath и другие методы иногда просто не работают, хотя должны);
- Необъяснимые падения драйвера прямо посреди работы скрипта;
- Взаимодействие возможно только с активной вкладкой браузера, хотя драйвер позволяет открывать новые вкладки и новые окна, но не позволяет одновременно в них работать, только поочерёдно.