_Все примеры выполнены в браузерe Chrome._

Вы можете находить элементы на веб-странице различными способами: используя HTML-теги, CSS-селекторы, атрибуты и их значения.

Вот некоторые примеры:

- `**id**="**name_id**"`: по идентификатору;
- `class="**name_class**"`: по имени класса;
- **`<div>`**: по имени тега;
- `**href**="link"`: по атрибуту;
- `name="**item**"`: по значению атрибута.

Откройте [страницу](http://parsinger.ru/html/hdd/4/4_17.html) в своём браузере, вызовите инструменты разработчика, нажав клавишу `F12`. Далее откройте панель поиска по дереву HTML, используя комбинацию клавиш `Ctrl+F`. После освоения этого модуля, в разделе, посвященном Selenium, мы приступим к написанию парсеров, применяя полученные знания.1

![](https://ucarecdn.com/9b32d32b-4346-4c1a-b599-523a51ee87b2/)

**Поиск по `#id`**

Символ "**`#`**" служит базовым селектором для поиска элементов по значению атрибута `id`. Этот метод особенно удобен, так как каждый `id` на веб-странице является уникальным. Следовательно, можно быть уверенным, что в HTML-документе найдется только один элемент с указанным `id`.

Для выполнения поиска по `id` применяется синтаксис вида `#значение_атрибута`. В качестве примера возьмем `#brand`. Для закрепления материала, попробуйте осуществить поиск по `id` на различных тегах самостоятельно по ссылке ниже.

Альтернативно, можно воспользоваться синтаксисом с квадратными скобками: `[id='brand']`. Этот метод дает такой же результат, как и `#brand`, но требует ввода большего количества символов. Выбор метода зависит от ваших личных предпочтений и сценария использования.

Понимание работы с селектором `#` является ключевым моментом при разработке парсера. Отобранный по `id` элемент чаще всего служит ключевой точкой доступа к конкретному тегу и информации на странице. Поскольку `id` уникален, ошибочный сбор данных исключается, что существенно повышает надежность вашего парсера.

_[ссылка для поиска](https://parsinger.ru/html/headphones/5/5_1.html)_

![](https://ucarecdn.com/08ba0eb4-a70d-4d42-9adf-f8018f95be12/)

**Поиск по `.class`**

Символ "**`.`**" является базовым селектором, позволяющим выбирать элементы по имени класса. Синтаксис весьма прост и понятен: `.имя_класса`, например, `.description`. Как альтернатива, можно использовать синтаксис с квадратными скобками: `[class="headers"]`.

Важно отметить, что при использовании селектора класса возможно получение нескольких элементов, поскольку один и тот же класс может быть присвоен разным элементам на странице. Это отличает поиск по классу от поиска по `id`, где каждый идентификатор уникален.

Для парсинга это означает, что если ваша цель — получить все элементы с определенным классом, данный метод будет крайне полезен. Но если необходимо найти конкретный элемент, возможно, придется дополнительно фильтровать результаты или использовать другие селекторы для уточнения поиска.

_[ссылка для поиска](https://parsinger.ru/html/index5_page_1.html#5_1)_

![](https://ucarecdn.com/bdf9861b-daea-42ef-bf64-d54a052a72e2/)

**Поиск по имени тега**

Самый простой способ отыскать определённый тег — это ввести его имя в строке поиска разработчика браузера. Например, `headers` или `div`. Этот метод особенно полезен, если вам нужно получить все элементы данного типа на странице — например, все абзацы, обозначенные тегом `<p>`.  
  
Если вы ищете тег, состоящий из одного символа, такой как `a` или `p`, будьте осторожны: в результатах поиска появятся не только соответствующие теги, но и все вхождения этих символов в тексте на странице. ![](https://ucarecdn.com/3e8a3afa-7b55-4c5d-a9d2-264f6f689432/) или 

![](https://ucarecdn.com/587a5f20-8654-4ae3-84fe-9fc9b9217cee/)

Для точного поиска только тегов используйте угловые скобки в вашем запросе, например: `<a>` или `<p>`.  
  
Метод поиска по имени тега является одним из наиболее базовых и распространённых в парсинге. Он часто используется в качестве отправной точки для дальнейшего уточнения селекторов или комбинирования с другими методами поиска. Однако, следует помнить о тонкостях, таких как вхождение символов в текст, чтобы избежать неточностей и ошибок при сборе данных.

_[ссылка для поиска](http://parsinger.ru//html/index4_page_1.html)_

![](https://ucarecdn.com/ac3e0978-141b-4b1d-ad21-22a30ada62da/)

```python
# Комбинированный поиск: ищем все абзацы с классом "my_class" и атрибутом "data-example"

soup.select('p.my_class[data-example]')
```

```
from bs4 import BeautifulSoup
import requests

# Получаем содержимое веб-страницы
response = requests.get('https://parsinger.ru/2.1/DOM/example.html')
response.encoding = 'utf-8'
soup = BeautifulSoup(response.text, 'html.parser')

# Комбинированный поиск: ищем все абзацы с классом "my_class" и атрибутом "data-example"
paragraphs = soup.select('p.my_class[data-example]')

# Выводим найденные элементы
for p in paragraphs:
    print(f'Найденный элемент: {p.text}')
```

Вывод:

```
Найденный элемент: Это абзац с классом my_class и атрибутом data-example.
```

Для ранней практики, вы можете потренероваться на других комбинированных элементах на этой [странице](https://parsinger.ru/2.1/DOM/example.html). 

**Поиск по значению атрибута** `**name**="**item**"`

В этом разделе мы уже коснулись использования квадратных скобок для поиска элементов по `class` и `id`. Однако это лишь вершина айсберга: квадратные скобки позволяют выполнять поиск по любым атрибутам и их значениям. Например, для поиска элемента с атрибутом `name` равным "**4_1**", вы можете применить синтаксис `[name="4_1"]`. И вы будете абсолютно правы в своём выборе.  
  
Необходимо учитывать, что такой метод поиска вернет все элементы с указанным атрибутом на веб-странице. Это может оказаться полезным, если вам нужно собрать все подобные элементы, но также может вызвать недочеты в сборе данных, если ваша задача требует большей специфичности.  
  
[ссылка для поиска](http://parsinger.ru//html/index4_page_1.html)

![](https://ucarecdn.com/8fd13c0e-fe12-4221-a28d-09d9b30a8417/)
#ПарсингPython 