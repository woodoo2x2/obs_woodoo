К этому моменту у вас уже должно быть сформировано понимание того, как работают Синхронность и [[Асинхронность]]. Помимо этого, существуют такие понятия, как многопоточность, конкурентность и параллелизм, которые тоже важно понимать.

Синхронность и асинхронность могут работать как в однопоточном, так и в многопоточном режиме.

**Синхронность/Однопоточность** — это программная модель, в которой потоку назначается только одна задача в единицу времени. После этого начинается её выполнение. Когда завершено выполнение первой задачи, начинается выполнение второй, и так далее до завершения всех задач. В этой модели невозможно остановить выполнение одной задачи для того, чтобы выполнить другую. При синхронных запросах большую часть времени код ничего не делает, только ждёт ответа от сервера, что существенно его замедляет. Это наглядно продемонстрировано на рисунке ниже (рисунок отсутствует в тексте). Так происходит потому, что в Python есть GIL([Global Interpreter Lock](https://ru.wikipedia.org/wiki/%D0%93%D0%BB%D0%BE%D0%B1%D0%B0%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F_%D0%B1%D0%BB%D0%BE%D0%BA%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0_%D0%B8%D0%BD%D1%82%D0%B5%D1%80%D0%BF%D1%80%D0%B5%D1%82%D0%B0%D1%82%D0%BE%D1%80%D0%B0)), который предоставляет доступ к интерпретатору только одному потоку в единицу времени. Этот доступ разблокируется только когда выполнение задачи завершено. Про GIL мы ещё подробнее поговорим в одном из следующих степов.

![](https://ucarecdn.com/87a4ecd0-0476-4141-9256-32bc5a79658b/)

Асинхронность, в отличие от синхронной модели, позволяет приостановить выполнение одной задачи, передать управление другой, сохранив при этом текущее состояние первой задачи. После этого можно вернуться к выполнению первой задачи. Переключение между задачами происходит в момент простоя первой задачи. Например, был отправлен запрос к серверу, и пока мы ждём ответ, управление передаётся второй задаче.

Запрос к серверу — это очень короткая по времени операция. Однако, когда ваш парсер будет делать тысячи запросов в асинхронном режиме и во время ожидания ответа будет выполнять другие запросы, скорость вашего парсера может вырасти в разы.

На картинке ниже видно, что при асинхронном выполнении запросов время ожидания заполнено другими запросами или получением ответа от сервера. На практике порядок выполнения запросов может быть совершенно другим; это зависит от скорости ответа сервера.

![](https://ucarecdn.com/31e5ce86-a928-4327-9c23-164b81473937/)

Если ваша цель — написать асинхронный многопоточный код, то он будет выглядеть вот так. Обратите внимание: Task1, Task2, Task3 и другие задачи обрабатываются несколькими потоками. Они запускаются в одном потоке и завершаются в другом. Это наглядно демонстрирует максимальное использование потоков.

![](https://ucarecdn.com/f35f51d0-76d9-4e82-8015-5de0e0339e3e/)

На изображении ниже наглядно изображено отличие двух этих моделей.

В асинхронной модели переключение между запросами или задачами происходит в тех местах, где мы указываем ключевое слово `await`.

![](https://ucarecdn.com/2bd61aaa-7043-492f-87ae-b7263e29d0b1/)

Для закрепления запустите этот код у себя в терминале. Смело можете добавлять любое количество сайтов в список `urls`. Вникать в код сейчас не нужно; дальше мы разберем его максимально подробно. Сейчас нужно просто понять, как происходят запросы и переключения между ними.

**Если у вас не запускается код ниже, удалите следующую строку.**

```
asyncio.set_event_loop_policy(asyncio.WindowsSelectorEventLoopPolicy())
```

```python
import asyncio
import aiohttp
from codetiming import Timer

#---------------------start block 1------------------------
urls = ["http://google.com",
        "http://yahoo.com",
        "http://apple.com",
        "http://microsoft.com",
        "https://habr.com/",
        "https://www.youtube.com/",
        "https://stepik.org/",
        "https://docs.python.org/",
        "https://stackoverflow.com/",
        "https://www.reg.ru/"]
#---------------------end block 1------------------------



#---------------------start block 2------------------------
async def main(url):
    with Timer(text=f"Затрачено времени на запрос: {{:.3f}} сек"):
        async with aiohttp.ClientSession() as session:
            async with session.get(url) as resp:
                print(resp.url)
#---------------------end block 2------------------------


async def run_tasks():
    tasks = [main(link) for link in urls]
    await asyncio.gather(*tasks)

#---------------------start block 3------------------------
if __name__ == '__main__':
    asyncio.set_event_loop_policy(asyncio.WindowsSelectorEventLoopPolicy())
    asyncio.run(run_tasks())
#---------------------end block 3------------------------

Ожидаемый результат:
>>> https://www.reg.ru/
    Затрачено времени на запрос: 0.162 сек
    https://www.youtube.com/
    Затрачено времени на запрос: 0.179 сек
    https://docs.python.org/3/
    Затрачено времени на запрос: 0.220 сек
    https://stackoverflow.com/
    Затрачено времени на запрос: 0.325 сек
    https://www.apple.com/
    Затрачено времени на запрос: 0.330 сек
    https://habr.com/en/all/
    Затрачено времени на запрос: 0.578 сек
    https://stepik.org/
    Затрачено времени на запрос: 0.578 сек
    http://www.google.com/
    Затрачено времени на запрос: 0.836 сек
    https://www.yahoo.com/
    Затрачено времени на запрос: 1.344 сек
    https://www.microsoft.com/ru-ru/
    Затрачено времени на запрос: 1.705 сек
```

Результат выполнения этого кода будет всегда разный, и это зависит от скорости ответа сервера. Как мы видим, `reg.ru` отвечает намного быстрее, чем `stepik.org`. Именно за этот короткий промежуток времени происходит переключение между запросами или задачами. Может показаться, что запросы к серверу происходят одновременно, но это не так.

[[Многопоточность]] — это модель, в которой мы создаем и используем несколько потоков для работы с нашими задачами. Мы указываем нужное количество потоков, исходя из наших потребностей и мощности нашего оборудования. Обычно мы используем больше задач, чем потоков. Если бы мы использовали неограниченное количество потоков, нам бы не хватило ресурсов процессора и оперативной памяти.



![](https://ucarecdn.com/d5a61e97-c92f-4281-a3fc-1900d02a6f66/)

[[Модуль asyncio]] — это библиотека для написания конкурентного кода с использованием синтаксиса `async/await`.

`asyncio` используется в качестве основы для многих асинхронных фреймворков, в том числе для `aiohttp` и `aiofiles`, которые мы будем изучать в этом разделе курса.

`asyncio` идеально подходит для IO-операций. IO-операции — это операции ввода-вывода. В этих операциях практически не задействована мощность процессора и не происходит никаких сложных вычислений. Поскольку шина или устройство ввода/вывода могут быть недоступны для чтения/записи в единицу времени, был придуман асинхронный подход. Разница между IO-операциями и CPU-операциями не всегда очевидна, и можно ошибиться. Но, к счастью, мы на курсе по парсингу, и тут нам даже гадать не стоит: все наши операции попадают под категорию IO (ввод/вывод).

#### Особенности asyncio:

- Работает конкурентно.
- Использует один поток и одно ядро по умолчанию.
- При необходимости может использовать хоть тысячи потоков.

Первый и самый основной недостаток — это сложность отладки кода. Если в синхронном коде разобраться довольно просто (здесь мы обычно используем принты или библиотеки для логирования), то в асинхронном коде всё не так очевидно.

Второй недостаток плавно вытекает из первого: обработка исключений невозможна вне асинхронных функций. Это можно сделать только внутри event loop, и для этого существует отдельный обработчик `loop.set_exception_handler()`, который устанавливает новый обработчик исключений.

Третий недостаток — это сложность понимания, какая асинхронная функция выполняется в данный момент. Радует тот факт, что для написания асинхронных парсеров не требуется большое количество функций: как правило, нам необходимо написать от двух до пяти. Но когда вам нужно написать большое количество асинхронных функций, начинаются трудности.

Четвёртый недостаток — сложно читаемый код. Сложность чтения асинхронного кода состоит в том, что все асинхронные функции запускаются через event loop. То есть, мы формируем список задач, который состоит из корутин, после чего передаём его в event loop, где и происходит основная магия. Про то, как устроен event loop, мы будем говорить в следующих разделах курса.

Пятый недостаток заключается в том, что в асинхронных функциях нельзя использовать функции, которые используют CPU-bound операции. В таком случае они будут блокировать выполнение других задач (task) в тот момент, пока идёт вычисление результата для функции. Что такое CPU-bound и IO-bound, вы узнаете в следующих разделах курса. Если коротко, то CPU-bound — это операции, использующие процессор для вычисления, а IO-bound — это операции, использующие ввод/вывод. Именно по этой причине модуль называется asyncio.

#ПарсингPython 