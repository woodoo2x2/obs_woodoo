**Coroutines** **(Корутины)** — это функции, которые могут быть приостановлены и возобновлены. Они позволяют контролировать моменты своей приостановки и возобновления работы, что делает их идеальными для сценариев асинхронного программирования, например, при выполнении длительных задач, ожидании данных от внешних ресурсов или выполнении других корутин.

### Пишем первый асинхронный код. Ключевые слова `async` и `await`.

Для создания корутины нужно использовать ключевое слово `async`.

```python
import asyncio


async def example_coroutine():
    print("Hello from coroutine!")
```

Если функция начинается с конструкции `async def`, она является асинхронной функцией, и внутри неё можно использовать ключевое слово `await` для вызова других корутин или асинхронных операций внутри тела этой корутины. Использование ключевого слова `await` вне корутины вызовет ошибку. 

```python
import asyncio


async def example_coroutine():
    await asyncio.sleep(1)  # запускаем внутри корутины асинхронную функцию sleep()
    print("Hello from coroutine!")
```

Корутина может принимать аргументы и возвращать значения. Правила передачи аргументов аналогичны правилам для обычных синхронных функций. 

```python
import asyncio


async def example_coroutine(number, *args, **kwargs):
    await asyncio.sleep(1)  # запускаем внутри корутины асинхронную функцию sleep()
    print(f"Hello from coroutine {number}!")
    return f"Корутина {number} завершила работу"
```

### **Запуск корутины. Функция `asyncio.run()`.**

Мы создали первую корутину `example_coroutine()`. Для ее запуска нужно использовать функцию `asyncio.run()`. Если попытаться запустить корутину, как обычную функцию, выполнение корутины не начнется. Вместо этого будет создан объект корутины. 

```python
#НЕ ПРАВИЛЬНО
async def example_coroutine():
    print("Hello from coroutine!")

example_coroutine()  # создан объект корутины example_coroutine(), корутина не запущена!


#ПРАВИЛЬНО
async def example_coroutine():
    print("Hello from coroutine!")

asyncio.run(example_coroutine())  # корутина example_coroutine() запущена. 
```

### Кооперативная многозадачность.

Корутины поддерживают модель *_кооперативной многозадачност_и, в отличие от *_вытесняющей многозадачности_, используемой с потоками. Это значит, что корутины сами передают управление обратно в цикл событий. Если корутина явно не передала управление, то она будет выполняться до ее полного завершения.


[_Кооперативная многозадачность_](https://en.wikipedia.org/wiki/Cooperative_multitasking#:~:text=Cooperative%20multitasking%2C%20also%20known%20as,running%20process%20to%20another%20process.) _— В кооперативной многозадачности задачи сами решают, когда им следует уступить контроль другим задачам. Это означает, что каждая задача должна активно передать управление системе, чтобы другие задачи могли выполняться._

**Аналогия:**  
_Представьте, что у нас есть группа друзей, которые решили вместе сделать проект. Они сидят в одной комнате и работают на одном компьютере. По правилам, только один человек может работать за компьютером в один момент времени. В случае с кооперативной многозадачностью, каждый член группы сам решает, когда ему встать и уступить место за компьютером следующему. Это означает, что если кто-то из них слишком увлечётся и забудет уступить место, остальные не смогут продолжить работу. Это может привести к задержкам в выполнении проекта, потому что никто другой не сможет внести свой вклад, пока этот человек не решит передать очередь._  
 

_Преимущества такого подхода в том, что всё довольно просто организовать. Нам не нужен сложный план или расписание, кто и когда будет работать. Это также снижает нагрузку на "систему" — в нашем случае, не нужно тратить время на решение, кто следующий будет работать за компьютером._

_Однако есть и недостатки. Если кто-то из друзей будет действовать эгоистично и занимать компьютер слишком долго, проект может застопориться. Другие не смогут внести свой вклад, пока он не решит уступить место.  
  
Такой подход часто используется в ситуациях, где ресурсы ограничены (например, когда только один компьютер доступен для группы людей) или в специализированных системах, где очень важно точно знать, сколько времени займёт выполнение каждой задачи, как в системах реального времени, где каждая задержка может привести к серьёзным последствиям.

# Вытесняющая многозадачность

[_Вытесняющая многозадачность_](https://ru.wikipedia.org/wiki/%D0%92%D1%8B%D1%82%D0%B5%D1%81%D0%BD%D1%8F%D1%8E%D1%89%D0%B0%D1%8F_%D0%BC%D0%BD%D0%BE%D0%B3%D0%BE%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%BD%D0%BE%D1%81%D1%82%D1%8C#:~:text=%D0%92%D1%8B%D1%82%D0%B5%D1%81%D0%BD%D1%8F%D1%8E%D1%89%D0%B0%D1%8F%20%D0%BC%D0%BD%D0%BE%D0%B3%D0%BE%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%BD%D0%BE%D1%81%D1%82%D1%8C%20(%D0%BF%D1%80%D0%B8%D0%BE%D1%80%D0%B8%D1%82%D0%B5%D1%82%D0%BD%D0%B0%D1%8F%20%D0%BC%D0%BD%D0%BE%D0%B3%D0%BE%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%BD%D0%BE%D1%81%D1%82%D1%8C%2C%20%D0%B0%D0%BD%D0%B3%D0%BB,%D0%BF%D0%BE%20%D0%B8%D1%81%D1%82%D0%B5%D1%87%D0%B5%D0%BD%D0%B8%D0%B8%20%D0%BD%D0%B5%D0%BA%D0%BE%D0%B5%D0%B3%D0%BE%20%D0%BA%D0%B2%D0%B0%D0%BD%D1%82%D0%B0%20%D0%B2%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%B8.) _— В вытесняющей многозадачности операционная система принимает решения о том, когда задаче следует начать или прекратить выполнение. Это достигается за счет прерываний, которые временно останавливают выполнение текущей задачи для запуска другой задачи, обеспечивая более равномерное распределение процессорного времени между задачами._  
 

**Аналогия:**

_Представьте, что у вас есть организатор вечеринки, который решает, кто из гостей будет играть музыку в данный момент. Этот организатор внимательно следит за временем, чтобы убедиться, что каждый получит шанс быть DJ на протяжении вечера. Если кто-то играет слишком долго, организатор может вежливо прервать и дать возможность следующему гостю включить свою музыку._ 

_Сложность здесь в том, что организатору нужно тщательно планировать, когда и как переключаться между гостями, чтобы все оставались довольны. Это требует от организатора постоянного внимания и может быть довольно утомительно, так как каждый раз при смене DJ нужно заново настраивать оборудование, что в нашей аналогии соответствует "переключению контекста" в компьютере. Это может снизить общую "производительность вечеринки", поскольку уходит время на переключения, но в то же время гарантирует, что никто не будет чувствовать себя обделённым._

_Основное преимущество такой системы - это справедливость и отзывчивость. Если какой-то гость (или программа) начинает "вести себя плохо", занимая слишком много времени или "зависая", организатор (операционная система) может вмешаться и исправить ситуацию, давая шанс другим._

Кооперативная многозадачность осуществляется через корутины с использованием ключевых слов `async/await`. Это позволяет создавать асинхронный код, где корутины/задачи явно указывают моменты своего приостановления и возобновления с помощью `await`.

### Точка входа. Запуск нескольких корутин.

В предыдущем примере мы создали  корутину `example_coroutine()` и запустили ее с помощью функции `asyncio.run()`. В реальных асинхронных приложениях есть различные корутины, каждая из которых выполняется много раз. Для того чтобы реализовать возможность запуска множества задач, а не одной, необходимо создать еще одну корутину, которая будет являться *точкой входа для асинхронного приложения. Из данной корутины будут запущены все необходимые корутины или задачи. 

*_Точка входа в асинхронную программу означает место, где начинается асинхронное выполнение кода, т.е. первая запускаемая корутина. Для такой корутины обычно используется имя `main()`._

Попробуем изменить наш код и запустить корутину `example_coroutine()` через точку входа. Для этого создадим корутину `main()`, внутри нее запустим `example_coroutine()`.

Для запуска корутин и задач из других корутин нужно использовать ключевое слово `await`.

```python
import asyncio


async def example_coroutine():
    await asyncio.sleep(1) 
    print("Hello from coroutine!")

async def main():
    await example_coroutine() # запускаем example_coroutine() и ждем выполнения

asyncio.run(main())  # Точка входа
```

Мы увидим то же самое поведение, что и в примере выше. Корутина `example_coroutine()` выполнится и на экран будет выведено сообщение:

```
Hello from coroutine!
```

Но теперь мы получили код, который можно масштабировать. Внутри `main()` мы можем запустить корутину `example_coroutine()` нужное нам число раз или запустить из `main()` другую корутину.

```python
import asyncio


async def example_coroutine():
    print("Hello from coroutine!")
    await asyncio.sleep(1)

async def main():
    for _ in range(10):
        await example_coroutine()

asyncio.run(main())  
```

В этом примере мы запускаем корутину `example_coroutine()` 10 раз. Вы можете заметить, что каждая корутина выполняется последовательно, а не конкурентно. Время выполнения такой программы составит чуть больше 10 секунд. Такое поведение пока не соответствует тому, что мы хотим получить от асинхронного программирования. Как запустить корутины конкурентно  рассмотрим в следующем уроке, а пока предлагаем ответить на несколько вопросов и потренироваться в написании простых корутин.