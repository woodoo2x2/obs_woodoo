В предыдущем уроке мы посмотрели как создавать корутины и запускать их. При этом конкурентного выполнения корутин не было, а ведь суть асинхронного программирования именно в этом. Для реализации кооперативной многозадачности, в которой управление передается от одной корутины к другой, нужно использовать задачи (объекты класса `Task`).

### Создание и запуск задачи. Метод `asyncio.create_task()`.

Задачи представляют собой обертки для корутин и используются для их конкурентного выполнения. Для создания задачи используется функция `asyncio.create_task()`. Возьмем пример из предыдущего урока и попробуем выполнить корутину `example_coroutine()`, обернув ее в задачу. 

```python
import asyncio


async def example_coroutine():
    await asyncio.sleep(1) 
    print("Hello from coroutine!")

async def main():
    task = asyncio.create_task(example_coroutine())  # создаем задачу из корутины example_coroutine()
    await task # ждем выполнения задачи

asyncio.run(main())
```

Функция`asyncio.create_task()` принимает объект корутины и возвращает объект класса `Task`. Возвращаемая задача, сразу добавляется в цикл событий и планируется к выполнению. Выполняться же она начнет при ближайшем переключении контекста (обычно это ключевое слово `await`).

Если мы посмотрим `type()` задачи, мы увидим там следующее: `<class '_asyncio.Task'>`.

```
print(type(asyncio.create_task(example_coroutine())))

>>> <class '_asyncio.Task'>
```

Объекты задачи, как и корутины, всегда следует запускать с оператором `await`.

`Task`/задачи предоставляют дополнительные возможности, такие как отслеживание состояния задачи, ожидание её завершения или отмены, или получение результата выполненной корутины и получения исключения. Подробнее будем говорить о методах задач [в модуле, посвященном объектам Task](https://stepik.org/lesson/933724/step/1?unit=939623), а пока рассмотрим конкурентное выполнение нескольких задач. 

### Выполнение нескольких задач конкурентно. Метод `asyncio.gather()`.

Как только задача создана из корутины, она становится независимой. Это означает, что выполнение задачи больше не связано напрямую с корутиной, которая её породила. Задача будет запланирована и управляема циклом событий , который определяет, когда задача получит возможность, чтобы начать свое выполнение. Цикл событий предоставляет такую возможность всем задачам, запланированным к запуску, при первой же смене контекста (`await`), и запускает её (задачу) асинхронно.

Попробуем создать в нашем примере 10 задач и запустить их конкурентно.  Для создания задач используем метод `asyncio.create_task()`, а для конкурентного запуска метод `asyncio.gather()`.

```python
import asyncio


async def example_coroutine():
    await asyncio.sleep(1)
    print("Hello from coroutine!")

async def main():
    tasks = []
    for _ in range(10):
        task = asyncio.create_task(example_coroutine())  # создаем 10 задач
        tasks.append(task)  # добавляем все задачи в список tasks
    await asyncio.gather(*tasks)  # запускаем все задачи из списка tasks

asyncio.run(main())
```

Попробуйте запустить данный код и увидите, что время выполнения программы чуть больше секунды. Сообщения из каждой корутины выводятся практически одновременно. Метод `asyncio.gather()` в качестве аргументов принимает объекты `Task` или объекты корутины. 

### Аналогия из реальной жизни с `asyncio.create_task()` и `asyncio.gather()`:

Вы менеджер в ресторане, и у вас есть несколько поваров, работающих одновременно. У каждого из поваров есть своя специализация и набор задач, которые нужно выполнить. Ваша задача как менеджера - назначать задачи поварам и официантам и следить за их выполнением. А также в случае необходимости следить, чтобы некоторые заказы готовились и подавались одновременно.   

В данном случае менеджер аналогичен циклу событий, а повара и официанты — асинхронным задачам (`task`). Когда вы назначаете задачу повару с помощью `asyncio.create_task()`, вы позволяете этому повару начать выполнение задачи, не ожидая завершения его работы, и переходите к назначению других задач другим поварам.

Как только повар заканчивает свою задачу, он сообщает об этом вам (_задача завершается_). Вы, в свою очередь, можете сказать официанту (_другой корутине_) забрать блюдо и передать его клиенту. 

Таким образом, `asyncio.create_task()` позволяет вам, как менеджеру, работать с несколькими поварами/официантами конкурентно, управлять их задачами и обрабатывать результаты по мере их выполнения. А `asyncio.gather()` позволяет готовить заказы одновременно.

**Давайте создадим код, иллюстрирующий эту аналогию.**

```python
import asyncio

# Список поваров.
chef_list = ['', 'Франсуа', 'Жан', 'Марсель']


async def cook_order(order_number, dish):
    # Повар готовит блюдо
    print(f"Повар {chef_list[order_number]} начинает готовить заказ №{order_number}: {dish}")
    await asyncio.sleep(2)  # Имитация времени на готовку
    print(f"Заказ №{order_number}: {dish} готов!")
    return f"{dish} для заказа №{order_number}"


async def serve_order(order_number, dish):
    # Официант подает блюдо
    await cook_order(order_number, dish)
    print(f"Официант подает {dish}")


async def manager():
    # Менеджер (событийный цикл) назначает задачи
    orders = [(1, 'Салат'), (2, 'Стейк'), (3, 'Суп')]
    tasks = [asyncio.create_task(serve_order(order_number, dish)) for order_number, dish in orders]

    # Ожидаем завершения всех задач
    await asyncio.gather(*tasks)


# Запуск событийного цикла
asyncio.run(manager())
```

 Вывод:

```
Повар Франсуа начинает готовить заказ №1: Салат
Повар Жан начинает готовить заказ №2: Стейк
Повар Марсель начинает готовить заказ №3: Суп
Заказ №1: Салат готов!
Официант подает Салат
Заказ №2: Стейк готов!
Официант подает Стейк
Заказ №3: Суп готов!
Официант подает Суп
```

- _Функция `cook_order()` аналогична работе повара, который готовит блюдо. Эта функция использует `await asyncio.sleep(2)`, чтобы имитировать время, затрачиваемое на приготовление блюда._
    
- _Функция `serve_order()` соответствует действиям официанта, который получает заказ, передает его повару (`cook_order())` , ожидает, пока блюдо не приготовится и подает его._
    
- _Функция `manager()` играет роль менеджера ресторана, который назначает задачи официанту и использует `asyncio.create_task()` для их планирования. Создание задач позволяет официанту (`serve_order`) раздать задания каждому повару (`cook_order`)._
    
- _Используя `asyncio.gather()`, менеджер отдает команду получить все заказы официанту и в итоге дождаться завершения всех задач, т.е., задачи официанта будут завершены только после того, как все блюда будут готовы и поданы._

**Важно!** Сохраняйте ссылку на результат функции `asyncio.create_task()`, чтобы задача не исчезла в процессе выполнения. Цикл событий сохраняет только слабые ссылки на задачи (_тип ссылки в Python, которая не препятствует удалению объекта, на который она ссылается_). Задача, на которую больше нигде нет ссылок, кроме слабых ссылок цикла событий, может быть удалена сборщиком мусора в любое время, даже до того, как она будет выполнена. Для надежных фоновых задач типа "запустил и забыл" нужно собрать их в коллекцию (_множество, список или кортеж_), как мы это делали в примерах выше.

Ниже продемонстрирован плохой пример — создание задачи без сохранения ссылок, т. е. без создания переменных или списка задач. Код ниже хоть и запустится, но в других ситуациях задача может быть удалена сборщиком мусора.

```python
import asyncio

async def my_task():
    print(f"{'-' * 10}\nRunning my task")
    await asyncio.sleep(1)
    print(f"Task complete\n{'-' * 10}")

async def main():
    # Создаем задачу без сохранения ссылки на нее
    asyncio.create_task(my_task())
    # Здесь произойдет запуск задачи, однако стоит помнить,
    # что эта задача может быть удалена сборщиком мусора в любой момент.
    await asyncio.sleep(2)

asyncio.run(main())
```

В этом конкретном случае задача будет выполнена, но такое поведение не гарантировано, в силу особенностей работы сборщика мусора Python.