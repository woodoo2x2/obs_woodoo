### Улучшенная производительность

Основное преимущество библиотеки `**asyncio**` - возможность писать более эффективный код. Это значит, что у асинхронных приложений есть способность конкурентно выполнять большое количество задач, а также избегать блокировок потока, связанных с ожиданием ресурсов. В обычных приложениях, когда поток должен ждать выполнения какой-либо операции, он блокируется и не может выполнять другие задачи. В `**asyncio**` приложение может выполнять другие задачи во время ожидания, что в результате повышает производительность приложения.

Давайте еще раз посмотрим на пример из предыдущего урока:

```python
import time
import asyncio

start = time.time()


async def sleeping(n):
    print(f"Начало выполнения длительной операции № {n}: {time.time() - start:.4f}")
    await asyncio.sleep(1)  # Имитация длительной операции в 1 секунду длиной.
    print(f"Длительная операция № {n} завершена")


async def main():
    # Запуск 30 задач.
    task = [sleeping(i) for i in range(1, 31)]
    all_results = await asyncio.gather(*task)
    print(f"Выполнено {len(all_results)} операций.")
    print(f"Программа завершена за {time.time() - start:.4f}")

# Запуск главной корутины.
asyncio.run(main())
```

_Данный код демонстрирует всю мощь асинхронного подхода. Сначала мы определили асинхронную функцию `sleeping(n)`, которая имитирует длительный процесс, например, загрузку данных из сети или запрос к базе данных. (Вместо реального запроса, для учебных целей здесь и далее по курсу мы часто будем использовать функцию `await asyncio.sleep(1)`.) Эта строка просто заставляет функцию "уснуть" на 1 секунду, что имитирует задержку, связанную с длительными операциями._

_Когда `sleeping()` "спит", это не означает, что вся программа останавливается. Благодаря асинхронности, Python может переключаться между задачами, выполняя другие операции, которые не требуют ожидания. Это позволяет эффективно использовать время ожидания, вместо того чтобы просто бездействовать._

_В функции `main()` мы создаем 30 асинхронных задач, используя функцию`sleeping()`._ 

_Использование `asyncio.gather(*tasks)` позволяет нам запустить все эти асинхронные задачи "одновременно" и дождаться  результатов их работы. В конце мы выводим количество успешно выполненных задач, что в этом случае будет равно 30, так как каждая задача завершается успешно после имитации длительной операции._

_Этот пример показывает, как асинхронность может значительно повысить производительность, особенно когда дело касается множества операций ввода-вывода. Все это делается без блокировки главного потока программы, что делает ваше приложение более отзывчивым и эффективным._

_* Все функции и ключевые слова библиотеки `asyncio`, использованные в данном примере, будут подробно рассмотрены в курсе. Поэтому пока предлагаю просто запустить данный код у себя и убедиться, что программа, в которой есть 30 задач длительностью 1 секунду, завершается за время немногим превышающее время выполнения одной задачи._ 

### Гибкость

[[Модуль asyncio]] предоставляет гибкость в решении различных задач, требующих многопоточности. Он может использоваться для решения таких задач, как обработка множества запросов к API, обработка большого количества данных в фоновом режиме и т.д. Он также может использоваться для создания многопоточных сетевых приложений, таких как многопользовательские игры и чаты. 

Также с помощью `asyncio` можно выполнять целый ряд последовательных задач конкурентно, например, одновременная загрузка определенного количества файлов и их последующая обработка. 

Далее по курсу будут примеры подобных ситуаций. 

### **Масштабируемость**

`**Asyncio**` позволяет значительно увеличить масштабируемость приложений. Дело в том, что асинхронные приложения не требуют такого количества ресурсов, как синхронные. Для обработки нескольких тысяч открытых соединений в синхронном приложении потребовалось бы такое же количество потоков или процессов. Вместо этого `asyncio` использует *мультиплексирование ввода-вывода для обработки всех этих соединений в рамках одного потока или процесса. Это делает его идеальным для разработки таких высоконагруженных приложений, как веб-серверы или чат-серверы.

*Мультиплексирование

### Большое количество готовых библиотек

Множество существующих библиотек уже используют асинхронный подход.

|Библиотека|Описание|
|---|---|
|[Twisted](https://twisted.org/)|Это одна из самых старых и мощных библиотек для асинхронного  <br>программирования на Python. Twisted поддерживает множество протоколов,  <br>таких как HTTP, DNS, mail, и др. Она также поддерживает асинхронные операции ввода-вывода.|
|[Tornado](https://www.tornadoweb.org/en/stable/)|Это масштабируемый, асинхронный веб-сервер и библиотека сетевых компонентов.  <br>Tornado специально разработан для обработки большого количества  <br>одновременных соединений, он отлично подходит для веб-приложений,  <br>которым необходима долгоживущая связь с каждым пользователем.|
|[gevent](https://www.gevent.org/)|Это библиотека для Python, которая предоставляет API для создания сетевых приложений.  <br>Она использует greenlet - легковесные потоки выполнения - для обработки сетевых операций.|
|[aiohttp](https://docs.aiohttp.org/en/stable/)|Это асинхронная библиотека HTTP для Python с поддержкой сервера и клиента.  <br>Работает на базе asyncio.|
|[Quart](https://pypi.org/project/Quart/)|Это асинхронный веб-фреймворк для Python, аналогичный Flask,  <br>но с поддержкой `async`/`await`. Он позволяет писать асинхронный код с использованием  <br>Flask-like API.|
|[FastAPI](https://fastapi.tiangolo.com/ru/)|Это современный и быстрый (высокопроизводительный) веб-фреймворк  <br>для построения API с Python 3.6+ на основе стандартов для веб API.  <br>FastAPI основан на Starlette для веб-части и Pydantic для части с данными.|
|[Sanic](https://sanic.dev/en/)|Веб-фреймворк Python 3.7+, создан для быстрого написания  <br>асинхронных приложений с помощью `async` и `await`.|
|[uvloop](https://pypi.org/project/uvloop/0.4.12/)|Это быстрая, полностью совместимая реализация цикла событий asyncio на базе libuv.|
|[curio](https://github.com/dabeaz/curio)|Это маленькая библиотека для выполнения одновременных операций  <br>ввода-вывода с использованием синтаксиса `async` / `await` Python.  <br>Она была разработана с упором на корректность и простоту.|
|[asks](https://github.com/theelous3/asks)|Это асинхронная HTTP библиотека для Python с очень простым  <br>и удобным API. Работает на базе asyncio и curio.|
|[httpx](https://www.python-httpx.org/)|Это полноценная библиотека HTTP для Python 3,  <br>которая предоставляет синхронный и асинхронный клиентский API.|
|[trio](https://trio.readthedocs.io/en/stable/)|Это библиотека Python для асинхронного ввода-вывода,  <br>которая призвана упростить написание программ, которые одновременно  <br>выполняют множество задач и обрабатывают множество соединений.  <br>Trio использует синтаксис `async` / `await` и стремится предоставить  <br>высокоуровневые абстракции для написания асинхронного кода.|

Это всего лишь некоторые из множества доступных библиотек для работы. В зависимости от ваших потребностей, вы можете найти еще больше специализированных решений, которые помогут вам решать конкретные задачи в асинхронном программировании.