### Interrupts

Из-за явных недостатков технологии [[Механизм Polling]] в большинстве случаев рекомендуется использовать другие технологии реагирования на события. Один из способов - это использование прерываний (*Interrupts) вместо поллинга, чтобы улучшить эффективность и уменьшить нагрузку на процессор, а также получить немедленный ответ на возникшее событие. 

***Interrupts** (прерывания) - это механизм, который позволяет процессору прерывать текущую задачу и переключаться на выполнение другой задачи, когда происходит определенное событие, такое как нажатие клавиши или получение данных от устройства. Прерывания не нуждаются в постоянном мониторинге устройств или событий. Вместо этого процесс может продолжать выполнение текущей задачи, а когда происходит событие, он прерывается и переключается на возникшую задачу.

**Пример кода с прерыванием:**

Непросто продемонстрировать живой пример прерывания функции, поэтому продемонстрируем наглядный пример с имитацией прерывания каждые 3 секунды. На первый взгляд может быть непонятно, что конкретно происходит в этом коде, но рекомендую его запустить и вдумчиво следить за ходом его работы. Далее в курсе мы ещё вернёмся к описанию всех используемых в этом коде методов и приёмов.

Например, функция `print_message()` может выполняться беспрерывно, выполняя определённые действия каждую секунду, в то время как функция `interrupt_handler()` может проверять флаг `interrupt_flag` в течение всего времени. 

В данном коде прерывание происходит каждые 3 секунды для наглядности демонстрации происходящего в коде, но на практике прерывание должно срабатывать на определённое событие. О событиях и работе с ними мы будем говорить дальше в курсе.

Важно понимать, что во время прерывания может быть вызвана любая другая функция из любой части вашего приложения. Это позволяет прерывать асинхронный код для выполнения функции в другом месте.

_* Класс `asyncio.Event`, использующийся в данном коде для демонстрации механизма прерываний, мы будем разбирать дальше по курсу. В данном примере изменение состояния объекта `asyncio.Event` является сигналом для прерывания выполнения одной задачи и переключения на задачу, ожидающую события._ 

```
import asyncio


async def print_message():
    while True:
        print("Имитация работы функции")
        await asyncio.sleep(1)


async def interrupt_handler(interrupt_flag):
    while True:
        # Ждем установки флага. 
        await interrupt_flag.wait()  
        print("Произошло прерывание! В этом месте может быть установлен любой обработчик")
        # Очищаем флаг для следующего использования
        interrupt_flag.clear()


async def main():
    interrupt_flag = asyncio.Event()
    asyncio.create_task(print_message())
    asyncio.create_task(interrupt_handler(interrupt_flag))

    while True:
        await asyncio.sleep(3)
        # Устанавливаем флаг для прерывания
        interrupt_flag.set()


asyncio.run(main())
```

Вывод:

```python
Имитация работы функции
Имитация работы функции
Имитация работы функции
Произошло прерывание! В этом месте может быть установлен любой обработчик
Имитация работы функции
Имитация работы функции
Имитация работы функции
Произошло прерывание! В этом месте может быть установлен любой обработчик
...

#Код будет выполнятся до бесконечности
```

Функция `print_message()` имитирует рабочий процесс и выводит сообщение "**Имитация работы функции**" каждую секунду.

 Функция `interrupt_handler()` ожидает события (флага прерывания), используя объект `asyncio.Event()` переданный как аргумент `interrupt_flag`. Корутина ждет, пока флаг будет установлен с помощью метода `interrupt_flag.wait()`. Как только флаг устанавливается, выводится сообщение "Произошло прерывание! В этом месте может быть установлен любой обработчик", после чего флаг сбрасывается методом `interrupt_flag.clear()` для следующего использования. Это позволяет корутине вновь перейти к ожиданию установки флага.
    
Функция `main()` создает флаг `interrupt_flag` с помощью `asyncio.Event()`. Затем создаются две задачи: первая выполняет функцию `print_message()`, а вторая — функцию `interrupt_handler()`.  
    В `main()` также содержится бесконечный цикл, в котором каждые три секунды устанавливается флаг прерывания с помощью `interrupt_flag.set()`. Как только флаг устанавливается - активируется корутина `interrupt_handler()`, которая реагирует на прерывание.
    
Программа запускается с помощью `asyncio.run(main())`, что означает начало асинхронного выполнения в контексте нового цикла событий.
Функция `print_message()` непрерывно выводит сообщения, пока функция `interrupt_handler()` реагирует на установленные каждые три секунды прерывания.

### Сравнение Polling и Interrupts. Где что применять?

||**Polling**|**Interrupts**|
|---|---|---|
|**Принцип работы**|Регулярный опрос состояния|Прерывание задачи по сигналу  <br>и переключения на другую задачу|
|**Время реакции на событие**|Может быть значительным, зависит от периодичности опроса|Минимальная, мгновенная реакция|
|**Использование ресурсов**|Высокое из-за постоянных опросов|Использование только при возникновении событий|
|**Инициатор обновления данных**|Система сама опрашивает устройства  <br>(или клиент отправляет запросы на сервер)|Устройства отправляют сигнал системе на прерывание|

**Недостатки механизма Interrupts и его применение**

Несмотря на явные преимущества технологии прерываний у нее есть свои недостатки: более сложная реализация и отладка кода с прерываниями, особенно если несколько устройств будут одновременно посылать сигналы на прерывание. 

Выбор между polling и прерываниями зависит от требований конкретной системы и типа задачи. Polling может быть предпочтительным в простых и менее критичных по времени приложениях, тогда как прерывания обеспечивают высокую реактивность и эффективность в системах, требующих немедленного ответа на события.

Так как технология Interrupts имеет среди недостатков сложности с синхронизацией (когда много устройств одновременно посылают сигнал), то в веб приложениях она практически не применяется, а в основном используется внутри ОС (например, прерывание по нажатию мыши или клавиатуру) или при взаимодействии c устройствами (жесткие диски, сетевые устройства, графические карты и т.д). Если речь идет о простых веб-приложениях, то можно использовать polling или другие технологии, например Long polling, о котором мы поговорим в следующем уроке, а пока предлагаю ответить на несколько вопросов по технологиям, описанным выше.