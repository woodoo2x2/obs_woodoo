
Асинхронное программирование при правильном использовании дает большой плюс к производительности приложения. При этом в Python есть еще одно ограничение, которое непосредственно влияет на эффективность кода. Это Global Interpreter Lock (GIL), так что стоит иметь ввиду данное ограничение в том числе при написании асинхронного кода. 

**GIL** - это мьютекс ([**mutex**](https://stepik.org/lesson/933667/step/1?unit=939566)), который предотвращает выполнение нескольких потоков в одно и то же время. Все потоки должны конкурировать за GIL, чтобы получить доступ к исполнению Python-кода. Таким образом GIL гарантирует, что только один поток выполняет Python-код в любой момент времени. Он был создан для обеспечения безопасности многопоточной работы в CPython (реализация Python на языке C), основной реализации языка Python.

Давайте проще. GIL, это как замок на двери, который не позволяет нескольким потокам одновременно делать что-то. Представьте, что у вас есть один ключ, и все потоки дерутся за право его использовать. Это нужно, чтобы вся программа работала без сбоев: чтобы данные не перепутались и память правильно очищалась после того, как объекты перестают быть нужны.

Гвидо ван Россум, который придумал Python, говорит, что GIL - это компромисс. Он помогает делать программы на Python проще и безопаснее, потому что разработчикам не надо ломать голову над сложностями, связанными с одновременной работой нескольких потоков. Но при этом GIL ограничивает скорость работы программ, когда пытаешься запустить много потоков одновременно.

На одной из конференций Гвидо говорил, что хотя GIL мешает программам работать быстрее на многоядерных компьютерах, он упрощает написание кода. Избавиться от GIL или заменить его на что-то другое было бы очень сложно и дорого, потому что пришлось бы переписывать много чего в самом Python.

В итоге, Гвидо считает, что GIL - это некий баланс между удобством программистов и скоростью выполнения программ. Несмотря на то, что у GIL есть свои минусы, он всё равно важен для безопасной и стабильной работы с памятью.

### **Вот как GIL работает:**

1. При запуске интерпретатора Python создается GIL. 
    
2. Когда создается поток, он действительно "знает" о существовании GIL, но не столько "связывается" с ним, сколько учитывает его в своей работе. Поток не всегда активно взаимодействует с GIL — это происходит только в моменты, когда он выполняет инструкции, изменяющие состояние Python-объектов.
    
3. Перед выполнением поток проверяет, не занят ли GIL другим потоком. Если GIL свободен, поток блокирует его для себя и начинает выполнение кода. Это предотвращает одновременное изменение объектов другими потоками.
    
4. Если GIL занят, поток ожидает его освобождения. Python использует механизмы планирования потоков операционной системы, а также внутреннюю логику для определения, когда потоку следует попытаться захватить GIL снова.
    
5. Во время выполнения поток действительно может освобождать GIL, особенно при операциях ввода-вывода или при использовании определенных функций, которые явно освобождают GIL (например, `time.sleep()`). Это позволяет другим потокам получить доступ к выполнению, улучшая отзывчивость программы при операциях, не требующих постоянного доступа к Python-объектам. 
    
6. После завершения своей работы поток освобождает GIL, позволяя другим потокам захватить его и продолжить выполнение.
    

### Взаимодействие Asyncio и GIL

В простых асинхронных приложениях с использованием asyncio все задачи выполняются внутри одного потока. Но при операциях ввода-вывода GIL освобождается. Именно этот факт использует asyncio, что позволяет внутри одного потока в момент ожидания переключаться с одной задачи на другую и реализовывать конкурентное выполнение задач. При этом asyncio полностью подчиняется GIL, так что при кажущемся параллелизме, задачи в асинхронном приложении выполняются по очереди, передавая управление друг другу при ожидании ответа на запрос. 

### Как обойти GIL?

Чтобы не сталкиваться с проблемой GIL, есть несколько трюков. Во-первых, можно попробовать многопроцессное программирование вместо того, чтобы работать с потоками. Это значит, что вы запускаете несколько процессов, и каждый из них работает на своём ядре процессора. Так вы сможете использовать все ресурсы компьютера на полную катушку.

Если вам нужно много считать, можно воспользоваться специальными библиотеками, например, NumPy или pandas. Они написаны с использованием языка C и могут обходить GIL, выполняя тяжёлые задачи в отдельных потоках или процессах, что ускоряет работу.


Несмотря на то, что `asyncio` в стандартном исполнении работает в одном потоке, тема GIL является очень важной для понимания многозадачности в Python. GIL является препятствием для параллельного программирования в Python, которое не так просто обойти. В данном уроке предлагаю более подробно рассмотреть принципы работы с GIL. 

Пока работа идет на одном ядре в одном процессе и в одном потоке (как в большинстве приложений `asyncio`) — все кажется понятным и логичным. Команды и данные попадают в стек, и их обработка происходит в соответствии с работой стека ([[LIFO]]: последний пришел — первый ушел). 

Напомню некоторые аспекты работы самого интерпретатора:

1. Любой объект в Python существует, пока существует хотя бы одна ссылка на него; если ссылок нет, то объект будет уничтожен.
2. На самом деле интерпретатор (вернее, его виртуальная машина) выполняет операции, которые не являются атомарными (неделимыми).  
     


Можем посмотреть, сколько всего содержит в себе простейшая функция по сложению двух чисел:

```
import dis


def sum_2(a, b):
    return a + b


dis.dis(sum_2)
```

Вывод: 

```
4           0 RESUME                   0

5           2 LOAD_FAST                0 (a)
            4 LOAD_FAST                1 (b)
            6 BINARY_OP                0 (+)
           10 RETURN_VALUE
```

Этот код использует модуль `dis` из стандартной библиотеки Python, который позволяет "дизассемблировать" байт-код, генерируемый Python для функций, методов классов и других объектов. Это полезно для понимания внутреннего представления функций и их выполнения.

Рассмотрим вывод дизассемблера для функции `sum_2()`:

- `4 0 RESUME 0`:
    - `4`: Это номер строки в исходном коде.
    - `0`: Это смещение инструкции (_или номер байта_) в байт-коде.
    - `RESUME 0`: Указывает на начало функции, которая не является ни генератором, ни coroutine, ни async-генератором.
- `5 2 LOAD_FAST 0 (a)`:
    - `5`: Номер строки в исходном коде.
    - `2`: Смещение инструкции.
    - `LOAD_FAST`: Инструкция, которая загружает значение из локальной переменной на вершину стека. В данном случае она загружает значение переменной `a`.
    - `0 (a)`: Операнд инструкции. Это индекс переменной a во внутреннем списке локальных переменных функции.
- `4 LOAD_FAST 1 (b)`:
    - Загрузка значения переменной `b` на вершину стека.
- `6 BINARY_OP 0 (+)`:
    - Выполнение бинарной операции (в данном случае - сложения) с двумя верхними значениями стека. Результатом будет новое значение, которое затем помещается на вершину стека.
- `10 RETURN_VALUE`:
    - Возвращает значение с вершины стека в качестве результата функции.


Теперь представим, что никакого контроля за потоками не существует, любой поток может вносить свои изменения в общие данные и принимать решения, нужны ли еще какие-то переменные или их можно отдать сборщику мусора. Во время работы данные изменяются самым непредсказуемым образом, переменные удаляются, возникают ошибки... думаю, что итог работы такой программы вряд ли будет соответствовать нашим ожиданиям.  
Как же все организовать и сделать так, чтобы таких проблем не возникало? Очевидно, что существует несколько возможных путей решения проблемы.

1. Тотальный контроль каждого такого потенциально "узкого" места, отдельная обработка каждой такой ситуации примитивами синхронизации с целью блокировки доступа на изменение каких-то определенных ресурсов. Только вот цена такого контроля может оказаться слишком высока, расходы на контроль могут превысить расходы на выполнение самой программы, многократно вырастает объем кода, сопровождать и вносить изменения в который — то еще удовольствие.  
     
2. Решение, которое используется в Python. Не городить суперсложный огород, а использовать единственную сущность, которая бы могла автоматически разрешать работу одновременно только одному потоку, используя несложный набор правил. Например: пусть первым начнет выполняться тот поток, который первым запросит такую возможность, работающий поток не блокирует "навсегда" работу других потоков, их выполнение должно чередоваться через какое-то время и так далее. Такое решение довольно изящно позволяет "увернуться" от множества сложностей, связанных с многопоточностью, сэкономить ресурсы, писать относительно простой код. Но как всегда есть но, и это - невозможность (по крайней мере на момент написания этого текста) по-настоящему параллельного выполнения потоков в CPython. Сколько бы потоков мы ни создали в своей программе, в любой конкретный момент времени будет выполняться только один из них!

**GIL** был введен, чтобы обеспечить безопасность потоков при работе с памятью. В Python объекты управляются сборщиком мусора, который автоматически освобождает память, когда объект больше не нужен. GIL предотвращает [состояние гонки](https://stepik.org/lesson/933669/step/1?unit=939568) и другие проблемы, связанные с многопоточностью, такие как повреждение структур данных или утечки памяти.

Ситуация с многопоточностью и GIL напоминает игру "Говорящая палка" (Talking Stick), в которой право говорить имеет только тот игрок, в чьих руках и находится палка. По истечении заранее установленного времени он должен передать ее другому игроку. Смысл игры в том, что в итоге каждый игрок получает возможность высказаться, когда приходит его очередь, и не должен мешать другим ораторам.   
  
Так же и с GIL, тот поток, который захватил эту сущность, будет выполняться, а остальные потоки — ждать, когда GIL будет освобожден, чтобы попытаться захватить его самим.

![](https://ucarecdn.com/9f7909bd-b803-4f78-8a84-f767ccf291aa/)

### Когда потоки могут переключаться.

1. CPython переключает потоки, основываясь на *интервале времени, который определяет длительность "квантов" времени, выделенных для выполнения каждого из потоков. Этот интервал может быть настроен и определяет, как часто интерпретатор Python будет проверять возможность переключения между потоками, чтобы обеспечить справедливое распределение процессорного времени.
2. Поток приступает к выполнению I/O операции.
3. Поток завершает свою работу

*_Интервал - это интервал времени, который служит рекомендацией для интерпретатора Python о том, как часто следует рассматривать возможность переключения контекста, однако конкретное решение о переключении потоков и выборе потока для выполнения принимается операционной системой. Операционная система управляет планированием потоков на основе своих алгоритмов и политик, что может привести к переключению потоков вне зависимости от установленного в Python интервала._ Проверить текущее значение интервала можно:

```
print(sys.getswitchinterval())  # По умолчанию 0.005 секунды
```

Второй пункт и объясняет различие во времени выполнения I/O и CPU bound задач.

При работе с потоками и наличии операций ввода-вывода (I/O), передача GIL (Global Interpreter Lock) происходит без учета ожидания "внешних" факторов, таких как операции ввода-вывода. Благодаря этому, происходит некоторая параллелизация работы.

![](https://ucarecdn.com/93983bf4-3715-44d3-a65e-99161f80fce2/)