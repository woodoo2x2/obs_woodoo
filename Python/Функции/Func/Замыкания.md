 Функции в качестве возвращаемых значений других функций

Объектная сущность функций позволяет и передавать их в качестве аргументов в другие функции, и возвращать одни функции из других. То есть, функции могут быть результатом работы других функций, что позволяет писать генераторы функций, возвращающие функции в зависимости от передаваемых им аргументов.

Рассмотрим код, где функция `generator()` возвращает функцию `hello()` в качестве результата своей работы.

```python
def generator():
    def hello():
        print('Hello from function!')
    return hello
```

Результат работы функции `generator()` можно записать в переменную, и использовать эту переменную как функцию.

Приведенный ниже код:

```python
func = generator()
func()
```

выводит:

```no-highlight
Hello from function!
```

 В Python можно определять функцию внутри функции, ведь функция это объект.

Приведенный выше пример не очень информативен, но идею можно использовать и для построения более мощных генераторов функций. Например, рассмотрим семейство функций — квадратных трехчленов. Все эти функции имеют один и тот же вид f(x)=ax2+bx+c, но поведение конкретного квадратного трехчлена зависит от значения параметров a,b,c. Мы можем написать генератор функций, который по параметрам a,b,c, построит и вернет нам конкретный квадратный трехчлен:

```python
def generator_square_polynom(a, b, c):
    def square_polynom(x):
        return a * x**2 + b * x + c

    return square_polynom
```

Приведенный ниже код:

```python
f = generator_square_polynom(a=1, b=2, c=1)
g = generator_square_polynom(a=2, b=0, c=-3)
h = generator_square_polynom(a=-3, b=-10, c=50)

print(f(1))
print(g(2))
print(h(-1))
```

выводит:

```no-highlight
4
5
57
```

Другими словами мы построили функции f(x)=x2+2x+1, g(x)=2x2−3, h(x)=−3x2−10x+50

Обратите внимание на то, что внутренняя функция `square_polynom()` использует параметры внешней функции `generator_square_polynom()`. Такую вложенную функцию называют **замыканием**.

Замыкания – вложенные функции, ссылающиеся на переменные, объявленные вне определения этой функции, и не являющиеся её параметрами.

Замыкания

Вложенные функции могут захватывать и переносить с собой часть состояния родительской функции.

Перепишем немного функцию `get_speak_func()`, чтобы новая версия сразу принимала два аргумента `volume` и `text`:

```python
def get_speak_func(text, volume):
    def whisper():
        return text.lower() + '...'
    def yell():
        return text.upper() + '!'
    
    if volume > 0.5:
        return yell
    else:
        return whisper
```

Приведенный ниже код:

```python
yell = get_speak_func('Hello, World', 0.7)

print(yell())
```

выводит:

```no-highlight
HELLO, WORLD!
```

Теперь вложенные функции `whisper()` и `yell()` не имеют параметра `text`. Они его получают и используют через родительскую функцию `get_speak_func()`. Функции, которые делают это, называются **замыканиями**. Замыкание запоминает значения из включающей его области, даже если поток программы больше не находится в этой области.

Таким образом, **замыкание** — это особый вид функции. Она определена в теле другой функции и создаётся каждый раз во время её выполнения. Синтаксически это выглядит как функция, находящаяся целиком в теле другой функции. При этом вложенная функция содержит ссылки на локальные переменные внешней функции. Каждый раз при выполнении внешней функции происходит создание нового экземпляра внутренней функции, с новыми ссылками на переменные внешней функции.

```
def closure():
    count = 0
    def inner():
        nonlocal count
        count += 1
        print(count)
    return inner

start = closure()
another = closure()             # другое замыкание, со своими локальными значениями

start()                         # выводит 1
start()                         # выводит 2

another()                       # выводит 1

start()                         # выводит 3
```

Замыкания очень полезны при решении многих задач. С их помощью функции могут не только возвращать поведение, но и предварительно настраивать это поведение.

Рассмотрим несколько примеров, в которых используются замыкания.

**Пример 1**. В этом примере функция `greeting_creator()` служит фабрикой для создания и настройки функции приветствия. Обратите внимание на то, что вложенная функция `greet()` может обращаться к аргументу `greeting_word` своей родительской функции `greeting_creator()`.

```python
def greeting_creator(greeting_word):
    def greet(name):
        return f'{greeting_word}, {name}'

    return greet
```

Приведенный ниже код:

```python
say_hi = greeting_creator('Hi')
say_hello = greeting_creator('Hello')

print(say_hi('Timur'))
print(say_hello('Soslan'))
```

выводит:

```no-highlight
Hi, Timur
Hello, Soslan
```

**Пример 2.** В этом примере функции `make_adder()` и `multiplier_of()` служат фабриками для создания и настройки функций «сумматора» и «мультипликатора». Обратите внимание на то, что вложенные функции `add()` и `mult()` могут обращаться к аргументу `n` своих родительских функций `make_adder()` и `multiplier_of()`.

```python
def make_adder(n):
    def add(x):
        return x + n
    return add

def multiplier_of(n):
    def mult(x):
        return x * n
    return mult
```

Приведенный ниже код:

```python
plus_3 = make_adder(3)
plus_5 = make_adder(5)
multiply_3 = multiplier_of(3)
multiply_5 = multiplier_of(5)

print(plus_3(10), plus_3(100))
print(plus_5(10), plus_5(100))
print(multiply_3(10), multiply_3(100))
print(multiply_5(10), multiply_5(100))
```

выводит:

```no-highlight
13 103
15 105
30 300
50 500
```

Имейте в виду, что вложенные функции, которые возвращает родительская функция, могут быть анонимными. Приведенный выше код можно переписать в виде:

```python
def make_adder(n):
    return lambda x: x + n

def multiplier_of(n):
    return lambda x: x * n
```

**Пример 3.** В этом примере функция `line_generator()` служит фабрикой для создания и настройки линейной функции вида y=kx+by=kx+b. Обратите внимание на то, что вложенная функция `func()` может обращаться к аргументам `k` и `b` своей родительской функции `line_generator()`.

```python
def line_generator(k, b):
    def func(x):
        return k * x + b
    return func
```

Приведенный ниже код:

```python
line_func_1 = line_generator(2, 5)        # получаем функцию y = 2*x + 5
line_func_2 = line_generator(-6, 9)       # получаем функцию y = -6*x + 9

print(line_func_1(10))                    # печатаем значение 2*10 + 5
print(line_func_2(4))                     # печатаем значение -6*4 + 9
```

выводит:

```no-highlight
25
-15
```

Обратите внимание на то, что во всех предыдущих примерах наши вложенные функции (замыкания) использовали **нелокальные переменные**, которые являлись параметрическими для родительской функции. Вложенные функции могут обращаться ко всем локальным переменным родительской функции, независимо от того, были они определены во внешней функции или пришли из аргументов внешней функции.

 Параметрические переменные тоже считаются [[Область видимости локальных и глобальных переменных|локальными переменными]].

Приведенный ниже код:

```python
def f(x):
    z = 2
    def g(y):
        return z*x + y    # обращение к нелокальной переменной z и параметрической переменной x
    return g

h = f(5)
print(h(1))
```

выводит:

```no-highlight
11
```

Когда использовать замыкания

Концепция замыканий, то есть функций, захватывающих нелокальные переменные, находят много применений при написании кода. Замыкания хороши для:

- воздержания от жестко закодированных констант
- воздержания от использования глобальных переменных
- воздержания от создания ненужных типов данных (классов)
- замыкания нужны для реализации декораторов, о которых мы поговорим чуть позже

Сокрытие данных основное преимущество замыканий.


 Вложенные (внутренние) функции позволяют избавиться от глобальных переменных. Такая техника позволяет сделать внешнюю для функции переменную, но при этом спрятанную от посторонних глаз, в отличие от глобальной. Такие переменные нужны в первую очередь для того, чтобы хранить какие-то данные, относящиеся к функции, между вызовами функции. Локальные переменные стираются при выходе из функции, глобальные — сохраняются, но видны всему свету, а нелокальные — идеальное сочетание закрытости и «сохраняемости».

Если функция использует глобальные переменные, это тоже замыкание. Но чаще всего замыканием называют все-таки функцию, которая использует нелокальные переменные. Такая функция как бы «таскает за собой» свои внешние переменные, но никому их не показывает.


## От простого к сложному

Замыкание (closure) или фабричная функция это функция определяемая и возвращаемая другой функцией, при этом замыкание получает доступ к значениям и объектам в области видимости "родительской" (или объемлющей) функции независимо от того из какой области видимости происходит вызов замыкания.

```py
def outers():   
    n = 2  
  
    def closure():   
        return n ** 2   
return closure  
  
  
closure_foo = outers()      # Вызываем внешнюю функцию, возвращаемая функция (замыкание) присваивается переменной

print(closure_foo)          # <function outers.<locals>.closure at 0x7f254d6fe170> 

num = closure_foo()         # Вызываем замыкание, результат присваивается переменной 

print(num)                  # 4   


# Второй вариант вызова замыкания 
print(outers()())           # 4
```


На примере видно, что функция `closure` имеет доступ к переменной `n` определенной в родительской функции, несмотря на то, что интерпретатор уже не находится в соответствующей зоне видимости.

Второй вариант вызова замыкания не сложно понять, если проследить эволюцию значений:

![](https://habrastorage.org/getpro/habr/upload_files/f40/880/a20/f40880a2078460e0375e66b4521765da.gif)

Скобки после имени функции говорят интерпретатору о том, что ее необходимо вызвать. После вызова `outers()`, на ее место возвращается замыкание `closure`, к которому добавляется оставшаяся пара скобок. Замыкание вызывается, возвращая на свое место результат.


Важной особенностью замыканий является тот факт, что они имеют доступ к самим объектам из области видимости родительской функции, а не к их копиям или состояниям существующим на момент определения замыкания.

```py
def outers(lst):  
  
    def closure():  
        return lst[0] * 2  
    return closure  
  
  
x = ['a']  
closure_foo = outers(x)    # Вызываем внешнюю функцию, передав ей список в качестве аргумента  
print(closure_foo())       # aa  
  
x[0] = 'b'                 # меняем единственный элемент списка  
print(closure_foo())       # bb
```

В указанном примере содержимое списка `x` меняется после определения замыкания, однако результат вызова замыкания показывает, что ему доступно актуальное содержимое списка.

Однако важно понимать и другую особенность, замыкание "запоминает" именно те объекты и значения, что были доступны родительской функции в момент его определения, что позволяет использовать сразу несколько экземпляров замыканий, отличных друг от друга.

```py
 
def multiplier(factor):  
  
    def closure(x):  
        return factor * x  
    return closure  
  
  
double = multiplier(2)  
triple = multiplier(3)  
  
print(double(5))  # 10 результат аналогичен вызову multiplier(2)(5) 

print(triple(4))  # 12 результат аналогичен вызову multiplier(3)(4)
```

В данном примере механизм замыканий используется для определения нескольких схожих функций (double и triple), что позволяет избежать дублирования кода. Кроме того, этот пример призван продемонстрировать, что разные экземпляры одного замыкания будут иметь доступ к разным значениям из области видимости родительской функции.

Так же для создания замыкания может использоваться анонимная функция.
```py

def modify(foo):  
    return lambda x: foo(x)  
  
  
"""  
# результат аналогичен обычному синтаксису  
def modify(foo):  
  
    def closure(x):        return foo(x)    return closure"""  
  
  
to_str = modify(str)  
to_str(152)              # '152'  
to_bool = modify(bool)  
to_bool('John Cena')     # True  
to_bool('')              # False  
adder = modify(lambda x: x + 1)  
adder(152)               # 153
```

В данном примере функции `modify` передаются различные функции (в том числе анонимные). Полученное замыкание возвращает результат применения функции к своему аргументу.

## Почти настоящий код

Замыкания способны изменять значения и объекты из области видимости родительской функции, для этого используется оператор `nonlocal`.

```py
def count_calls():  
    counter = 0  
  
    def closure(print_result=False):  
        nonlocal counter  
        if print_result:  
            return counter  
        counter += 1  
        return counter  
    return closure  
  
  
counter = count_calls()     # Вызвав функцию, получаем счетчик (замыкание)  
  
for _ in range(5):  
    counter()               # Вызываем счетчик  
  
print(counter(True))        # Проверяем результат подсчета: 5  
  
for _ in range(2):  
    counter()  
  
print(counter(1))           # 7

```

В данном примере, с использованием замыкания создается счетчик, с помощью которого можно отслеживать, например, количество вызовов некоторой функции. В примере счетчик был 5 раз вызван в первом цикле и два раза во втором. Для проверки результата подсчета функции нужно передать соответствующий аргумент и тогда данный вызов не будет учитываться при подсчете результата. Для «обнуления» счетчика необходимо получить новый экземпляр замыкания, вызвав внешнюю функцию. Одновременно можно использовать сразу несколько счетчиков.

П
  


## Вместо вывода

В своей книге Марк Лутц пишет: «Разумеется, наилучшая рекомендация для большей части кода заключается в том, чтобы избегать вложения операторов def внутрь def, т.к. тогда программа станет гораздо проще — согласно духу Python плоский код, как правило, лучше вложенного». Однако важно отметить, что существует множество ситуаций, в которых от использования замыканий отказаться нельзя, так как их применение является оптимальным и предпочтительным решением. Понимание механизмов их работы является ключевым для освоения более сложных концепций, таких как [[Декораторы]]


