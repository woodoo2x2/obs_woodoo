
Раньше на Python писали в основном небольшие скрипты, но в последнее время язык стал значительно популярнее и сегодня на Python написано много сложных систем из сотен тысяч строк кода. В таких обстоятельствах документирующее свойство системы типов становится очень полезным. В достаточно крупной кодовой базе при отсутствии информации о типах очень сложно угадать, какие именно объекты используются в программе.

По этим соображениям, в Python 3.5 появились **аннотации типов**, которые представляют собой специальный синтаксис для объявления типов параметров функций и их возвращаемых значений ([PEP 484](https://www.python.org/dev/peps/pep-0484/)). В Python 3.6 эта возможность была расширена — стало можно объявлять типы переменных вообще в любом месте программы ([PEP 526](https://www.python.org/dev/peps/pep-0526/)). С каждой новой версией языка эта функциональность улучшается, и писать аннотации типов становится всё проще, удобнее и естественнее.

Нужно отметить, что аннотации типов — это именно возможность, а не обязанность. У программиста есть выбор — добавлять информацию о типах или нет. Таким образом Python пытается усидеть на двух стульях — остаться языком с динамической типизацией и дать возможность для статического анализа написанных программ.

Программист при написании кода расставляет информацию о типах переменных, параметров и возвращаемых значений функций. Это никак не влияет на выполнение программы. Python сам по себе никак не использует эту информацию, он лишь перекладывает её в специальные атрибуты функций или переменных, делая доступной для сторонних утилит. То есть, если указано, что функция принимает строковый аргумент, то это никак не помешает вызвать её с целым числом или списком — в зависимости от тела функции, она может отработать, а может завершиться ошибкой, но сама возможность вызова с любыми типами аргументов никак не ограничивается.

### Простые типы

Рассмотрим определение функции `greet()`, которая по задумке принимает строковый аргумент `name` и возвращает строковое значение приветствия:

```python
def greet(name):
    return f'Hello {name}!'
```

С помощью аннотаций типов можем переписать функцию в виде:

```python
def greet(name: str) -> str:
    return f'Hello {name}!'
```

Как мы видим, типы параметров, записываются после имени параметра через знак двоеточия, а тип возвращаемого значения функции записывается после знака "стрелки". Теперь программист просто взглянув на сигнатуру функции может понять, что функция принимает строку и возвращает строку. При этом можно понять, что если передать в неё другой тип, то она не сможет корректно отработать.

Если некоторый аргумент имеет значение по умолчанию, то его тип должен предшествовать значению по умолчанию:

```python
def greet(name: str = 'world') -> str:
    return f'Hello, {name}!'
```

Точно так же можно использовать и любые другие базовые (не являющиеся коллекциями) типы в Python:  [[Тип данных int]],  [[Тип данных float]],  [[Тип данных bool]],  [[Тип данных str]],  [[None (NoneType)]].

Приведем несколько примеров.

**Пример 1.** Функция `print_hello()` принимает два аргумента типа `str` и `bool` и возвращает значение `None`.

```python
def print_hello(name: str, upper: bool = False) -> None:
    if upper:
        name = name.upper()
    print(f'Hello, {name}')
```

**Пример 2.** Функция `avg()` принимает три аргумента типа `int` и возвращает значение `float`:

```python
def avg(num1: int, num2: int, num3: int) -> float:
    return (num1 + num2 + num3) / 3
```

Как уже было сказано выше, помимо специального синтаксиса для объявления параметров функций и их возвращаемых значений в Python 3.6 стало можно объявлять типы переменных вообще в любом месте программы.

Вот так можно добавить аннотации типов к переменным в любом месте кода (Python 3.6+):

```python
name: str = 'Timur'
age: int = 29
height: float = 171.5
is_married: bool = False
```

Можно также аннотировать переменные, не назначая им сразу значения:

```python
surname: str
gender: bool
```

### Типы коллекции

Перейдем к более сложным типам, таким как списки, кортежи, словари и множества. Можно добавлять аннотации типов, используя сами имена классов [[Тип данных list]], [[Тип данных tuple]], [[Тип данных set]], [[Тип данных dict]]:

```python
def sum_square(nums: list) -> int:
    total = 0
    for i in nums:
        total += i ** 2
    return total
```

Это не слишком информативно, потому что кроме самого типа `list` было бы ещё полезно знать, какие данные он в себе содержит. В нашем примере непонятно, списком каких типов является параметр `nums`.

В приведенном ниже коде:

```python
numbers: list
person: tuple
prices: dict
answers: set
```

также неизвестно, какие данные должны храниться в коллекциях `numbers`, `person`, `prices` и `answers`.

В Python до версии 3.9 для этого придётся использовать отдельные типы из модуля `typing`. Делается это при помощи квадратных скобок:

```python
from typing import List

def sum_square(nums: List[int]) -> int:
    total = 0
    for i in nums:
        total += i ** 2
    return total
```

или 

```python
from typing import List, Tuple, Dict, Set

numbers: List[int]                                # тип всех элементов списка
person: Tuple[str, int, bool]                     # тип каждого элемента кортежа
prices: Dict[str, int]                            # тип ключей, тип значений
answers: Set[float]                               # тип всех элементов множества
```

 Обратите внимание на то, что типы из [[Модуль Typing]] указываются с заглавной буквы.

Начиная с Python 3.9 можно использовать стандартные классы в точно таких же целях, ничего ниоткуда не импортируя:

```python
numbers: list[int]                                # тип всех элементов списка
person: tuple[str, int, bool]                     # тип каждого элемента кортежа
prices: dict[str, int]                            # тип ключей, тип значений
answers: set[float]                               # тип всех элементов множества
```





