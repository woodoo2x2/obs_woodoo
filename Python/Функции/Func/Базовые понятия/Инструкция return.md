Использование инструкции `return` по максимуму

Взглянем еще раз на функцию `convert_to_celsius()`:

```python
def convert_to_celsius(temp):
    result = (5 / 9) * (temp - 32)
    return result
```

Обратите внимание, что внутри этой функции происходят две вещи: во-первых, переменной `result` присваивается значение выражения `(5 / 9) * (temp - 32)`, и во-вторых, значение переменной `result` возвращается из функции. Эта функция хорошо справляется с поставленной перед ней задачей, но ее можно упростить. Поскольку инструкция `return` возвращает значение выражения, переменную `result` устраняем и переписываем функцию так:

```python
def convert_to_celsius(temp):
    return (5 / 9) * (temp - 32)
```

Эта версия функции не сохраняет значение `(5 / 9) * (temp - 32)` в отдельной переменной, а сразу возвращает значение выражения с помощью инструкции `return`. Делает то же, что и предыдущая версия, но за один шаг.

## Использование нескольких return

В одной функции может быть сколько угодно инструкций `return`. Рассмотрим функцию `convert_grade()`, которая переводит стобалльную оценку в пятибалльную:

```python
def convert_grade(grade):
    if grade >= 90:
        return 5
    elif grade >= 80:
        return 4
    elif grade >= 70: 
        return 3
    elif grade >= 60:
        return 2
    else:
        return 1

# основная программа
grade = int(input('Введите вашу отметку по 100-балльной системе: '))
print(convert_grade(grade))
```

В функции `convert_grade()` используется 5 инструкций `return`. Каждая из них возвращает соответствующее значение и завершает работу функции.

Функцию `convert_grade()` можно переписать с помощью одной инструкции `return`:

```python
def convert_grade(grade):
    if grade >= 90:
        result = 5
    elif grade >= 80:
        result = 4
    elif grade >= 70: 
        result = 3
    elif grade >= 60:
        result = 2
    else:
        result = 1
    
    return result
```

## Возвращение True False
Python позволяет писать [[Булева Функция]], возвращающие либо истину (`True`), либо ложь (`False`). Булеву функцию можно применять для проверки условия, тогда значения True и False будут сигнализировать о его выполнении.

Булевы функции широко применяются для упрощения сложных условий, проверяемых в структурах принятия решения и структурах с повторением.  
Например, напишем программу, которая просит пользователя ввести число и определяет, четное оно или нечетное.

Это можно сделать так:

```python
number = int(input())
if number % 2 == 0:
    print('Это число четное. ')
else:
    print('Это число нечетное.')
```

Этот фрагмент кода будет легче понять, если написать булеву функцию `is_even()`, которая принимает число в качестве аргумента и возвращает `True`, если оно четное, и `False` если нечетное.

```python
def is_even(number):
    if number % 2 == 0:
        return True
    else:
        return False
```

Теперь можно переписать инструкцию `if-else` основной программы так, чтобы она для определения четности переменной `number` вызывала функцию `is_even()`:

```python
number = int(input())
if is_even(number):
    print('Это число четное. ')
else:
    print('Это число нечетное.')
```

Так логику программы легче понять, а функцию можно вызывать в программе всякий раз, когда необходимо проверить четность числа.

 Использование булевых функций для валидации входных данных

Булевы функции можно также использовать для _**упрощения сложного кода валидации входных данных**_. Например в программе, предлагающей пользователю ввести номер модели изделия, где возможны только значения 100, 200 или 300, можем написать такой код:

```python
model = int(input())

while model != 100 and model != 200 and model != 300:
    print('Допустимыми номерами моделей являются 100, 200 или 300.')
    model = int(input())
```

Цикл валидации использует длинное составное булево выражение, и повторяется до тех пор, пока `model` не будет равняться 100100, 200200 или 300300. 

Вместе с тем, цикл валидации можно упростить, написав булеву функцию проверки переменной `model` и вызывая ее в цикле. Напишем функцию `is_invalid()`, которая принимает один параметр `model` и возвращает значение `True`, если модель недопустима и `False` в противном случае. Тогда цикл валидации можно переписать следующим образом:

```python
while is_invalid(model):
    print('Допустимыми номерами моделей являются 100, 200 и 300.')
    model = int(input())
```

После этого изменения цикл становится легче читать. Теперь вполне очевидно, что цикл повторяется до тех пор, пока номер модели недопустим. Приведенный ниже фрагмент кода показывает, как можно было бы написать функцию `is_invalid()`. Она принимает номер модели в качестве аргумента, и если аргумент не равен 100100, 200200 или 300300, то эта функция возвращает `True`, говоря, что он недопустимый. В противном случае функция возвращает `False`.

```python
def is_invalid(model):
    if model != 100 and model != 200 and model != 300:
        return True
    else:
        return False
```

Создание функций, реализующих такую простую логику, — не всегда оптимальное решение, так как увеличивает размер кода и ведет к затратам времени на вызов функции и возврат обратно результата, что может сказаться негативно на производительности программы.

## Функции с возвратом нескольких значений

В Python функции не ограничены возвратом всего одного значения. После инструкции `return` можно определить много выражений, разделенных запятыми:

```python
return выражение 1, выражение 2, выражение 3 ...
```

Следующий программный код определяет функцию `get_powers(num)`, которая принимает в качестве аргумента число `num` и возвращает его квадрат, куб и четвертую степень.

```python
def get_powers(num):
    return num**2, num**3, num**4
```

Результатом выполнения следующего кода:

```python
a, b, c = get_powers(2)
print(a)
print(b)
print(c)
```

будет:

```python
4
8
16
```

Возвращающие несколько значений функции – исключительная особенность языка Python. В большинстве языков программирования для возврата нескольких значений используется результирующий тип данных – список, который может содержать несколько значений.

Рассмотрим еще один пример. Пусть требуется написать функцию, которая находит точку пересечения двух **непараллельных** прямых ax+by=e и cx+dy=f Другими словами требуется решить систему уравнений:

ax+by=e
cx+dy=f​

Программный код, решающий задачу, имеет вид:

```python
def solve(a, b, c, d, e, f):
    x = (d * e - b * f)/(a * d - b * c)
    y = (a * f - c * e)/(a * d - b * c)
    return x, y
```

Следующий код:

```python
xsol, ysol = solve(2, 3, 4, 1, 2, 5)
print('Решением системы являются числа', 'x =', xsol, 'y =', ysol)
```

выведет

```no-highlight
Решением системы являются числа x = 1.3 y = -0.2
```

![](https://ucarecdn.com/053e7fe8-b707-411a-bc45-080ba285db42/)