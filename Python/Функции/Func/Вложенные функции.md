

Python позволяет определять функции внутри других функций. Их называют вложенными функциями или внутренними функциями.

Приведенный ниже код:

```python
def speak(text):
    def whisper(t):                      # объявляем вложенную функцию
        return t.lower() + '...'
    return whisper(text)                 # вызываем вложенную функцию и возвращаем ее результат

print(speak('Hello, World'))         
```

определяет вложенную функцию `whisper()` внутри функции `speak()` и выводит:

```no-highlight
hello, world...
```

Каждый раз, когда мы вызываем функцию `speak()`, она определяет новую внутреннюю функцию `whisper()`, а затем вызывает ее. При этом функция `whisper()` не существует вне родительской функции `speak()`.

Приведенный ниже код:

```python
whisper('Hello')
```

приводит к возникновению ошибки:

```python
NameError: name 'whisper' is not defined
```

Ровно как и приведенный ниже код:

```python
speak.whisper('Hello')
```

приводит к возникновению ошибки:

```python
AttributeError: 'function' object has no attribute 'whisper'
```

Если нам нужно получить доступ к вложенной функции `whisper()` извне, то мы можем вернуть ее (вложенную функцию) вызывающей стороне родительской функции.

Функция высшего порядка `get_speak_func()` определяет две вложенные функции `whisper()` и `yell()`. В зависимости от аргумента `volume`, переданного родительской функции `get_speak_func()`, она выбирает и возвращает вызывающей стороне одну из вложенных функций:

```python
def get_speak_func(volume):
    def whisper(text):
        return text.lower() + '...'
    def yell(text):
        return text.upper() + '!'

    if volume > 0.5:
        return yell
    else:
        return whisper
```

  [[Функции высшего порядка]] – это функции, которые принимают и/или возвращают другие функции.

Обратите внимание на то, что функция `get_speak_func()` на самом деле не вызывает одну из своих вложенных функций — она просто выбирает подходящую функцию на основе аргумента `volume`, а затем возвращает объект этой функции.

Приведенный ниже код:

```python
whisper = get_speak_func(0.3)     # функция whisper()
yell = get_speak_func(0.7)        # функция yell()

print(whisper('Hello'))           # говорим шепотом
print(yell('Hello'))              # кричим
```

выводит:

```python
hello...
HELLO!
```

Таким образом, функции не только могут принимать поведение через аргументы, но также могут возвращать поведение.



## Нелокальные переменные

При поиске переменной с указанным именем приоритет (правило разрешения имен) следующий:

1. сначала ищем локальную переменную
2. если не нашли локальную, ищем нелокальную
3. если не нашли нелокальную, ищем глобальную
4. и в самом конце — встроенную в язык

Промежуточная область видимости, которая доступна вложенным функциям, называется **нелокальной**. Если вложенность функций больше двух уровней, нелокальная переменная ищет в «ближайшей» области видимости, т. е. в функции вложенностью на один меньше. Если не находит, поиск переходит в самую ближнюю из внешних областей видимости, затем в чуть более далекую — и так далее, пока не найдется нужное имя. Фактически интерпретатор ищет там, «где поближе».

## Ключевое слово nonlocal

Как мы уже знаем, вложенная функция видит переменные в родительской функции, которые называются нелокальными или свободными переменными.

Рассмотрим следующий код:

```python
def outer_function():
    num = 5
    def inner_function():      # определяем вложенную функцию
        num += 10
        print(num)
    inner_function()           # вызываем вложенную функцию
        
outer_function()
```

Такой код приводит к возникновению ошибки:

```no-highlight
UnboundLocalError: local variable 'num' referenced before assignment
```

Дело в том, что вложенная функция не просто обращается (получает значение) к переменной `num`, но и пытается его изменить! Внутренняя функция видит переменные в объемлющей функции, но, если она хочет такую переменную изменить, должна объявить ее `nonlocal`.

Приведенный ниже код:

```python
def outer_function():
    num = 5
    def inner_function():      # определяем вложенную функцию
        nonlocal num
        num += 10
        print(num)
    inner_function()           # вызываем вложенную функцию
        
outer_function()
```

выводит значение:

```no-highlight
15
```


