

Способ, который декорирует функцию `say()`, — многословен, приходится набирать имя функции несколько раз. Кроме того, декорирование скрывается под определением функции. Вместо этого Python позволяет использовать декораторы более простым способом с помощью символа `@`.


Приведенный ниже код:

```python
def null_decorator(func):
    return func

def say():
    print('Привет Мир!')

say = null_decorator(say)            # декорируем функцию

say()
```

можно переписать в виде:

```python
def null_decorator(func):
    return func

@null_decorator                      # декорируем функцию
def say():
    print('Привет Мир!')

say()
```

Приведенный ниже код:

```python
def sample_decorator(func):          # определяем декоратор
    def wrapper():
        print('Начало функции')
        func()
        print('Конец функции')
    return wrapper

def say():
    print('Привет Мир!')

say = sample_decorator(say)          # декорируем функцию

say()                                # вызываем декорированную функцию
```

можно переписать в виде:

```python
def sample_decorator(func):          # определяем декоратор
    def wrapper():
        print('Начало функции')
        func()
        print('Конец функции')
    return wrapper

@sample_decorator                    # декорируем функцию
def say():
    print('Привет Мир!')

say()
```

Просто добавив `@sample_decorator` перед определением функции `say()`, мы модифицировали её поведение. Однако, как вы уже могли догадаться, запись с `@` является всего лишь синтаксическим сахаромдля записи:

```python
say = sample_decorator(say)
```

Иными словами, выражение `@sample_decorator` вызывает функцию `sample_decorator()` с `say` в качестве аргумента и присваивает имени `say` возвращаемую функцию.

Обратите внимание, что использование синтаксиса `@` декорирует функцию сразу во время определения. Это затрудняет доступ к недекорированной функции. Поэтому мы можем декорировать некоторые функции вручную, чтобы сохранить возможность вызывать и недекорированную версию функции.
