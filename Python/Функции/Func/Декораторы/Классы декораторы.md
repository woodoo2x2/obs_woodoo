## Декорирование методов

Есть два способа использования декораторов в классах, первым из которых является декорирование методов. С ним мы уже сталкивались, например, когда изучали статические методы и методы класса, которые реализуются с помощью декораторов [[Декоратор @staticmethod]] и [[Декоратор @classmethod]] соответственно.

К методам в классе мы также можем применять и собственные декораторы. Рассмотрим класс `Cat`, описывающий кошку, и задекорируем один из его методов приведенным выше декоратором `@do_n_times`.

Приведенный ниже код:

```python
import functools

def do_n_times(n):
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            for _ in range(n):
                value = func(*args, **kwargs)
            return value
        return wrapper
    return decorator

class Cat:
    @do_n_times(4)
    def say(self):
        print('Мяу')


cat = Cat()

cat.say()
```

выводит:

```no-highlight
Мяу
Мяу
Мяу
Мяу
```

Вторым способом использования декораторов в классах является **декорирование всего класса**, но о нем мы поговорим позже.

## Классы декораторы

В общем случае декоратор представляет собой функцию, которая принимает в качестве аргумента функцию и возвращает новую функцию, которая заменяет переданную. Однако декоратор может возвращать не только функцию, но и вызываемый объект, который аналогичным образом способен заменить декорируемую функцию. Данный подход позволяет нам реализовывать декораторы не только с помощью функций, но и с помощью классов, экземпляры которых являются вызываемыми объектами, то есть содержат магический метод `__call__()`.

Рассмотрим класс декоратор `@do_twice`, выполняющий вызов декорируемой функции дважды.

Приведенный ниже код:

```python
class do_twice:
    def __init__(self, func):
        self.func = func                            # декорируемая функция
        
    def __call__(self, *args, **kwargs):
        for _ in range(2):
            value = self.func(*args, **kwargs)      # вызов декорируемой функции
        return value

def greet(name):
    print(f'Привет, {name}!')


greet = do_twice(greet)

greet('Кемаль')
```

выводит:

```no-highlight
Привет, Кемаль!
Привет, Кемаль!
```

Класс `do_twice` имеет два метода `__init__()` и `__call__()`. Первый метод принимает в качестве аргумента декорируемую функцию и закрепляет ее за экземпляром класса `do_twice` в виде атрибута `func`. Второй метод делает экземпляр класса `do_twice` вызываемым объектом.

Таким образом, вызов `do_twice(greet)` возвращает экземпляр класса `do_twice`, который:

- внутренне хранит функцию `greet()` в виде атрибута `func`
- является вызываемым объектом и при вызове себя вызывает сохраненную функцию `greet()`

В итоге использование класса в качестве декоратора отличается лишь тем, что вместо вызова функции и получения функции, мы вызываем класс и получаем его экземпляр, который является вызываемым объектом.

Использование классов декораторов может быть выгодно тем, что они избавляют от тройной последовательной вложенности функций и делают код более простым для понимания.

Стоит отметить, что заменив функцию `greet()` на экземпляр класса `do_twice`, мы потеряли всю информацию о ней. Для сохранения информации о декорируемой функции нам необходимо воспользоваться функцией `update_wrapper()` из [[Модуль functools]].

Приведенный ниже код:

```python
import functools

class do_twice:
    def __init__(self, func):
        functools.update_wrapper(self, func)        # сохранение информации о декорируемой функции
        self.func = func
        
    def __call__(self, *args, **kwargs):
        for _ in range(2):
            value = self.func(*args, **kwargs)
        return value

@do_twice
def greet(name):
    """docstring"""
    print(f'Привет, {name}!')


print(greet.__name__)
print(greet.__doc__)
```

выводит:

```no-highlight
greet
docstring
```

Обратите внимание, что для сохранения информации о декорируемой функции нужно использовать функцию `update_wrapper()` модуля `functools`, вместо декоратора `@wraps`.

Класс декоратор также может выступать в качестве декоратора с аргументами. Рассмотрим класс декоратор `@do_n_times`, выполняющий вызов декорируемой функции `n` раз.

Приведенный ниже код:

```python
import functools

class do_n_times:
    def __init__(self, n):
        self.n = n
        
    def __call__(self, func):                       # передача декорируемой функции
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            for _ in range(self.n):
                value = func(*args, **kwargs)       # вызов декорируемой функции
            return value
        return wrapper

def greet(name):
    print(f'Привет, {name}!')


decorator = do_n_times(4)                           # создание экземпляра класса do_n_times
greet = decorator(greet)                            # вызов экземпляра класса do_n_times

greet('Кемаль')
```

выводит:

```no-highlight
Привет, Кемаль!
Привет, Кемаль!
Привет, Кемаль!
Привет, Кемаль!
```

Здесь в метод [[Магический метод __init__()|__init__()]] уже передается не декорируемая функция, а число `n` — количество вызовов декорируемой функции. Сам экземпляр класса `do_n_times` также не является объектом, заменяющим декорируемую функцию, он является фактическим декоратором, так как при вызове себя принимает в качестве аргумента декорируемую функцию `func` и возвращает функцию `wrapper()`, которая и заменяет переданную.

Таким образом, вызов `do_n_times(4)` возвращает экземпляр класса `do_n_times`, который внутренне хранит лишь число `4` в виде атрибута `n`. Однако этот экземпляр класса `do_n_times` является вызываемым объектом, который принимает в качестве аргумента декорируемую функцию `greet()` и возвращает функцию `wrapper()`, которая, в свою очередь, внутренне хранит число `4` и функцию `greet()`, а также эту функцию `greet()` заменяет.

Используя синтаксис декораторов, приведенный выше код можно записать в более короткой форме:

```python
import functools

class do_n_times:
    def __init__(self, n):
        self.n = n
        
    def __call__(self, func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            for _ in range(self.n):
                value = func(*args, **kwargs)
            return value
        return wrapper

@do_n_times(4)
def greet(name):
    print(f'Привет, {name}!')


greet('Кемаль')
```

который так же выводит:

```no-highlight
Привет, Кемаль!
Привет, Кемаль!
Привет, Кемаль!
Привет, Кемаль!
```



 Глубокие уровни наложения декораторов в итоге могут повлиять на производительность, поскольку они продолжают добавлять вложенные вызовы функций. Обычно на практике это не создает проблем, но об этом следует помнить, если вы работаете с кодом, требующим высокой производительности.

