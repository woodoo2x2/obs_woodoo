Определение декоратора

Иногда нам нужно модифицировать существующую функцию, не меняя при этом ее исходный код.

**Декоратор** — это функция, которая принимает другую функцию, расширяет ее поведение, не изменяя ее явно, и возвращает новую функцию.

Прежде чем понять, как работают декораторы, и начать создавать их, вспомним, некоторые важные особенности функций:

- функции являются объектами первого класса, то есть функции можно передавать и использовать в качестве аргументов;
- функции можно определять внутри других функций;
- вложенные функции могут использовать локальные переменные родительских функций;
- функции могут возвращать другие функции в качестве результата.

Теперь, владея этими знаниями, создадим простой декоратор `null_decorator()`, который возвращает исходную функцию без каких-либо изменений:

```python
def null_decorator(func):
    return func
```

Как мы видим, `null_decorator()` — это функция высшего порядка, которая принимает другую функцию в качестве аргумента и возвращает эту же функцию, не изменяя ее.

Применим данный декоратор для декорирования функции `say()`.

Приведенный ниже код:

```python
def say():
    print('Привет Мир!')

say = null_decorator(say)      # декорируем функцию

say()                          # вызываем декорированную функцию
```

выводит:

```no-highlight
Привет Мир!
```

Приведенный выше `null_decorator()` пока что не выглядит особо полезным, однако можно написать более интересный декоратор, который меняет поведение декорируемой функции.

Приведенный ниже код:

```python
def sample_decorator(func):          # определяем декоратор
    def wrapper():
        print('Начало функции')
        func()
        print('Конец функции')
    return wrapper

def say():
    print('Привет Мир!')

say = sample_decorator(say)          # декорируем функцию

say()                                # вызываем декорированную функцию
```

выводит:

```no-highlight
Начало функции
Привет Мир!
Конец функции
```

Здесь `sample_decorator()` является функцией-декоратором. Как можно заметить, она является функцией высшего порядка, так как принимает функцию в качестве аргумента, а также возвращает функцию. Внутри `sample_decorator()` мы определили другую функцию — обёртку, которая обёртывает передаваемую функцию `say()` и затем изменяет её поведение. Декоратор возвращает эту обёртку.

Декорирование функции `say()` происходит в следующей строке:

```python
say = sample_decorator(say)
```

После декорирования переменная `say` указывает на внутреннюю функцию `wrapper()`. **Важно понимать** то, что при вызове функции `sample_decorator(say)` с переданной в качестве аргумента функцией `say()` возвращается вложенная функция `wrapper()` в качестве результата. Функция `wrapper()`, в свою очередь, имеет ссылку на переданную в качестве аргумента функцию `say()` и вызывает эту функцию между двумя вызовами встроенной функции `print()`.

Приведенный ниже код:

```python
print(say)                         # до декорирования
say = sample_decorator(say)
print(say)                         # после декорирования
```

выводит (адрес может отличаться):

```
<function say at 0x00000122AD3F0F70>
<function sample_decorator.<locals>.wrapper at 0x00000122AD3F1090>
```

Таким образом, после декорирования мы получаем совершено другую функцию, которая расширяет функционал начальной функции.

Проще говоря: **декораторы обертывают функцию, изменяя ее поведение.**

Декоратор — это функция, которая позволяет обернуть другую функцию для расширения её функциональности без непосредственного изменения её кода.

## Введение в декораторы

В Python декораторы представляют собой мощный инструмент, который позволяет модифицировать поведение функций без изменения их кода. Чаще всего они используются для добавления дополнительной функциональности вокруг существующих функций. Это может включать в себя не только изменение выходных данных или выполнения определенных действий до и после вызова функции, но также возможность комбинирования нескольких декораторов для создания сложной функциональности. Кроме того, декораторы используются для логирования и отладки, обеспечивая прозрачный и эффективный способ отслеживания выполнения кода и выявления возможных проблем. Таким образом, декораторы становятся важным инструментом для улучшения гибкости и эффективности кода в Python.

В широком смысле, декораторы в Python это вызываемые объекты, которые создаются с помощью замыканий, принимают в качестве аргумента и возвращают дополненный или измененный вызываемый объект. В отношении декораторов функций, определение можно сформулировать следующим образом: декоратор это функция, которая создается с помощью замыкания, принимающая в качестве аргумента оборачиваемую функцию и возвращающая обернутую функцию.

Рассмотрим простой пример

```py
def decorator(foo):    
def wrapper():        
print('text before foo call')        
foo()        
print('text after foo call')    return wrapperdef greet():    print('Hello')greet()     # Hello# Применяем декоратор к функции greetgreet = decorator(greet)greet()     # text before foo call            # Hello            # text after foo call
```

В данном примере видно, что до декорирования функция выполняет ожидаемое действие, но после декорирования результат ее вызова меняется, хотя код самой функции не менялся. Это и есть изменение (модификация) поведения.

В Python реализован синтаксический сахар позволяющий декорировать функции проще, чем на предыдущем примере. Для этого перед оборачиваемой функцией необходимо указать имя функции-декоратора, добавив перед ним `@` при этом не требуется записывать в скобках имя декорируемой функции, т.к. интерпретатор сам понимает, что декорируется функция из следующей строки.

Предыдущий пример с учетом данного синтаксиса будет выглядеть так:

```
def decorator(foo):    def wrapper():        print('text before foo call')        foo()        print('text after foo call')    return wrapper@decoratordef greet():    print('Hello')greet()     # text before foo call            # Hello            # text after foo call
```

Использование декораторной нотации делает код более ясным и удобным для чтения.

К одной функции можно применить несколько декораторов. В развернутом виде, запись будет выглядеть так:

```
def each_pheasant(foo):    def wrapper():        print('каждый')        foo()        print('фазан')    return wrapperdef hunter_is_sitting(foo):    def wrapper():        print('охотник')        foo()        print('сидит')    return wrapperdef wishes_where(foo):    def wrapper():        print('желает')        foo()        print('где')    return wrapperdef know():    print('знать')know = each_pheasant(hunter_is_sitting(wishes_where(know)))know()# каждый# охотник# желает# знать# где# сидит# фазан
```

Результат выполнения данного кода будет аналогичен синтаксису:

```
@each_pheasant@hunter_is_sitting@wishes_wheredef know():    print('знать')know()# каждый# охотник# желает# знать# где# сидит# фазан
```

В обоих случаях интерпретатор получает новую функцию, обернув предыдущую функцию в обертку, из чего следует, что порядок применения декораторов влияет на результат.

![Порядок применения декораторов](https://habrastorage.org/r/w1560/getpro/habr/upload_files/ee6/fe7/fe3/ee6fe7fe3c1c8c06eb94af245d049a43.png "Порядок применения декораторов")

Порядок применения декораторов

При этом в случае использования синтаксического сахара функция know оборачивается сначала ближайшим декоратором, функция, получившаяся в результате, оборачивается следующим декоратором и так пока не будут применены все декораторы.

Использование декораторов в ином порядке приведет к неверному результату:

```
@wishes_where@hunter_is_sitting@each_pheasantdef know():    print('знать')know()# желает# охотник# каждый# знать# фазан# сидит# где
```

## Декораторы с аргументами

Может возникнуть ситуация, в которой декоратору требуется передать какое-то значение в виде аргумента. Решение может показаться не очевидным, если не разобраться с пошаговым оборачиванием функции.

Допустим, у нас есть сложная функция (longrunningfoo) выполнение которой занимает продолжительное время. Но мы заметили, что в нашем сценарии чаще всего при ее вызове используются одни и те же значения (которые впрочем, могут со временем измениться). Для оптимизации работы приложения, мы можем написать декоратор, который будет кэшировать результаты выполнения этой функции. При этом очевидно, что кол-во кэшированных значений должно быть ограничено, иначе производительность будет снижаться уже из-за объема кэша.  
В первую очередь создадим функцию с параметром, который будет указывать кол-во значений в кэше.  
`def memoize(amount):`  
Далее мы создаем функцию-декоратор, которая принимает оборачиваемую функцию в качестве аргумента  
`def inner(foo):`  
а уже внутри нее мы создаем функцию-обертку  
`def wrapper(arg):`  
и описываем логику работы декоратора, условие проверяющее, есть ли у нас уже результат для текущего аргумента и условие проверяющее, достигнут ли лимит значений в кэше. После этого собираем все вместе. Получившаяся функция может иметь следующий вид:

```
def memoize(amount):    args_list = []    memoize_dict = {}    def inner(foo):        def wrapper(arg):            if arg not in memoize_dict:                if len(args_list) == amount:                    value = args_list.pop(0)                    memoize_dict.pop(value)                args_list.append(arg)                new_value = foo(arg)                memoize_dict[arg] = new_value            return memoize_dict[arg]        return wrapper    return inner
```

Далее используем присваивание, что бы обернуть декорируемую функцию:

```
decorator = memoize(3)long_running_foo = decorator(long_running_foo)
```

В первой строке мы вызываем функцию `memoize` с аргументом `3` (кол-во значений в кэше), которая возвращает нам замыкание `inner`, которое и будет нашим декоратором. Его мы присваиваем переменной `decorator`. Функция `inner` ожидает в качестве аргумента оборачиваемую функцию. Соответственно, мы вызываем получившуюся функцию и передаем ей в качестве аргумента функцию `long_running_foo`, после чего обернутую функцию присваиваем переменной с тем же именем. Данный синтаксис можно сократить до одной строки следующим образом:

```
long_running_foo = memoize(3)(long_running_foo)
```

В данной строке происходит все то же самое, но без дополнительной переменной. Ну и переходя к использованию синтаксического сахара, вспоминаем, что имя декорируемой функции, в скобках после имени декоратора, писать не нужно, получаем следующую запись  
`@memoize(3)`  
Полностью скрипт может выглядеть следующим образом:

```
def memoize(amount):    args_list = []    memoize_dict = {}    def inner(foo):        def wrapper(arg):            if arg not in memoize_dict:                if len(args_list) == amount:                    value = args_list.pop(0)                    memoize_dict.pop(value)                args_list.append(arg)                new_value = foo(arg)                memoize_dict[arg] = new_value            return memoize_dict[arg]        return wrapper    return inner@memoize(3)def long_running_foo(arg):    print('processing..', end=' ')    return argprint(long_running_foo(1))      # processing.. 1print(long_running_foo(2))      # processing.. 2print(long_running_foo(3))      # processing.. 3print(long_running_foo(2))      # 2print(long_running_foo(3))      # 3print(long_running_foo(4))      # processing.. 4print(long_running_foo(3))      # 3print(long_running_foo(1))      # processing.. 1
```

Декоратор кэширует возвращаемые функцией значения и в случае, если для какого-то аргумента есть результат, возвращает его не вызывая саму функцию.

## Сохранение атрибутов при декорировании функции

У любой объявленной функции есть множество атрибутов, начиная с имени, имени модуля и docstring'a, и заканчивая пользовательскими атрибутами. Получить доступ с этим атрибутам можно по соответствующим именам.

```
def print_greet(name):    """Some description"""    print('Hello, ' + name + '!')print(print_greet.__name__)     # print_greetprint(print_greet.__doc__)      # Some description
```

Однако, при вызове задекорированной функции, вызывается именно обертка, и при попытке получить какие-либо атрибуты, будут получены атрибуты именно обертки:

```
def decorator(foo):    def wrapper(*args):        foo(*args)    return wrapper@decoratordef print_greet(name):    """Some description"""    print('Hello, ' + name + '!')print(print_greet.__name__)     # wrapperprint(print_greet.__doc__)      # None
```

Мы можем изменить и это поведение, передав функции-обертке соответствующие атрибуты оборачиваемой функции. Для этого после определения функции обертки нужно добавить строки типа `wrapper.__name__ = foo.__name__`.

```
def decorator(foo):    def wrapper(*args):        foo(*args)    wrapper.__name__ = foo.__name__    wrapper.__doc__ = foo.__doc__    return wrapper@decoratordef print_greet(name):    """Some description"""    print('Hello, ' + name + '!')print(print_greet.__name__)     # print_greetprint(print_greet.__doc__)      # Some description
```

Очевидным минусом этого решения является необходимость добавления отдельной строки для каждого атрибута, что захламляет код. Лучшей практикой в данной ситуации считается использование декоратора `wraps` из модуля `functools`. С помощью этого декоратора нужно декорировать функцию-обертку (иронично) и передать ему в качестве аргумента оборачиваемую функцию. В данном примере это будет выглядеть следующим образом:

```
from functools import wrapsdef decorator(foo):    @wraps(foo)    def wrapper(*args):        foo(*args)    return wrapper@decoratordef print_greet(name):    """Some description"""    print('Hello, ' + name + '!')print(print_greet.__name__)     # print_greetprint(print_greet.__doc__)      # Some description
```
 