

Мы можем без каких-либо проблем применять к функции несколько различных декораторов. Это накапливает их эффекты, и делает декораторы очень полезными на практике.

Рассмотрим два декоратора `bold()` и `italic()`, которые заключают результат вызова функции в HTML-теги:

```python
def bold(func):
    def wrapper():
        return '<b>' + func() + '</b>'
    return wrapper

def italic(func):
    def wrapper():
        return '<i>' + func() + '</i>'
    return wrapper
```

Применим их к функции `greet()`.

Приведенный ниже код:

```python
@bold
@italic
def greet():
    return 'Hello world!'

print(greet())
```

выводит:

```html
<b><i>Hello world!</i></b>
```

Декораторы применяются в порядке **снизу вверх**. Таким образом, мы можем явно использовать декорирование, обойдясь без специального синтаксиса. В таком случае цепочка вызовов функций декораторов будет выглядеть так:

```python
greet = bold(italic(greet))
```

Таким образом, сначала применяется декоратор `italic()`, который оборачивает результат вызова декорируемой функции в теги `<i></i>`, а затем результирующая обернутая функция снова обертывается декоратором `bold()`, который оборачивает результат вызова декорируемой функции в теги `<b></b>`.

Глубокие уровни наложения декораторов в итоге могут повлиять на производительность, поскольку они продолжают добавлять вложенные вызовы функций. Обычно на практике это не создает проблем, но об этом следует помнить, если вы работаете с кодом, требующим высокой производительности.
