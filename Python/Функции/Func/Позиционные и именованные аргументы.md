## Позиционные аргументы

Все ранее написанные нами функции имели **позиционные аргументы**. Такие аргументы передаются без указания имен. Они называются **позиционными**, потому что именно по позиции, расположению аргумента, функция понимает, какому параметру он соответствует.

Рассмотрим следующий код: 

```python
def diff(x, y):
    return x - y


res = diff(10, 3)    # используем позиционные аргументы
print(res)
```

Такой код выведет число 7. При вызове функции `diff()` **первому** параметру `x` будет соответствовать **первый** переданный аргумент, 10, а **второму** параметру `y`  — **второй** аргумент, 3.

В Python можно использовать не только позиционные, но и именованные аргументы.

## Именованные аргументы

Аргументы, передаваемые с именами, называются **именованными**. При вызове функции можно использовать имена параметров из ее определения. Исключение составляют списки аргументов неопределенной длины, где используются аргументы со звездочкой, но об этом в следующем уроке. Все функции из предыдущих уроков можно вызывать, передавая им именованные аргументы.

Рассмотрим следующий код: 

```python
def diff(x, y):
    return x - y


res = diff(x=10, y=3)   # используем именованные аргументы
print(res)
```

Такой код по-прежнему выведет число 7. При вызове функции `diff()` мы явно указываем, что параметру `x` соответствует аргумент 10, а параметру `y`— аргумент 3.

Использование именованных аргументов позволяет нарушать их позиционный порядок при вызове функции. Порядок упоминания именованных аргументов не имеет значения!

Мы можем вызвать функцию `diff()` так:

```python
res = diff(y=3, x=10)
```

и получить тот же результат 7.

Возможность использования именованных аргументов — еще один повод давать параметрам значащие, а не однобуквенные имена.

### Когда стоит применять именованные аргументы

Каких-то строгих правил на этот счёт не существует. Однако широко практикуется такой подход: если функция принимает больше трёх аргументов, нужно хотя бы часть из них указать по имени. Особенно важно именовать значения аргументов, когда они относятся к одному типу, ведь без имен очень трудно понять, что делает функция с подобным вызовом.

Рассмотрим определение функции `make_circle()` для рисования круга:

```python
def make_circle(x, y, radius, line_width, fill):
    # тело функции
```

Вызвать такую функцию можно так:

```python
make_circle(200, 300, 17, 2.5, True)
```

Тут непросто понять, какие параметры круга задают числа 200, 300 или 17.

Сравните:

```python
make_circle(x=200, y=300, radius=17, line_width=2.5, fill=True)
```

Такой код читать значительно проще!

В соответствии с PEP 8 при указании значений именованных аргументов при вызове функции знак равенства не окружается пробелами.

Когда значение аргументов очевидно, можно их не именовать. Да, очевидность относительна, но обычно легко понять, что скрывается за значениями при вызове функции `point3d(7, 50, 13)` или `rgb(7, 255, 45)`. В первом случае переданные аргументы – координаты точки в трехмерном пространстве, во втором – значения компонент **red**, **green**, **blue** некоторого цвета. Тут можно ориентироваться только на здравый смысл, жестких правил нет.

Мы уже сталкивались с именованными аргументами, когда вызывали функцию [[Функция print()|print()]].

Приведенный ниже код:

```python
print('aaaa', 'bbbbb', sep='*', end='##')
print('cccc', 'dddd', sep='()')
print('eeee', 'ffff', sep='123', end='python')
```

использует именованные аргументы `sep` и `end` и выводит:

```no-highlight
aaaa*bbbbb##cccc()dddd
eeee123ffffpython
```

Используя именованные аргументы `sep` и `end` можно не беспокоиться, какой из них указать первым.

  Напомним, что значение по умолчанию для `sep=' '` (символ пробела),  а для `end='\n'` (символ перевода строки).

### Комбинирование позиционных и именованных аргументов

Мы можем вызывать функции, используя именованные и позиционные аргументы одновременно. Но позиционные значения должны быть указаны **до** любых именованных!

Для функции `diff()` код:

```python
res = diff(10, y=3)   # используем позиционный и именованный аргумент
```

работает как полагается, при этом параметру `x` соответствует значение 1010.

Приведенный ниже код:

```python
res = diff(x=10, 3)   # используем позиционный и именованный аргумент
```

приводит к возникновению ошибки `SyntaxError: positional argument follows keyword argument`.

## Необязательные аргументы

Бывает, что какой-то параметр функции часто принимает одно и то же значение. Например, для функции `print()` создатели языка Python установили значения параметров `sep` и `end` равными символу пробела и символу перевода строки, поскольку эти значения используют наиболее часто.

Другим примером служит функция [[Функция int()|int()]], преобразующая строку в число. Она принимает два аргумента:

- первый аргумент: строка, которую нужно преобразовать в число;
- второй аргумент: основание [[Основы систем счисления|системы счисления]]

Это позволяет ей считывать числа в различных системах счисления.

Приведенный ниже код, преобразует двоичное число 101101:

```python
num = int('101', 2)     # аргумент 2 указывает на то, что число 101 записано в двоичной системе
```

В переменной `num` будет храниться число 5, так как 101(2)=5(10)

Но чаще всего эта функция используется для считывания из строки чисел, записанных в десятичной системе счисления. Утомительно каждый раз писать 10 вторым аргументом. В таких ситуациях Python позволяет задавать некоторым параметрам значения по умолчанию. У функции `int()` второй параметр по умолчанию равен 10, и потому можно вызывать эту функцию с одним аргументом. Значение второго подставится автоматически.

Чтобы задать **значение параметра по умолчанию**, в списке параметров функции достаточно после имени переменной написать знак равенства и нужное значение.

Параметры со значением по умолчанию идут последними, ведь иначе интерпретатор не смог бы понять, какой из аргументов указан, а какой пропущен, и для него нужно использовать значение по умолчанию.

Рассмотрим все то же определение функции `make_circle()`, которая рисует круг:

```python
def make_circle(x, y, radius, line_width, fill):
    # тело функции
```

Поскольку обычно нам нужно рисовать круг с шириной линии, равной 1 с заливкой, то логично установить данные значения в качестве значений по умолчанию:

```python
def make_circle(x, y, radius, line_width=1, fill=True):
    # тело функции
```

Теперь для того, чтобы нарисовать стандартный круг, то есть круг имеющий ширину линии, равную 11 с заливкой, мы вызываем функцию так:

```python
make_circle(100, 50, 20)
```

или так:

```python
make_circle(x=100, y=50, radius=20)
```

Если вам хочется поменять ширину линии и заливку, то вы легко можете это сделать:

```python
make_circle(x=100, y=50, radius=20, fill=False)                   # line_width=1, fill=False
make_circle(x=100, y=50, radius=20, line_width=3)                 # fill=True, line_width=3
make_circle(x=100, y=50, radius=20, line_width=5, fill=False)     # line_width=5, fill=False
```

 В соответствии с стандартом PEP 8 и при объявлении аргументов по умолчанию пробел вокруг знака равенства не ставят.

### Изменяемые типы в качестве значений по умолчанию

При использовании **изменяемых типов данных** в качестве значения параметра по умолчанию можно столкнуться с неожиданными результатами работы функции.

Рассмотрим определение функции `append()`, где в качестве значения по умолчанию используется изменяемый тип данных (список, тип `list`):

```python
def append(element, seq=[]):
    seq.append(element)
    return seq
```

Вызывая функцию `append()` следующим образом:

```python
print(append(10, [1, 2, 3]))
print(append(5, [1]))
print(append(1, []))
print(append(3, [4, 5]))
```

получим ожидаемый вывод:

```no-highlight
[1, 2, 3, 10]
[1, 5]
[1]
[4, 5, 3]
```

А если вызовем функцию `append()` так:

```python
print(append(10))
print(append(5))
print(append(1))
```

 получим **не совсем** ожидаемый вывод:

```no-highlight
[10]
[10, 5]
[10, 5, 1]
```

Что происходит? Значение по умолчанию для параметра создается единожды при определении функции (обычно при загрузке модуля) и становится атрибутом (свойством) функции. Поэтому, если значение по умолчанию изменяемый объект, то его изменение повлияет на каждый следующий вызов функции.

Чтобы посмотреть значения по умолчанию, можно использовать атрибут `__defaults__`.

Приведенный ниже код:

```python
def append(element, seq=[]):
    seq.append(element)
    return seq

print('Значение по умолчанию', append.__defaults__)
```

выводит:

```no-highlight
Значение по умолчанию ([],)
```

Приведенный ниже код:

```python
def append(element, seq=[]):
    seq.append(element)
    return seq

print('Значение по умолчанию', append.__defaults__)
print(append(10))
print('Значение по умолчанию', append.__defaults__)
print(append(5))
print('Значение по умолчанию', append.__defaults__)
print(append(1))
print('Значение по умолчанию', append.__defaults__)
```

выводит:

```no-highlight
Значение по умолчанию ([],)
[10]
Значение по умолчанию ([10],)
[10, 5]
Значение по умолчанию ([10, 5],)
[10, 5, 1]
Значение по умолчанию ([10, 5, 1],)
```

Для решения проблемы можно использовать константу `None` в качестве значения параметра по умолчанию, а в теле функции устанавливать нужное значение:

```python
def append(element, seq=None):
    if seq is None:
        seq = []
    seq.append(element)
    return seq
```

Вызывая функцию `append()` следующим образом:

```python
print(append(10))
print(append(5))
print(append(1))
```

 получим **ожидаемый вывод**:

```no-highlight
[10]
[5]
[1]
```

 Подход, основанный на значении `None`, общепринятый в Python.





## Переменное количество аргументов

Вспомним функцию `print()`, которой мы пользуемся почти в каждой задаче.

Приведенный ниже код:

```python
print('a')
print('a', 'b')
print('a', 'b', 'c')
print('a', 'b', 'c', 'd')
```

выводит:

```no-highlight
a
a b
a b c
a b c d
```

Функция `print()` принимает столько аргументов, сколько ей передано. Причем функция `print()` делает полезную работу, даже когда вызывается вообще без аргументов. В этом случае она переносит каретку печати на новую строку.

Было бы здорово научиться писать свои собственные функции, способные принимать переменное количество аргументов. Для этого потребуется специальный, совсем не сложный во всех смыслах, синтаксис.

Рассмотрим определение функции `my_func()`:

```python
def my_func(*args):
    print(type(args))
    print(args)


my_func()
my_func(1, 2, 3)
my_func('a', 'b')
```

Приведенный выше код выводит:

```1c
<class 'tuple'>
()
<class 'tuple'>
(1, 2, 3)
<class 'tuple'>
('a', 'b')
```

В заголовке функции `my_func()` указан всего один параметр `args`, но со звездочкой перед ним. Звездочка в определении функции означает, что переменная (параметр) `args` получит в виде кортежа все аргументы, переданные в функцию при ее вызове от текущей позиции и до конца.

При описании функции можно использовать **только один** параметр помеченный звездочкой, причем располагаться он должен в конце списка параметров, иначе последующим параметрам не достанется значений.

Приведенный ниже код:

```python
def my_func(*args, num):
    print(args)
    print(num)
```

не является рабочим, так как параметр со звездочкой указан раньше позиционного `num`.

Приведенный ниже код:

```python
def my_func(num, *args):
    print(args)
    print(num)


my_func(17, 'Python', 2, 'C#')
```

связывает с переменной `num` значение 1717, а с переменной `args` значение кортежа `('Python', 2, 'C#')` и выводит:

```no-highlight
('Python', 2, 'C#')
17
```

Помеченный звездочкой параметр `*args` нормально переживает и отсутствие аргументов, в то время как позиционные параметры всегда обязательны.

Приведенный ниже код:

```python
my_func(17)
```

связывает с переменной `num` значение 1717, а с переменной `args` значение пустого кортежа `()` и выводит:

```no-highlight
()
17
```

Обратите внимание: функция `my_func()` принимает несколько аргументов, но как минимум один аргумент должен быть передан обязательно. Этот первый аргумент станет значением переменной `num`, а остальные аргументы сохранятся в переменной `args`. Подобным образом можно делать любое количество обязательных аргументов.

Параметр `args` в определении функции пишется после позиционных параметров перед первым параметром со значением по умолчанию.

### Передача аргументов в форме списка и кортежа

Иногда хочется сначала сформировать набор аргументов, а потом передать их функции. Тут поможет оператор распаковки коллекций, который также обозначается звездочкой `*`.

Вспомним, что встроенная функция `sum()` принимает на вход коллекцию чисел (список, кортеж, и т.д).

Приведенный ниже код:

```python
sum1 = sum([1, 2, 3, 4])        # считаем сумму чисел в списке
sum2 = sum((10, 20, 30, 40))    # считаем сумму чисел в кортеже

print(sum1, sum2)
```

выводит:

```no-highlight
10 100
```

Однако функция `sum()` не может принимать переменное количество аргументов.

Приведенный ниже код:

```python
sum1 = sum(1, 2, 3, 4)        

print(sum1)
```

приводит к возникновению ошибки:

```no-highlight
TypeError: sum expected at most 2 arguments, got 4
```

Напишем свою версию функции `sum()`, функцию `my_sum()`, которая принимает переменное количество аргументов и вычисляет их сумму:

```python
def my_sum(*args):
    return sum(args)    # args - это кортеж
```

Приведенный ниже код:

```python
print(my_sum())
print(my_sum(1))
print(my_sum(1, 2))
print(my_sum(1, 2, 3))
print(my_sum(1, 2, 3, 4))
```

выводит:

```no-highlight
0
1
3
6
10
```

Мы также можем вызывать нашу функцию `my_sum()` , передавая ей списки или кортежи, предварительно распаковав их.

Приведенный ниже код:

```python
print(my_sum(*[1, 2, 3, 4, 5]))   #  распаковка списка
print(my_sum(*(1, 2, 3)))         #  распаковка кортежа
```

выводит:

```no-highlight
15
6
```

Более того, часть аргументов можно передавать непосредственно и даже коллекции подставлять не только по одной.

Приведенный ниже код:

```
print(my_sum(1, 2, *[3, 4, 5], *(7, 8, 9), 10))
```

выводит: 

```no-highlight
49
```

По соглашению, параметр, получающий подобный кортеж значений, принято называть `args` (от слова arguments). Старайтесь придерживаться этого соглашения.

## Получение именованных аргументов в виде словаря

Позиционные аргументы можно получать в виде `*args`, причём произвольное их количество. Такая возможность существует и для именованных аргументов. Только именованные аргументы получаются в виде словаря, что позволяет сохранить имена аргументов в ключах.

Рассмотрим определение функции `my_func()`:

```python
def my_func(**kwargs):
    print(type(kwargs))
    print(kwargs)
```

Приведенный ниже код:

```python
my_func()
my_func(a=1, b=2)
my_func(name='Timur', job='Teacher')
```

выводит: 

```1c
<class 'dict'>
{}
<class 'dict'>
{'a': 1, 'b': 2}
<class 'dict'>
{'name': 'Timur', 'job': 'Teacher'}
```

По соглашению параметр, получающий подобный словарь, принято называть `kwargs` (от словосочетания keyword arguments). Старайтесь придерживаться этого соглашения.

Параметр  `**kwargs` пишется в самом конце, после последнего аргумента со значением по умолчанию. При этом функция может содержать и `*args` и `**kwargs` параметры.

Рассмотрим определение функции, которая принимает все виды аргументов.

```python
def my_func(a, b, *args, name='Gvido', age=17, **kwargs):
    print(a, b)
    print(args)
    print(name, age)
    print(kwargs)
```

Приведенный ниже код:

```python
my_func(1, 2, 3, 4, name='Timur', age=28, job='Teacher', language='Python')
my_func(1, 2, name='Timur', age=28, job='Teacher', language='Python')
my_func(1, 2, 3, 4, job='Teacher', language='Python')
```

выводит (пустая строка вставлена для наглядности):

```python
1 2
(3, 4)
Timur 28
{'job': 'Teacher', 'language': 'Python'}

1 2
()
Timur 28
{'job': 'Teacher', 'language': 'Python'}

1 2
(3, 4)
Gvido 17
{'job': 'Teacher', 'language': 'Python'}
```

Не нужно пугаться, в реальном коде функции редко используют все эти возможности одновременно. Но понимать, как каждая отдельная форма объявления аргументов работает, и как такие формы сочетать — очень важно.

Для лучшего понимания, поэкспериментируйте с передачей аргументов. Правила использования аргументов довольно сложно описывать, но на практике мы редко сталкиваемся с проблемами.

### Передача именованных аргументов в форме словаря

Как и в случае позиционных аргументов, именованные можно передавать в функцию "пачкой" в виде словаря. Для этого нужно перед словарём поставить две звёздочки.

Рассмотрим определение функции `my_func()`:

```python
def my_func(**kwargs):
    print(type(kwargs))
    print(kwargs)
```

Приведенный ниже код:

```python
info = {'name':'Timur', 'age':'28', 'job':'teacher'}

my_func(**info)
```

выводит: 

```1c
<class 'dict'>
{'name': 'Timur', 'age': '28', 'job': 'teacher'}
```

Рассмотрим еще один пример определения функции `print_info()`, распечатывающей информацию о пользователе.

```python
def print_info(name, surname, age, city, *children, **additional_info):
    print('Имя:', name)
    print('Фамилия:', surname)
    print('Возраст:', age)
    print('Город проживания:', city)
    if len(children) > 0:
        print('Дети:', ', '.join(children))
    if len(additional_info) > 0:
        print(additional_info)
```

Приведенный ниже код:

```python
children = ['Бодхи Рансом Грин', 'Ноа Шэннон Грин', 'Джорни Ривер Грин']
additional_info = {'height':163, 'job':'actress'}

print_info('Меган', 'Фокс', 34, 'Ок-Ридж', *children, **additional_info)
```

выводит:

```no-highlight
Имя: Меган
Фамилия: Фокс
Возраст: 34
Город проживания: Ок-Ридж
Дети: Бодхи Рансом Грин, Ноа Шэннон Грин, Джорни Ривер Грин
{'height': 163, 'job': 'actress'}
```

При подстановке аргументов "разворачивающиеся" наборы аргументов вроде `*positional` и `**named` можно указывать вперемешку с аргументами соответствующего типа: `*positional` с позиционными, а `**named` — с именованными. И, конечно, же, все именованные аргументы должны идти после всех позиционных!

## Keyword-only аргументы

В Python 3 добавили возможность пометить именованные аргументы функции так, чтобы вызвать функцию можно было, только передав эти аргументы по именам. Такие аргументы называются `keyword-only` и их нельзя передать в функцию в виде позиционных.

Рассмотрим определение функции `make_circle()`:

```python
def make_circle(x, y, radius, *, line_width=1, fill=True):
```

Здесь `*` выступает разделителем: отделяет обычные аргументы (их можно указывать по имени и позиционно) от строго именованных.

Приведенный ниже код работает как и полагается:

```python
make_circle(10, 20, 5)                                     # x=10, y=20, radius=5,  line_width=1, fill=True
make_circle(x=10, y=20, radius=7)                          # x=10, y=20, radius=7,  line_width=1, fill=True
make_circle(10, 20, radius=10, line_width=2, fill=False)   # x=10, y=20, radius=10, line_width=2, fill=False
make_circle(x=10, y=20, radius=17, line_width=3)           # x=10, y=20, radius=17, line_width=3, fill=True
```

То есть аргументы `x`, `y` и `radius` могут быть переданы в качестве как позиционных, так и именованных аргументов. При этом аргументы `line_width` и `fill` могут быть переданы **только** как именованные аргументы.

Приведенный ниже код:

```python
make_circle(10, 20, 15, 20)
make_circle(x=10, y=20, 15, True)
make_circle(10, 20, 10, 2, False)
```

приводит к возникновению ошибок.

Этот пример неплохо демонстрирует подход к описанию аргументов. Первые три аргумента — координаты центра круга и радиус. Координаты центра и радиус присутствуют у круга всегда, поэтому обязательны и их можно не именовать. А вот `line_width` и `fill` — необязательные аргументы, ещё и получающие ничего не говорящие значения. Вполне логично ожидать, что вызов вида `make_circle(10, 20, 5, 3, False)` мало кому понравится! Ради ясности аргументы `line_width` и `fill`  и объявлены так, что могут быть указаны только явно через имя.

Мы также можем объявить функцию, у которой будут только строго именованные аргументы, для этого нужно поставить звёздочку в самом начале перечня аргументов.

```python
def make_circle(*, x, y, radius, line_width=1, fill=True):
```

Теперь для вызова функции `make_circle()` нам нужно передать значения всех аргументов явно через их имя:

```python
make_circle(x=10, y=20, radius=15)                              # line_width=1, fill=True
make_circle(x=10, y=20, radius=15, line_width=4, fill=False)
```

Такой разделитель можно использовать только один раз в определении функции. Его нельзя применять в функциях с неограниченным количеством позиционных аргументов `*args`.

.** Специальный синтаксис `*args` и `**kwargs` в определении функции позволяет передавать функции переменное количество позиционных и именованных аргументов. При этом `args` и `kwargs` **просто имена.** Вы не обязаны их использовать, можно выбрать любые, однако среди Python программистов приняты именно эти.

Вы можете использовать одновременно `*args` и `**kwargs` в одной строке для вызова функции. В этом случае **порядок имеет значение**. Как и аргументы, не являющиеся аргументами по умолчанию, `*args` должны предшествовать и аргументам по умолчанию, и `**kwargs`. Правильный порядок параметров:

1. позиционные аргументы,
2. `*args` аргументы, 
3. `**kwargs` аргументы.

```python
def my_func(a, b, *args, **kwargs):
```