Синтаксис:
```python
zip(*iterables, strict=False)
```
Параметры:
- \*iterables - последовательность аргументов или итераций.
- strict=False - отвечает за проверку длин переданных итераций. Доступен с версии Python 3.10.

Возвращаемое значение:
- итератор кортежей.

Описание:
 
Функция zip() создает итератор кортежей, который объединяет элементы каждой из переданных последовательностей *iterables.

Пример:
```python 
>>> for item in zip([1, 2, 3], ['sugar', 'spice', 'everything nice']):
...     print(item)

# (1, 'sugar')
# (2, 'spice')
# (3, 'everything nice')
```
Более формально: функция zip() возвращает итератор кортежей, где i-й кортеж содержит i-й элемент из каждой итерации аргументов.

Другой способ понять функцию zip() состоит в том, что она превращает строки в столбцы, а столбцы в строки. Это похоже на транспонирование матрицы.

Функция zip() ленива: элементы не будут обрабатываться, пока не будет повторена итерация, например циклом for/in или заключением в список list(zip()).

Следует учитывать, что итерации, передаваемые в zip(), могут иметь разную длину, иногда намеренно, а иногда из-за ошибки в коде. Python предлагает три разных подхода к решению этой проблемы:

По умолчанию функция zip() останавливается, когда исчерпывается самая короткая итерация. Она проигнорирует оставшиеся элементы в более длинных итерациях, обрезая результат до длины самой короткой итерации:

```python
>>> list(zip(range(3), ['fee', 'fi', 'fo', 'fum']))
# [(0, 'fee'), (1, 'fi'), (2, 'fo')]
```
Функция zip() часто используется в тех случаях, когда предполагается, что итерации имеют одинаковую длину. В таких случаях рекомендуется использовать параметр strict=True (доступен с версии Python 3.10). Вывод будет такой же, как и у обычного zip():

```python
>>> list(zip(('a', 'b', 'c'), (1, 2, 3), strict=True))
# [('a', 1), ('b', 2), ('c', 3)]
```
В отличие от поведения по умолчанию параметр strict=True (доступен с версии Python 3.10), проверяет идентичность длин итераций, вызывая ошибку ValueError, если они не совпадают:

```python
>>> list(zip(range(3), ['fee', 'fi', 'fo', 'fum'], strict=True))
# Traceback (most recent call last):
#   ...
# ValueError: zip() argument 2 is longer than argument 1
```
Без аргумента strict=True (доступен с версии Python 3.10), любая ошибка, приводящая к итерациям разной длины, будет заглушена, что может проявиться как трудно обнаруживаемая ошибка в другой части программы.

Более короткие итерации можно дополнить постоянным значением, чтобы все итерации имели одинаковую длину. Это делает itertools.zip_longest().

Пограничные случаи: с одним итерируемым аргументом, функция zip() возвращает итератор из кортежей с одним элементом. Без аргументов он возвращает пустой итератор.

Секреты и уловки:

Порядок оценки итераций слева направо гарантируется. Это делает возможной идиому для кластеризации ряда данных в группы длиной n с использованием `zip(*[iter(s)]*n, strict=True)`. Это повторяет один и тот же итератор n раз, так что каждый выходной кортеж имеет результат n вызовов итератора. Это приводит к разделению входных данных на блоки длиной n.

zip() в сочетании с оператором * можно использовать для распаковки списка:

```python
>>> x = [1, 2, 3]
>>> y = [4, 5, 6]
>>> list(zip(x, y))
# [(1, 4), (2, 5), (3, 6)]
>>> x2, y2 = zip(*zip(x, y))
>>> x == list(x2) and y == list(y2)
# True
```

Изменено в версии 3.10: Добавлен аргумент strict.

Как и где можно использовать функцию zip()
Распаковка списка кортежей на отдельные списки;
Сортировка нескольких связанных между собой списков;
Функция zip() в циклах for/in;
Создание словаря из двух списков;

Распаковка списка кортежей на отдельные списки.
Совместно с оператором распаковки * в аргументах функции zip() можно использовать распаковку списка кортежей на отдельные списки:

```python
>>> x = [1, 2, 3]
>>> y = [4, 5, 6]
# объединим два списка 
>>> zipped = zip(x, y)
>>> list(zipped)
# [(1, 4), (2, 5), (3, 6)]

# распакуем полученный список кортежей
>>> x2, y2 = zip(*zipped)
# сравниваем полученные списки
# с их исходными значениями
>>> list(x2) == x and list(y2) == y
# True
```
Сортировка нескольких связанных между собой списков.
Допустим, что есть несколько списков, которые связаны между собой по индексам и их нужно отсортировать, при этом не нарушив связей.

Рассмотрим такую ситуацию на примере из трех связанных списка, в этом случае связь означает, что нулевой элемент первого списка связан с нулевым элементом второго списка, и с нулевым элементом третьего списка, далее первый элемент первого списка связан с первым элементом второго списка, и с первым элементом третьего списка и т.д.

Следовательно сортировать списки по отдельности нельзя, т.к. нарушиться связь. Смотрим как можно сортировать такие списки, используя функцию zip()

```python
>>> from random import shuffle
# приготовим первый список
>>> x = list(range(6))
# перемешаем его
>>> shuffle(x)
# приготовим второй список
>>> y = list(range(6))
# третий список пусть будет перевернутый `y` 
>>> z = list(reversed(y))
# распечатаем для наглядности
>>> print(f'x: {x}\ny: {y}\nz: {z}')
# x: [3, 5, 2, 1, 4, 0], 
# y: [0, 1, 2, 3, 4, 5], 
# z: [5, 4, 3, 2, 1, 0])

# сортируем по первому списку `x`
>>> x, y, z = zip(*sorted(zip(x, y, z), key=lambda tpl: tpl[0]))
>>> print(f'{list(x)}\n{list(y)}\n{list(z)}')
# [0, 1, 2, 3, 4, 5]
# [5, 3, 2, 0, 4, 1]
# [0, 2, 3, 5, 1, 4]

# теперь сортируем по последнему списку `z`
# обратите внимание, что меняется только 
# аргумент `key` в функции `sorted()`
>>> x, y, z = zip(*sorted(zip(x, y, z), key=lambda tpl: tpl[2]))
>>> print(f'{list(x)}\n{list(y)}\n{list(z)}')
# [0, 4, 1, 2, 5, 3]
# [5, 4, 3, 2, 1, 0]
# [0, 1, 2, 3, 4, 5]
```
Функция zip() в циклах for/in.
Есть такие ситуации, когда необходимо перебрать несколько списков в одном цикле for/in. Первое, что приходит в голову, это вытаскивать элементы этих списков в цикле по индексу, как то так:
```python
for i in range(len(list1))
    a, b, c = list1[i], list2[i], list3[i]

# или

for i, a in enumerate(list1)
    b, c = list2[i], list3[i]
Но есть способ проще и эффектнее с использованием функции zip():

>>> lst1 = [0, 1, 2, 3, 4, 5]
>>> lst2 = [5, 3, 2, 0, 4, 1]
>>> lst3 = ['zero', 'one', 'two', 'three', 'four', 'five']
>>> for a, b, c in zip(lst1, lst2, lst3):
...     print(f'{c}:\t{a} + {b} = {a + b}')
...
# zero:   0 + 5 = 5
# one:    1 + 3 = 4
# two:    2 + 2 = 4
# three:  3 + 0 = 3
# four:   4 + 4 = 8
# five:   5 + 1 = 6
```

Создание словаря из двух списков.
```python
>>> lst1 = [0, 1, 2, 3, 4, 5]
>>> lst2 = ['zero', 'one', 'two', 'three', 'four', 'five']
# создаем словарь при помощи `dict()`
>>> dict(zip(lst1, lst2))
# {0: 'zero', 1: 'one', 2: 'two', 3: 'three', 4: 'four', 5: 'five'}

# создаем словарь при помощи выражения генератора 
# словаря, при этом меняем элементы списков местами
>>> d = {y: x for x, y in zip(lst1, lst2)}
>>> d
# {'zero': 0, 'one': 1, 'two': 2, 'three': 3, 'four': 4, 'five': 5}
```

Функция zip()

Встроенная функция `zip()` объединяет отдельные элементы из каждой переданной ей последовательности (итерируемого объекта) в кортежи.

Сигнатура функции следующая: `zip(*iterables)`. В качестве `iterable` может выступать любой итерируемый объект:

- список;
- кортеж;
- строка;
- множество;
- словарь и т.д.

![](https://ucarecdn.com/6e5bd777-145f-4d13-a231-677d81dd1b4f/)

Приведенный ниже код:

```python
numbers = [1, 2, 3]
words = ['one', 'two', 'three']

for pair in zip(numbers, words):
    print(pair)
```

выводит:

```no-highlight
(1, 'one')
(2, 'two')
(3, 'three')
```

Функция `zip()`, как и функция `enumerate()` возвращает не список, а специальный объект, который называется итератором. Такой объект похож на список тем, что его можно перебирать циклом `for`, то есть итерировать. Итератор можно преобразовать в список с помощью функции `list()`.

Приведенный ниже код:

```python
numbers = [1, 2, 3]
words = ['one', 'two', 'three']

result = zip(numbers, words)

print(result)
print(list(result))
```

выводит:

```1c
<zip object at 0x...>
[(1, 'one'), (2, 'two'), (3, 'three')]
```

Мы можем передавать функции `zip()` сколько угодно итерируемых объектов.

Приведенный ниже код:

```python
numbers = [1, 2, 3]
words = ['one', 'two', 'three']
romans = ['I', 'II', 'III']

result = zip(numbers, words, romans)
print(list(result))
```

выводит:

```no-highlight
[(1, 'one', 'I'), (2, 'two', 'II'), (3, 'three', 'III')]
```

Мы можем передать функции `zip()` даже один итерируемый объект.

Приведенный ниже код:

```python
numbers = [1, 2, 3]
result = zip(numbers)
print(list(result))
```

выводит:

```no-highlight
[(1,), (2,), (3,)]
```

Если функции `zip()` передать итерируемые объекты, имеющие разную длину, то объект с наименьшим количеством элементов определяет итоговую длину.

Приведенный ниже код:

```python
numbers = [1, 2, 3, 4]
words = ['one', 'two']
romans = ['I', 'II', 'III']

result = zip(numbers, words, romans)
print(list(result))
```

выводит:

```no-highlight
[(1, 'one', 'I'), (2, 'two', 'II')]
```

### Частые сценарии использования функции zip()

**Сценарий 1.** Функция `zip()` удобна для создания словарей, когда ключи и значения находятся в разных списках.

Приведенный ниже код:

```python
keys = ['name', 'age', 'gender']
values = ['Timur', 28, 'male']

info = dict(zip(keys, values))
print(info)
```

выводит:

```no-highlight
{'name': 'Timur', 'age': 28, 'gender': 'male'}
```

**Сценарий 2.** Функция `zip()` удобна для одновременного (параллельного) итерирования сразу по нескольким коллекциям.

Приведенный ниже код:

```python
name = ['Timur', 'Ruslan', 'Rustam']
age = [28, 21, 19]

for x, y in zip(name, age):
    print(x, y)
```

выводит: 

```no-highlight
Timur 28
Ruslan 21
Rustam 19
```