

Функция `hash()` принимает в качестве аргумента некоторый объект и возвращает целое число, представляющее хеш-значение переданного объекта. Большинство неизменяемых встроенных объектов Python являются хешируемыми и имеют хеш-значение. Изменяемые коллекции, такие как списки, множества и словари, не имеют хеш-значений.

Приведенный ниже код:

```python
print(hash(899))
print(hash(69.0))
print(hash('timyrik'))
print(hash((1, 2, 3)))
print(hash(False))
print(hash(True))
```

выводит:

```python
899
69
1468304915
-378539185
0
1
```

Обратите внимание на то, что хеш-значения целых чисел совпадают с самим числом, за исключением числа −1.

Приведенный ниже код:

```python
for i in range(-5, 6):
    print(hash(i))
```

выводит:

```no-highlight
-5
-4
-3
-2
-2
0
1
2
3
4
5
```



Приведем ниже таблицу хешируемости встроенных в Python типов данных:

|   |   |
|---|---|
|**Тип данных**|**Хешируемость**|
|`bool`|✔️|
|`int`|✔️|
|`float`|✔️|
|`complex`|✔️|
|`str`|✔️|
|`list`|❌|
|`tuple`|✔️*|
|`set`|❌|
|`frozenset`|✔️|
|`dict`|❌|

Кортежи (тип `tuple`) хешируемы только при условии, что их элементы являются хешируемыми.

Приведенный ниже код:

```python
tpl = (1, 2, True, 'python')

print(hash(tpl))
```

выводит (Python 3.10):

```no-highlight
8728127638606130792
```

 Приведенный ниже код:

```python
tpl = (1, 2, [True, 'python'])

print(hash(tpl))
```

приводит к возникновению ошибки (исключения):

```no-highlight
TypeError: unhashable type: 'list'
```


Имейте в виду, что хеш-функция может меняться в новых версиях языка Python. Поэтому всегда является плохой идеей сохранять хеш-значения, которые генерирует встроенная функция `hash()`  в базу данных или на диск.


Встроенная функция `hash()` используется для вычисления хеш-значения объекта. Она принимает один аргумент:

- `object` — объект, хеш-значение которого требуется вычислить

Функция возвращает **целое число**, представляющее хеш-значение переданного объекта.

Приведенный ниже код:

```python
print(hash(1))                          # хеш-значение целого числа
print(hash(2.5))                        # хеш-значение вещественного числа
print(hash('bee'))                      # хеш-значение строки
print(hash((1, 2, 3)))                  # хеш-значение кортежа
```

выводит (хеш-значения могут отличаться):

```no-highlight
1
1152921504606846978
7327928671037089808
529344067295497451
```

В Python хеш-значениями небольших целых чисел являются сами числа. Исключение представляет число `-1`, его хеш-значение равно `-2`.

Приведенный ниже код:

```python
print(hash(1))
print(hash(69))
print(hash(314))
print(hash(2077))
print(hash(-1))
```

выводит:

```no-highlight
1
69
314
2077
-2
```

\ Почитать о том, почему `hash(-1) == -2`, можно по [ссылке](https://stackoverflow.com/questions/10130454/why-do-1-and-2-both-hash-to-2-in-cpython) и [ссылке](https://omairmajid.com/posts/2021-07-16-why-is-hash-in-python/).

Для более сложных типов данных, например, [[Тип данных str]], встроенная функция `hash()` возвращает новое хеш-значение при каждом новом запуске программы.

Приведенный ниже код:

```python
print(hash('beegeek'))
print(hash('beegeek'))
print(hash('beegeek!'))
print(hash('beek'))
print(hash('geek'))
```

выводит (хеш-значения могут отличаться):

```no-highlight
3750473969066821398
3750473969066821398
-5101520736652926912
6279574873516782143
-8122464414691433199
```

Обратите внимание на то, что первые два значения всегда будут равны между собой, поскольку данный код работает в рамках одного запуска программы. Если программу перезапустить, значения будут совершенно другими.

Дело в том, что Python по умолчанию использует рандомизацию хешей для некоторых типов (например, `str`), чтобы сделать хеш-значения менее предсказуемыми. Это делает функцию `hash()` более безопасной и позволяет избежать возникновения [DoS-атаки](https://ru.wikipedia.org/wiki/DoS-%D0%B0%D1%82%D0%B0%D0%BA%D0%B0), которая может использовать уязвимость хеш-функций на веб-серверах. Злоумышленники могут использовать слабый алгоритм хеширования, чтобы преднамеренно создавать коллизии хешей, перегружая сервер и делая его недоступным.

Функция `hash()` может работать не только с числами и строками, но и с большинством встроенных типов данных.

Приведенный ниже код:

```python
print(hash(None))
print(hash(print))
print(hash(hash))
```

выводит (хеш-значения могут отличаться):

```no-highlight
-9223363241050908545
4611694664844004019
8646416648793
```

Встроенная функция `hash()` не работает с экземплярами встроенных изменяемых типов данных, таких как  [[Тип данных list]], [[Тип данных set]] и [[Тип данных dict]]. Такие объекты являются **нехешируемыми**.

Приведенный ниже код:

```python
print(hash(['bee', 'geek']))
```

приводит к возбуждению исключения:

```no-highlight
TypeError: unhashable type: 'list'
```

Встроенная функция `hash()` работает с экземплярами типа  [[Тип данных tuple]] только в том случае, если их элементами являются хешируемые объекты.

Приведенный ниже код:

```python
print(hash(('bee', 'geek', 1)))
```

выводит (хеш-значение может отличаться):

```no-highlight
8983813428229996918
```

В то время как приведенный ниже код:

```python
print(hash(('bee', 'geek', [1, 2, 3])))
```

приводит к возбуждению исключения:

```no-highlight
TypeError: unhashable type: 'list'
```

  Функция `hash()` также работает с экземплярами типа [[Тип данных frozenset]].

Функция `hash()` обрезает значение, возвращаемое методом `__hash__()`, до определенного размера. На 64-х разрядном компьютере встроенная функция `hash()` возвращает целочисленное значение из диапазона `[-2305843009213693950; 2305843009213693950]`.

Приведенный ниже код:

```python
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __eq__(self, other):
        if isinstance(other, Point):
            return self.x == other.x and self.y == other.y
        return NotImplemented

    def __hash__(self):
        return 123456789012345678901234567890


p = Point(1, 2)

print(hash(p))
```

выводит:

```no-highlight
248789772095949448
```

Очевидно, что напечатанное значение равняется `123456789012345678901234567890 % 230584300921369395`