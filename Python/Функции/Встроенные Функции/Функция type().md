Синтаксис:
```python
type(object)
type(name, bases, dict)
```
Параметры:
- object - объект, тип которого определяется
- name - имя для создаваемого типа
- bases - кортеж с родительскими классами
- dict - словарь, будет являться пространством имён для тела класса
Возвращаемое значение:

- тип объекта, при вызове с одним аргументом,
объект нового типа при вызове класса с тремя аргументами.

Вызов класса type() с одним аргументом:
Класс type() с одним аргументом object возвращает тип объекта. Возвращаемое значение - это как правило, тот же объект, что и возвращаемый object.\_\_class__.

Рекомендуется для проверки типа объекта использовать встроенную функцию [[Функция isinstance()]], так как она принимает во внимание подклассы.

Примеры использования класса type() при вызове с одним аргументом.
```python
>>> x = 1
>>> type(x)
# <class 'int'>

>>> x = [1, 2, 3]
>>> type(x)
# <class 'list'>

# проверка типа объекта
>>> x = 1
>>> isinstance(x, int)
# True
>>> x = [1, 2, 3]
>>> isinstance(x, list)
# True
```
Вызов класса type() с тремя аргументами:
Класс type() с тремя аргументами вернет объект нового типа. Это по сути динамическая форма инструкции class, ее еще называют метакласс.

Другими словами класс type(), вызванный с тремя аргументами на самом деле является метаклассом! Класс type() это метакласс, который Python внутренне использует для создания всех классов.

Все, с чем имеем дело в Python, является объектом. Сюда входят функции и классы целые числа, строки и т.д. Все они объекты. И все они созданы из класса.

```python
# type - это тип всех типов, для 
# которых не указан явно иной метакласс
>>> type(type)
# <class 'type'>
>>> type(object)
# <class 'type'>
>>> type(list)
# <class 'type'>
>>> type(int)
# <class 'type'>
>>> class Bar(object): pass
>>> type(Bar)
# <class 'type'>
```
В общем type - это класс всех классов в языке Python и является собственным метаклассом. Класс type() нельзя воспроизвести на чистом Python.

Аргумент name является именем класса и становится атрибутом __name__. bases это кортеж, в котором перечисляются базовые классы, он становится атрибутом __bases__. dict - это пространство имен, содержащее определения для тела класса, которое копируется в стандартный словарь и становится атрибутом __dict__.

Понятия класс и тип по сути являются синонимами. Пользовательские типы данных могут быть сконструированы налету, во время исполнения, при помощи вызова type() с тремя аргументами или определены в коде, например при помощи инструкции class.

Важно понимать, что тип, как и другие сущности в Python, тоже является объектом.

Изменено в Python 3.6: подклассы, которые не переопределяют, type.__new__ больше не могут использовать форму с одним аргументом для получения типа объекта.

Дополнительно смотрите раздел "Определение метаклассов metaclass в Python".

Примеры создания и изменения классов "на лету" при помощи type():
Например, следующие два определения создают идентичные объекты.
```python
>>> class Foo(object):
...       bar = True
>>> Foo = type('Foo', (), {'bar':True})
Класс Foo, созданный через метакласс type() можно использовать как обычный класс:

>>> Foo
# <class '__main__.Foo'>
>>> f = Foo()
>>> f.bar
# True

# можно наследоваться от него
>>>   class FooChild(Foo): pass
...
>>> FooChild
# <class '__main__.FooChild'>
>>> FooChild.bar # bar унаследован от Foo
# True
```
Добавим методы в класс FooChild(). Для этого определим функцию и добавим ее как атрибут.

```python
>>> def echo_bar(self):
...       print(self.bar)
...
>>> FooChild = type('FooChild', (Foo,), {'echo_bar': echo_bar})
>>> hasattr(Foo, 'echo_bar')
# False
>>> hasattr(FooChild, 'echo_bar')
# True
>>> my_foo = FooChild()
>>> my_foo.echo_bar()
# True

# после динамического создания класса добавим еще один метод 
>>> def echo_bar_more(self):
...       print('yet another method')
...
>>> FooChild.echo_bar_more = echo_bar_more
>>> hasattr(FooChild, 'echo_bar_more')
# True
```