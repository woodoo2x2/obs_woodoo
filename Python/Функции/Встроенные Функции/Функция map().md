Функция map()

При работе со списками часто требуется применить одно и то же преобразование к каждому элементу. Можно написать цикл, содержащий нужное преобразование.

Например, для преобразования списка чисел в список их квадратов, код может выглядеть так:

```python
def f(x):
    return x**2     # тело функции, которая преобразует аргумент x


old_list = [1, 2, 4, 9, 10, 25]
new_list = []
for item in old_list:
    new_item = f(item)
    new_list.append(new_item)

print(old_list)
print(new_list)
```

Результатом работы такого кода будет:

```no-highlight
[1, 2, 4, 9, 10, 25]
[1, 4, 16, 81, 100, 625]
```

Несложно понять, что цикл будет выглядеть одинаково практически во всех случаях. Меняться будет только преобразование, то есть применяемая функция `f()`. Так почему бы не обобщить код, чтобы функция была параметром? Так и сделаем:

```python
def map(function, items):
    result = []
    for item in items:
        new_item = function(item)
        result.append(new_item)

    return result
```

Теперь мы можем совершать преобразования, используя функцию высшего порядка `map()`.

Приведенный ниже код:

```python
def square(x):
    return x**2


def cube(x):
    return x**3


numbers = [1, 2, -3, 4, -5, 6, -9, 0]

strings = map(str, numbers)        # используем в качестве преобразователя - функцию str
abs_numbers = map(abs, numbers)    # используем в качестве преобразователя - функцию abs

squares = map(square, numbers)     # используем в качестве преобразователя - функцию square
cubes = map(cube, numbers)         # используем в качестве преобразователя - функцию cube

print(strings)
print(abs_numbers)
print(squares)
print(cubes)
```

выводит:

```no-highlight
['1', '2', '-3', '4', '-5', '6', '-9', '0']
[1, 2, 3, 4, 5, 6, 9, 0]
[1, 4, 9, 16, 25, 36, 81, 0]
[1, 8, -27, 64, -125, 216, -729, 0]
```

Функция называется "map" то есть "отобразить". Название пришло из математики, где так называется функция, отображающая одно множество значений в другое путём преобразования всех элементов с помощью некой трансформации.

Реализованную нами функцию `map()` можно использовать как альтернативную возможность для преобразования типов элементов любого списка. Раньше мы решали такую задачу с помощью списочных выражений. Теперь можем использовать и функцию `map()`.

Приведенный ниже код при условии, что функция `map()` определена, как указано выше:

```python
strings = ['10', '12', '-4', '-9', '0', '1', '23', '100', '99']

numbers1 = [int(c) for c in strings]  # используем списочное выражение для преобразования
numbers2 = map(int, strings)          # используем функцию map() для преобразования

print(numbers1)
print(numbers2)
```

выводит:

```no-highlight
[10, 12, -4, -9, 0, 1, 23, 100, 99]
[10, 12, -4, -9, 0, 1, 23, 100, 99]
```

### Цепочки преобразований

Мы также можем строить цепочки преобразований, несколько раз вызывая функцию `map()`.

Приведенный ниже код при условии, что функция `map()` определена, как указано выше:

```python
numbers = ['-1', '20', '3', '-94', '65', '6', '-970', '8']

new_numbers = map(abs, map(int, numbers))

print(new_numbers)
```

выводит:

```no-highlight
[1, 20, 3, 94, 65, 6, 970, 8]
```

То есть, сначала мы преобразуем список строк в список чисел с помощью кода `map(int, numbers)`, получая список `[-1, 20, 3, -94, 65, 6, -970, 8]`. Далее с помощью еще одного вызова функции `map()` трансформируем полученный список в список `[1, 20, 3, 94, 65, 6, 970, 8]`.

Встроенная функция map()

Встроенная функция `map()` имеет сигнатуру `map(func, *iterables)`. В отличие от нашей версии из прошлого урока, встроенная функция `map()` может принимать сразу несколько последовательностей, переменное количество аргументов.

В качестве параметра `func` указывается [[Функция (func)]], которой будет передаваться текущий элемент последовательности. Внутри функции `func` необходимо вернуть новое значение. Для примера прибавим к каждому элементу списка число 7.

Приведенный ниже код:

```python
def increase(num):
    return num + 7


numbers = [1, 2, 3, 4, 5, 6]
new_numbers = map(increase, numbers)     #  используем встроенную функцию map()

print(new_numbers)
```

выведет не список, а специальный объект:

```1c
<map object at 0x...>
```

Такой объект похож на список тем, что его можно перебирать циклом `for`, то есть итерировать. Такие объекты в Python называют **итераторами**.

Приведенный ниже код:

```python
def increase(num):
    return num + 7


numbers = [1, 2, 3, 4, 5, 6]
new_numbers = map(increase, numbers)

for num in new_numbers:    #  итерируем циклом for
    print(num)
```

выводит:

```no-highlight
8
9
10
11
12
13
```

Чтобы получить из итератора список, нужно воспользоваться функцией [[Функция list()]]:

```python
new_numbers = list(map(increase, numbers))
```

Функция `map()` возвращает объект, поддерживающий итерации, а не список. Чтобы получить из него список, необходимо результат передать в функцию `list()`.

Функции `map()` можно передать несколько последовательностей. В этом случае в функцию обратного вызова `func` будут передаваться сразу несколько элементов, расположенных в последовательностях на одинаковых позициях.

Приведенный ниже код суммирует элементы трех списков:

```python
def func(elem1, elem2, elem3):
    return elem1 + elem2 + elem3


numbers1 = [1, 2, 3, 4, 5]
numbers2 = [10, 20, 30, 40, 50]
numbers3 = [100, 200, 300, 400, 500]

new_numbers = list(map(func, numbers1, numbers2, numbers3))  #  преобразуем итератор в список

print(new_numbers)
```

и выводит:

```no-highlight
[111, 222, 333, 444, 555]
```

Если в последовательностях разное количество элементов, то последовательность с минимальным количеством элементов становится ограничителем.

Приведенный ниже код:

```python
def func(elem1, elem2, elem3):
    return elem1 + elem2 + elem3


numbers1 = [1, 2, 3, 4]
numbers2 = [10, 20]
numbers3 = [100, 200, 300, 400, 500]

new_numbers = list(map(func, numbers1, numbers2, numbers3))  #  преобразуем итератор в список

print(new_numbers)
```

выводит:

```python
[111, 222]
```

Встроенная функция `map()` реализована очень гибко. В качестве последовательностей мы можем использовать: списки, строки, кортежи, множества, словари.

Приведем пример удобного использования встроенной функции `map()`, которой передано две последовательности.

Приведенный ниже код:

```python
circle_areas = [3.56773, 5.57668, 4.31914, 6.20241, 91.01344, 32.01213]

result1 = list(map(round, circle_areas, [1]*6))         # округляем числа до 1 знака после запятой
result2 = list(map(round, circle_areas, range(1, 7)))   # округляем числа до 1,2,...,6 знаков после запятой

print(circle_areas)
print(result1)
print(result2)
```

выводит:

```no-highlight
[3.56773, 5.57668, 4.31914, 6.20241, 91.01344, 32.01213]
[3.6, 5.6, 4.3, 6.2, 91.0, 32.0]
[3.6, 5.58, 4.319, 6.2024, 91.01344, 32.01213]
```

Встроенная функция [[Функция round()]] принимает два числовых аргумента `x` и `n` и округляет переданное число `x` до `n` цифр после десятичной запятой. Значением по умолчанию для `n` является 0.

### Функции all() и any() в связке с функцией map()

[[Функция all()]] и [[Функция any()]] могут быть полезны в комбинации с функцией `map()`, которая может преобразовывать элементы последовательности (итерируемого объекта) к значению `True/False` в соответствии с неким условием.

Приведенный ниже код, проверяет, **все ли элементы** списка `numbers` больше 1010:

```python
numbers = [17, 90, 78, 56, 231, 45, 5, 89, 91, 11, 19]

result = all(map(lambda x: True if x > 10 else False, numbers))

if result:
    print('Все числа больше 10')
else:
    print('Хотя бы одно число меньше или равно 10')
```

и выводит:

```no-highlight
Хотя бы одно число меньше или равно 10
```

так как список `numbers` содержит число 5, которое не больше чем 10.

Лямбда функцию, которая преобразует элементы списка `numbers` в значения `True/False` можно упростить следующим образом:

```
result = all(map(lambda x: x > 10, numbers))
```

Приведенный ниже код, проверяет, что **хотя бы один элемент** списка четное число:

```python
numbers = [17, 91, 78, 55, 231, 45, 5, 89, 99, 11, 19]

result = any(map(lambda x: x % 2 == 0, numbers))

if result:
    print('Хотя бы одно число четное')
else:
    print('Все числа нечетные')
```

и выводит:

```no-highlight
Хотя бы одно число четное
```

так как список `numbers` содержит четное число 78.
