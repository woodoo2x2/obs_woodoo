

**Задача 1.** Реализовать функцию `draw_rect()` с использованием рекурсии, которая принимает два аргумента в следующем порядке:

- `width` – ширина прямоугольника
- `height` – высота прямоугольника

и печатает звездный прямоугольник размерами `width × height`.

**Решение.** Для использования рекурсии будем использовать третий аргумент `step`.

```python
def draw_rect(width, height, step):
    if step < height:
        print('*' * width)
        draw_rect(width, height, step + 1)
```

Приведенный ниже код:

```python
draw_rect(4, 3, 0)
print()
draw_rect(6, 6, 0)
print()
draw_rect(10, 2, 0)
```

выводит:

```no-highlight
****
****
****

******
******
******
******
******
******

**********
**********
```

Несложно заметить, что такая функция хоть и выполняет поставленную задачу, но содержит дополнительный параметр `step`, который необходим для остановки рекурсии. Мы вызываем функцию, подставляя вместо `step` значение 00.

Для того чтобы избавиться от параметра `step` и оставить только `width` и `height`, можно использовать два подхода.

**Подход 1.** Сделать значение по умолчанию для `step`, равным нулю:

```python
def draw_rect(width, height, step=0):
    if step < height:
        print('*' * width)
        draw_rect(width, height, step + 1)
```

Минусом такого подхода является тот факт, что вызывающий функцию код, может передать значение отличное от нуля для параметра `step`. В этом случае код не будет работать так, как полагалось.

**Подход 2.** Использовать вложенные функции и механизм замыканий.

```python
def draw_rect(width, height):
    def rec(step):
        if step < height:
            print('*' * width)
            rec(step + 1)
    rec(0)
```

Функция `draw_rect()` определяет внутри себя рекурсивную функцию `rec()`, которая имеет один параметр `step` и имеет доступ к переменным `width` и `height` внешней функции. Затем функция `draw_rect()` вызывает внутреннюю рекурсивную функцию, передавая в качестве `step` значение 00.

Теперь функция `draw_rect()` принимает только нужные аргументы и скрывает в своей реализации значение `step`, которое нужно лишь для остановки рекурсии. Такой подход используется достаточно часто при написании рекурсивных функций.

**Задача 2.** Реализовать функцию `print_numbers()` с использованием рекурсии, которая принимает два аргумента в следующем порядке:

- `start` – начальное целое число
- `end` – конечное целое число

и печатает все целые числа от `start` до `end` включительно.

**Решение.** Для решения задачи будем использовать вложенную рекурсивную функцию `rec()`:

```python
def print_numbers(start, end):
    def rec(num):
        if num <= end:
            print(num)
            rec(num + 1)
    rec(start)
```

Приведенный ниже код:

```python
print_numbers(0, 7)
print()
print_numbers(-3, 4)
```

выводит:

```no-highlight
0
1
2
3
4
5
6
7

-3
-2
-1
0
1
2
3
4
```

Рекурсивная функция `rec()` полагает, что значение `start` не больше, чем значение `end`. Если попытаться вызвать функцию с аргументами, равными, например, `start=7`, `end=0`, то рекурсивных вызовов не будет, и функция ничего не распечатает.




 Вложенные функции позволяют избавиться от глобальных переменных. Такая техника позволяет сделать внешнюю для функции переменную, но при этом спрятанную от посторонних глаз, в отличие от глобальной.

 Наиболее распространенной ошибкой при использовании рекурсии является бесконечная рекурсия, когда цепочка вызовов функций никогда не завершается и продолжается, пока не кончится свободная память в компьютере. При разработке рекурсивной функции необходимо прежде всего оформлять условия завершения рекурсии и думать, почему рекурсия когда-либо завершит работу.

 В ситуации, когда не предусмотрен способ остановки рекурсивных вызовов, происходит переполнение аппаратного стека и возбуждается исключение `RecursionError`.


**Задача 1.** Реализовать функцию `factorial()` с использованием рекурсии, которая принимает один аргумент:

- `n` – неотрицательное число

и возвращает факториал числа `n`.

**Решение.** Факториалом неотрицательного числа nn называется произведение всех натуральных чисел от 11 до nn, то есть n!=1⋅2⋅3⋅…⋅(n−1)⋅n, при этом полагают, что 0!=1.

Для разработки рекурсивного алгоритма вычисления факториала сначала мы должны описать базовый случай, который можно решить без рекурсии. Это как раз тот случай, когда nn равняется 0. Если же n>0 то n!=1⋅2⋅3⋅…⋅(n−1)⋅n=(n−1)!n или в терминах функции `factorial()`, мы получаем соотношение:factorial(n)=n⋅factorial(n−1)

Обратите внимание на то, что рекурсивный вызов работает с уменьшенным вариантом задачи для n−1

```python
def factorial(n):
    if n == 0:
        return 1                        # базовый случай
    else:
        return n * factorial(n-1)       # рекурсивный случай
```

Приведенный ниже код:

```python
print('Факториал числа 4 равен', factorial(4))
```

выводит:

```no-highlight
Факториал числа 4 равен 24
```

В приведенном выше примере функция `factorial()` вызывается с аргументом 44, который передается в параметр `n`. Поскольку `n` не равняется 0, выражение `else` условного оператора `if` исполняет инструкцию:

```python
return n * factorial(n - 1)
```

Хотя это и инструкция `return`, она не возвращает значение немедленно. Прежде чем возвращаемое значение будет определено, должно быть определено значение `factorial(n - 1)`. Функция `factorial()` вызывается рекурсивно вплоть до пятого вызова, в котором значение параметра `n` будет равно 0.

![](https://ucarecdn.com/fbc78916-0368-40ed-a664-cfbd0c8e0d62/)

Данный рисунок демонстрирует, почему рекурсивный алгоритм должен уменьшать задачу с каждым рекурсивным вызовом. В конечном счете рекурсия должна остановиться, чтобы решение было достигнуто.

Если каждый рекурсивный вызов работает с уменьшенным вариантом задачи, то работа рекурсивных вызовов сводится к базовому случаю. Базовый случай не требует рекурсии, и поэтому он останавливает цепочку рекурсивных вызовов.

  Обратите внимание на то, что в модуле [[Модуль math]] уже реализована функция `factorial()`.

 **Задача 2.** Реализовать функцию `sum_to()` с использованием рекурсии, которая принимает один аргумент:

- `n` – неотрицательное число

и возвращает сумму чисел от 00 до nn включительно.

**Решение.** Для разработки рекурсивного алгоритма вычисления искомой суммы сначала мы должны описать базовый случай, который можно решить без рекурсии. Это как раз тот случай, когда nn равняется 00. Если же n>0n>0, то 0+1+2+…+(n−1)+n=(0+1+2+…+(n−1))+n0+1+2+…+(n−1)+n=(0+1+2+…+(n−1))+n или в терминах функции `sum_to()` мы получаем соотношение:sum_to(n)=n+sum_to(n−1)sum_to(n)=n+sum_to(n−1)

Обратите внимание на то, что рекурсивный вызов работает с уменьшенным вариантом задачи для n−1n−1.

```python
def sum_to(n):
    if n == 0:
        return 0                       # базовый случай
    else:
        return n + sum_to(n - 1)       # рекурсивный случай
```

Приведенный ниже код:

```python
print(sum_to(0))
print(sum_to(5))
print(sum_to(10))
print(sum_to(100))
```

выводит:

```no-highlight
0
15
55
5050
```

**Задача 3.** Реализовать функцию `recursive_sum()` с использованием рекурсии, которая принимает один аргумент:

- `nums` – список чисел

и возвращает сумму элементов списка `nums`.

**Решение.** Для разработки рекурсивного алгоритма вычисления искомой суммы сначала мы должны описать базовый случай, который можно решить без рекурсии. Базовым случаем будем считать пустой `nums`, сумма элементов которого равна нулю.

```python
def recursive_sum(nums):
    if not nums:
        return 0                                       # базовый случай
    return nums[0] + recursive_sum(nums[1:])           # рекурсивный случай
```

Приведенный ниже код:

```python
numbers = [1, 9, 2, 8, 7, 3]

print(recursive_sum(numbers))
```

выводит:

```no-highlight
30
```

)Разумеется, для нахождения суммы чисел списка нужно использовать встроенную функция [[Функция sum()]]. Данный пример представлен лишь в учебных целях.

**Задача 4.** Во всех предыдущих задачах тело функции содержало ровно один рекурсивный вызов. Однако так бывает не всегда. Классический пример – числа Фибоначчи.

Числа Фибоначчи – последовательность чисел: 1,1,2,3,5,8,13,21,34,55,89,…в которой два первых элемента равны 1, а каждый следующий — сумме двух предыдущих. 



Рекурсивная функция, вычисляющая числа Фибоначчи имеет вид:

```python
def fib(n):
    if n <= 2:
        return 1                             # базовый случай
    else:
        return fib(n - 1) + fib(n - 2)       # рекурсивный случай
```

Приведенный ниже код:

```no-highlight
print(fib(6))
```

выводит:

```no-highlight
8
```

  Несложно заметить, что рекурсивная функция `fib()` почти слово в слово совпадает с определением чисел Фибоначчи.

Функция `fib()` порождает **два рекурсивных вызова** `fib(n - 1)` и `fib(n - 2)`. Дерево рекурсивных вызовов будет иметь вид:

![](https://ucarecdn.com/bfe9075f-f1cb-4938-bb95-a85f50de1c53/)

Во время вычисления значения числа Фибоначчи мы неявно обходим дерево в глубину. Важно понимать, что экземпляры функции выполняются не параллельно, а последовательно: сначала левое поддерево, а потом правое поддерево из любой вершины.

Обратите внимание на то, что дерево рекурсивных вызовов очень быстро разрастается при росте номера числа Фибоначчи, что влечет замедление программы и трату памяти. А все потому, что в рекурсивном случае мы много раз вычисляем одно и то же число Фибоначчи:

![](https://ucarecdn.com/5a4ae4be-0ae0-4e9a-a6bd-d9aa53b10888/)



 Наиболее распространенной ошибкой при использовании рекурсии является бесконечная рекурсия, когда цепочка вызовов функций никогда не завершается и продолжается, пока не кончится свободная память в компьютере.

Определим две наиболее распространенные причины для бесконечной рекурсии на примере некорректно написанной функции нахождения факториала числа.

**Ошибка:** неправильное оформление выхода из рекурсии

```python
def factorial(n):
    return n * factorial(n - 1)
```

**Ошибка:** рекурсивный вызов с неправильными аргументами

```python
def factorial(n):
    if n == 0:
        return 1
    else:
        return n * factorial(n)
```

**Примечание 3.** Не рекурсивный аналог функции, вычисляющей числа Фибоначчи может выглядеть так:

```python
def fib(n):
    a, b = 1, 1
    for _ in range(n - 2):
        a, b = b, a + b
    return b
```

**Примечание 4.** Рекурсию также можно использовать в лямбда функциях.

Приведенный ниже код:

```python
fact = lambda n: 1 if n == 0 else n * fact(n - 1)

print(*map(fact, range(1, 11)))
```

выводит последовательность факториалов чисел от 1 до 10:

```no-highlight
1 2 6 24 120 720 5040 40320 362880 3628800
```