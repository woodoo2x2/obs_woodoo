Благодаря грамотной реализации словарей и множеств в виде структур, построенных на [[Хеширование Python|хешировании]], поиск в них происходит достаточно быстро. В этом степе мы покажем, насколько быстро выполняется данная операция в словарях и множествах, а для наглядности дополнительно покажем скорость поиска в списках.

При поиске объекта в списке необходимо перебирать список поэлементно, и если искомый объект находится в самом конце, то список придется перебрать полностью.

В качестве тестовых данных возьмем словарь, множество и список, элементами которых являются различные целые числа. С помощью оператора `in` будем выполнять поиск каждого числа, находящегося в коллекции.

**1 этап.** Рассмотрим коллекции из `10000` элементов.

Приведенный ниже код:

```python
from time import perf_counter

def search_time_test(collection, numbers):
    start = perf_counter()
    
    for num in numbers:
        num in collection
    
    end = perf_counter()
    return end - start

numbers = range(10000)

d = dict(zip(numbers, numbers))
s = set(numbers)
l = list(numbers)

print(search_time_test(d, numbers))                # результат в секундах
print(search_time_test(s, numbers))                # результат в секундах
print(search_time_test(l, numbers))                # результат в секундах
```

выводит (время может отличаться):

```no-highlight
0.00030620000325143337
0.00024690001737326384
0.20942239998839796
```

Здесь все коллекции на поиск `10000` элементов затратили менее секунды, однако словарь и множество сделали это не просто быстро, а очень быстро.

**2 этап.** Рассмотрим коллекции из `100000` элементов.

Приведенный ниже код:

```python
from time import perf_counter

def search_time_test(collection, numbers):
    start = perf_counter()
    
    for num in numbers:
        num in collection
    
    end = perf_counter()
    return end - start

numbers = range(100000)

d = dict(zip(numbers, numbers))
s = set(numbers)
l = list(numbers)

print(search_time_test(d, numbers))
print(search_time_test(s, numbers))
print(search_time_test(l, numbers))
```

выводит (время может отличаться):

```no-highlight
0.00274089997401461
0.0027747999993152916
20.910516000003554
```

С увеличением количества элементов в коллекциях в `10` раз время поиска в списке выросло в `100` раз, в то время как словарь и множество хоть и выполнили поиск медленнее, чем в предыдущем этапе, по-прежнему затратили на все операции менее секунды.

**3 этап.** Рассмотрим коллекции из `1000000` элементов.

Приведенный ниже код:

```python
from time import perf_counter

def search_time_test(collection, numbers):
    start = perf_counter()
    
    for num in numbers:
        num in collection
    
    end = perf_counter()
    return end - start

numbers = range(1000000)

d = dict(zip(numbers, numbers))
s = set(numbers)
l = list(numbers)

print(search_time_test(d, numbers))
print(search_time_test(s, numbers))
print(search_time_test(l, numbers))
```

выводит (время может отличаться):

```no-highlight
0.025614199985284358
0.02500779996626079
2152.579886399966
```

Увеличение количества элементов в `100` раз привело к тому, что для поиска всех элементов списку потребовалось целых полчаса, в то время как словарю и множеству — менее секунды.



Реализация [[Тип данных dict]] – пример компромисса, когда жертвуют памятью ради скорости: накладные расходы словаря в части памяти велики, зато доступ производится быстро независимо от размера словаря. При обработке большого количества записей лучше хранить их в списке кортежей, а не в списке словарей. Замена словарей кортежами значительно снижает потребление памяти.

Приведенный ниже код:

```python
from pympler import asizeof

tuples = [('Python', 1991) for _ in range(1000000)]
dicts = [{'Python': 1991} for _ in range(1000000)]

tuples_size = asizeof.asizeof(tuples)
dicts_size = asizeof.asizeof(dicts)

print('Размер списка с кортежами', tuples_size, 'байт')
print('Размер списка с словарями', dicts_size, 'байт')
```

выводит:

```no-highlight
Размер списка с кортежами 8448872 байт
Размер списка с словарями 240448816 байт
```

В примере выше список, содержащий словари, занимает примерно в `30` раз больше памяти, чем список, содержащий кортежи.

## Изменяемые ключи

При работе со словарями и множествами важно, чтобы ключи были неизменяемыми объектами. В противном случае мы можем попасть в ситуацию, когда не сможем найти соответствующее значение для изменившегося ключа.

Приведенный ниже код:

```python
class Key:
    def __init__(self, data):
        self.data = data
        
    def __repr__(self):
        return f'Key({repr(self.data)})'
    
    def __hash__(self):
        return hash(self.data)
    
    def __eq__(self, other):
        if isinstance(other, Key):
             return self.data == other.data
        return NotImplemented


data = {}

key = Key('one')
  
data[key] = 1                # добавляем в словарь
key.data = 'один'            # изменяем ключ

print(key in data)           # ищем в словаре
```

выводит:

```no-highlight
False
```

## Подводные камни и обратная сторона реализации

Иногда при работе со словарями можно наткнуться на неочевидное поведение, связанное с их внутренней реализацией.

Приведенный ниже код:

```python
data = {}

data[True] = 'yes'
data[1] = 'no'
data[1.0] = 'maybe'

print(data)
```

выводит:

```no-highlight
{True: 'maybe'}
```

вместо ожидаемого:

```no-highlight
{True: 'yes', 1: 'no', 1.0: 'maybe'}
```

Причина такого поведения связана с тем, что Python считает объекты `True, 1` и `1.0` равными, более того, их хеш-значения также равны.

Приведенный ниже код:

```python
print(True == 1 == 1.0)
print(hash(True) == hash(1) == hash(1.0))
```

 выводит:

```no-highlight
True
True
```

Когда в словарь добавляются значения по ключам `1` и `1.0`, Python просто перезаписывает значение по ключу `True`. Это своего рода оптимизация, ведь если ключи считаются равными, то зачем тратить время на их обновление.

Аналогичное поведение ожидает нас и при работе с множествами.

Приведенный ниже код:

```python
data = set()

data.add(True)
data.add(1)
data.add(1.0)

print(data)
```

выводит:

```no-highlight
{True}
```



 Нужно помнить, что класс [[Тип данных bool|bool]] является наследником класса [[Тип данных int|int]], а значит, значения `False` и `True` ведут себя как значения `0` и `1` почти во всех контекстах, за исключением, быть может, преобразования в строку.