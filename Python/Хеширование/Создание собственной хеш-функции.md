

Создание хорошей хеш-функции задача не из простых. Однако попытка создать хеш-функцию с нуля — отличный способ узнать, как работает хеширование.

**1 версия хеш-функции.** Хеш-функция перебирает все символы переданной строки и для каждого символа вычисляет его номер в таблице Unicode с помощью функции `ord()`, а затем вычисляет сумму всех полученных номеров:

```python
def hash_function(obj):
    return sum(ord(character) for character in obj)
```

Приведенный ниже код:

```python
print(hash_function('Python'))
```

выводит:

```no-highlight
642
```

Такая реализации хеш-функции содержит серьезную проблему, она работает только со строковым аргументом.

**2 версия хеш-функции.** Хеш-функция сначала преобразует переданный объект в строку с помощью функции `str()`, а затем выполняет указанное выше преобразование:

```python
def hash_function(obj):
    return sum(ord(character) for character in str(obj))
```

Приведенный ниже код:

```python
print(hash_function('Python'))
print(hash_function(123))
print(hash_function(12.34))
print(hash_function(None))
print(hash_function(True))
```

выводит:

```no-highlight
642
150
248
400
416
```

Теперь хеш-функция работает с объектом любого типа. Однако новая версия хеш-функции все еще содержит проблемы. Очевидно, что небольшое изменение начальных данных мало влияет на итоговое хеш-значение. В этом несложно убедиться, если поменять последний символ переданной строки.

Приведенный ниже код:

```python
print(hash_function('Python'))
print(hash_function('Pythoo'))
print(hash_function('Pythop'))
```

выводит:

```no-highlight
642
643
644
```

Также функция нечувствительна к порядку символов во входных данных, а это значит, что анаграммы одного и того же слова, такие как `Python` и `yPthon`, приводят к возникновению коллизий.

Приведенный ниже код:

```python
print(hash_function('Python'))
print(hash_function('yPthon'))
print(hash_function('thonPy'))
```

выводит:

```no-highlight
642
642
642
```

Чтобы решить указанные проблемы, можно использовать не только порядковый номер символа в таблице Unicode, но и его позицию (индекс) в начальных данных.

**3 версия хеш-функции.** Здесь мы берем сумму произведений, полученных путем умножения порядковых значений символов и их соответствующих индексов. Обратите внимание, что мы нумеруем индексы с единицы, а не с нуля, в противном случае первый символ всегда будет отбрасываться, так как его значение будет умножаться на ноль:

```python
def hash_function(obj):
    return sum(index * ord(character) for index, character in enumerate(str(obj), start=1))
```

Приведенный ниже код:

```python
print(hash_function('Python'))
print(hash_function('yPthon'))
print(hash_function('thonPy'))
```

выводит:

```no-highlight
2301
2260
2223
```

Теперь наша хеш-функция довольно универсальна и не приводит к возникновению большого количества коллизий. Можно заметить, что чем больше входные данные, тем больше будет хеш-значение.

Приведенный ниже код:

```python
print(hash_function('Python'))
print(hash_function('Beegeek'*1000))
print(hash_function('Stepik'*10000000))
```

выводит:

```no-highlight
2301
2380463000
187200003610000000
```

Мы всегда можем справиться с неограниченным ростом с помощью оператора `%`:

```python
def hash_function(obj):
    return sum(index * ord(character) for index, character in enumerate(str(obj), start=1)) % 123456761
```

Приведенный ниже код:

```python
print(hash_function('Python'))
print(hash_function('Beegeek'*1000))
print(hash_function('Stepik'*10000000))
```

выводит:

```no-highlight
2301
34784541
116170254
```

Использование оператора `%` позволяет загнать вычисляемое хеш-значение в нужный диапазон. В нашем случае получаем, что хеш-значения будут в диапазоне `[0; 123456761)`. Однако нужно помнить, что выбор меньшего пула хеш-значений увеличивает вероятность возникновения коллизий. В качестве максимального количества хеш-значения рекомендуется использовать большую константу (желательно простое число).

Из существенных минусов нашей хеш-функции остается медленная скорость работы при больших входных данных. Подумайте над тем, как можно ее оптимизировать.