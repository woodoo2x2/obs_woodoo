## Возбуждение исключений

До сих пор мы позволяли интерпретатору Python возбуждать исключения, совершая преднамеренно ошибки. Однако мы можем заставить и наш код также возбудить исключение.

Для возбуждения исключения используется оператор `raise`. В качестве аргумента оператор `raise` использует экземпляр класса, унаследованного от `Exception`. Класс указывает на тип исключения, а аргумент, передаваемый конструктору этого исключения, обычно описывает подробности возникновения исключительной ситуации.

Если возбуждаемые пользователем исключения не перехватываются, то они распространяются вплоть до стандартного обработчика исключений и прекращают работу программы с выводом стандартного сообщения об ошибке.

![](https://ucarecdn.com/94f108bd-fd4b-4cd3-867e-cb7e5e1b5f45/)Возбуждаемые пользователем исключения перехватываются тем же способом, что и исключения, которые возбуждает интерпретатор Python.

Приведенный ниже код:

```python
try:
    raise IndexError('ошибочка')             # возбуждение исключения вручную
except Exception as err:
    print(err)
    print(type(err)) 
```

выводит:

```1c
ошибочка
<class 'IndexError'>
```

Приведем еще один пример:

```python
def get_month_name(index):
    if not index.isdigit():
        raise TypeError('Аргумент должен быть числом.')
    if int(index) < 1 or int(index) > 12:
        raise ValueError('Аргумент должен быть целым числом от 1 до 12.')
     ...
```

При создании объекта исключения мы можем указать в конструкторе подробности возникновения исключительной ситуации. Конструктор любого исключения принимает переменное количество аргументов. Для того чтобы получить указанные значения, мы используем атрибут `args`, который является кортежем.

Приведенный ниже код:

```python
try:
    x, y = 10, 0
    if y == 0:
        raise ZeroDivisionError('Произошло деление на ноль.')
except ZeroDivisionError as err:
    print(err)
    print(err.args)
    print(type(err.args))
```

выводит:

```no-highlight
Произошло деление на ноль.
('Произошло деление на ноль.',)
<class 'tuple'>
```

![](https://ucarecdn.com/2ea86077-990e-427a-b67d-82cd76aa4921/)   При печати объекта исключения автоматически происходит вызов функции `str()`.

Оператор возбуждения исключений `raise` имеет несколько вариантов формата:

- `raise` <экземпляр класса>
- `raise` <название класса>
- `raise` <экземпляр или название класса> `from` <объект исключения>
- `raise`

**В первом варианте** оператора `raise` указывается экземпляр класса возбуждаемого исключения с аргументами при необходимости.

Пример:

```python
raise ValueError('Oпиcaниe исключения')
```

**Во втором варианте** оператора `raise` указывается только название класса исключения.

Пример:

```python
raise ValueError                       # эквивалентно: raise ValueError()
```

**В третьем варианте** оператора `raise` сначала указывается экземпляр класса или просто название класса, а потом объект исключения, на основании которого создается новое исключение. В этом случае объект исходного исключения сохраняется в атрибуте `__cause__`. При обработке вложенных исключений эти данные используются для вывода информации не только о последнем исключении, но и о первоначальном исключении.

Пример:

```python
try:
    х = 1 / 0
except Exception as err:
   raise ZeroDivisionError('Описание исключения') from err
```

## Повторное возбуждение исключения

**В четвертом варианте** оператора `raise` мы повторно возбуждаем и пробрасываем выше последнее перехваченное исключение.

Пример:

```python
try:
    х = 1 / 0
except Exception as err:
    print(err)                  # каким-то образом обработали перехваченное исключение
    raise                       # пробрасываем исключение выше
```

## Примечания

**Примечание 1.** Возбуждение исключения в коде похоже на `return`, только на его глобальную версию, завершающую все функции в порядке, обратном тому, в котором они вызывались. Если исключение будет возбуждено, но не будет перехвачено, то есть как-то обработано, вся программа так и завершится.

**Примечание 2.** Сам механизм исключений достаточно медленный, поэтому, например, не очень хорошей идеей будет возбуждать исключение внутри цикла, когда мы точно знаем, что их будет достаточно большое количество.

**Примечание 3.** В ситуации, когда мы перехватываем исключение, делаем некие действия, а затем пробрасываем его выше, нужно использовать следующий код:

```python
try:
    х = 1 / 0
except Exception as err:
    print(err)                  # каким-то образом обработали перехваченное исключение
    raise                       # пробрасываем исключение выше
```

Использовать код:

```python
try:
    х = 1 / 0
except Exception as err:
    print(err)
    raise err
```

не рекомендуется, так как мы получим возбуждение нового исключения, пусть даже и представляющего старый объект. Возбуждение нового исключения повлечет за собой потерю информации о месте возникновения изначального исключения.

Просто пишите `raise` — так будет заново возбуждено последнее перехваченное исключение с сохранением нужной информации.

**Примечание 4.** Как уже говорилось ранее, при создании объекта исключения мы можем указать в конструкторе подробности возникновения исключительной ситуации. Конструктор исключения принимает переменное количество аргументов.

Приведенный ниже код:

```python
try:
    raise ValueError('Произошла ошибка')
except ValueError as e:
    print(e)
```

выводит:

```python
Произошла ошибка
```

Примечательно то, что при передаче переменной с исключением в функцию `print()` происходит вывод именно тех аргументов, которые были указаны при создании объекта исключения. И если таких аргументов было передано несколько, они будут выведены все в виде кортежа.

Приведенный ниже код:

```python
try:
    raise ValueError('Ой', 'Произошла ошибка')
except ValueError as e:
    print(e)
```

выводит:

```no-highlight
('Ой', 'Произошла ошибка')
```