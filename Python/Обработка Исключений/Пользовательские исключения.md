## Пользовательские исключения

В Python можно создавать собственные типы исключений. Такая практика позволяет увеличить гибкость процесса обработки ошибок в рамках той предметной области, для которой написана программа.

Для создания собственного типа исключения необходимо создать класс, являющийся потомком (наследником) одного из уже существующего типа исключения. Как уже было сказано в прошлом уроке, самым верным вариантом является класс `Exception`.

Приведенный ниже код:

```python
class NegativeAgeError(Exception):
    pass
```

описывает новый тип исключения с именем `NegativeAgeError`, который является потомком класса `Exception`. Класс `Exception` содержит весь необходимый функционал, позволяющий работать с исключениями, поэтому в большинстве случаев достаточно создать пустой класс, который является потомком класса `Exception`. Теперь мы можем работать с типом исключения `NegativeAgeError`, как с любым встроенным.

Приведенный ниже код:

```python
try:
    print('Введите свой возраст')
    age = int(input())
    if age < 0:
        raise NegativeAgeError('Возраст не может быть отрицательным')
    print('Ваш возраст равен', age)
except ValueError:
    print('Возраст должен быть числом')
except NegativeAgeError as e:
    print(e)
```

при вводе некорректных значений приводит к возбуждению соответствующих типов исключений:

- `ValueError` – при нечисловых значениях 
- `NegativeAgeError` – при отрицательных числовых значениях

## Методики LBYL и EAFP

При написании программного кода, который может потенциально возбуждать исключения, существуют два основных подхода:

- **LBYL (Look Before You Leap)** — посмотри перед прыжком
- **EAFP (Easier to Ask Forgiveness than Permission)** — проще извиниться, чем спрашивать разрешение

Приведенный ниже код

```python
data = {'Timur': 29, 'Ivan': 54}

data['Anri'] += 1
```

приводит к возникновению исключения `KeyError`, поскольку ключ `Anri` отсутствует в словаре.

Мы можем исправить такой код двумя способами.

**Способ 1.** Перестраховаться и заранее проверить, что все получится. Это идеология LBYL-подхода. Сначала посмотрели, убедились, что все в порядке, только потом сделали.

```python
data = {'Timur': 29, 'Ivan': 54}

if 'Anri' in data:
    data['Anri'] += 1
else:
    print('Ключ Anri отсутствует в словаре.')
```

![](https://ucarecdn.com/133adce1-c25e-4df2-b1c1-47071dd116d7/)Аналогия с LBYL-подходом такая: поглядели на светофор, потом по сторонам. Если горит зеленый свет и нет препятствий, можно переходить.

**Способ 2.** Мы можем описывать только главный алгоритм, рассчитывая, что все будет хорошо. Но при таком подходе необходимо прописать действия с исключениями (иногда разных типов). Это суть подхода EAFP.

```python
data = {'Timur': 29, 'Ivan': 54}

try:
    data['Anri'] += 1
except KeyError:
    print('Ключ Anri отсутствует в словаре.')
```

![](https://ucarecdn.com/f00caaae-9f77-420b-984c-4c8edb3993a7/)   Python также предоставляет третий способ исправления кода с помощью метода `get()`.

В Python, скорее, преобладает подход EAFP, поэтому Python полагается на то, что исключения будут обработаны после их возникновения. И хотя такой подход может показаться рискованным, при разумном использовании исключений код получается менее громоздким и лучше читается, а ошибки обрабатываются только в случае их возникновения. И пусть подход EAFP выглядит более выигрышным, это не значит, что методику LBYL вообще нельзя использовать.