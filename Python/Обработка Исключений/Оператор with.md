

Подход, основанный на использовании конструкции `try-finally`, для освобождения внешних ресурсов рабочий, однако достаточно громоздкий. При его использовании мы пишем один и тот же код каждый раз, когда нам нужно освободить ресурс.

В Python для удобного и своевременного освобождения ресурсов есть специальный оператор `with`.

Приведенный ниже код:

```python
file = open('output.txt', mode='w', encoding='utf-8')

try:
    file.write('Python generation!')
finally:
    file.close()
```

можно переписать с использованием оператора `with` в виде:

```python
with open('output.txt', mode='w', encoding='utf-8') as file:
    file.write('Python generation!')
```

Как мы видим, явные вызовы метода `close()` пропали, однако при этом файл закрывается надёжно и вовремя. Помимо надежного и своевременного закрытия файла, код с использованием `with` выглядит понятнее и короче, а также не содержит ненужный шаблонный код.

Оператор `with` является своего рода синтаксическим сахаром), и за кулисами разворачивается практически тот же самый блок `try-finally`.

Объект, которым управляет оператор `with`, не обязательно должен создаваться в нем. Приведенный выше код можно переписать в виде:

```python
file = open('output.txt', mode='w', encoding='utf-8')

with file:
    file.write('Python generation!')
```

Оператор `with` также может управлять сразу несколькими объектами.

Приведенный ниже код:

```python
with open('file.txt', encoding='utf-8') as file, open('output.txt', mode='w', encoding='utf-8') as output:
    for index, line in enumerate(file, 1):
        output.write(f'{index}. {line}')
```

нумерует строки файла `file.txt` и записывает их в файл `output.txt`.

При наличии нескольких объектов в операторе `with` они обрабатываются так, как если бы несколько операторов `with` были вложенными.

Приведенный выше код равнозначен коду:

```python
with open('file.txt', encoding='utf-8') as file:
    with open('output.txt', mode='w', encoding='utf-8') as output:
        for index, line in enumerate(file, 1):
            output.write(f'{index}. {line}')
```

Общий шаблон использования оператора `with` выглядит следующим образом:

```python
with EXPRESSION as TARGET:
    # это тело with блока
    # здесь нам доступен ресурс TARGET

# здесь ресурс TARGET уже освобождён, даже если в теле with блока было возбуждено исключение
```

Весь код в теле `with` блока работает как бы в одном контексте. Чаще всего контекст подразумевает выделение некоторого ресурса, например, файла. По выходу из контекста ресурс автоматически освобождается, даже если при выполнении блока было возбуждено исключение. Обратите внимание на то, что использовать ключевое слово `as` при работе с оператором `with` **необязательно**.

 Оператор `with` работает не со всеми объектами. Для того, чтобы иметь возможность использовать некоторый объект в операторе `with`, этот объект должен удовлетворять **протоколу контекстного менеджера**, о котором подробно будет рассказано в следующем уроке.

Несмотря на то, что оператор `with` короче использования конструкции `try-finally`, он все же менее универсален. Мы можем использовать оператор `with` только с объектами, поддерживающими протокол контекстного менеджера, в то время как конструкция `try-finally` позволяет выполнять действия по очистке произвольных объектов без необходимости поддержки какого-либо протокола.

Встроенная функция `open()` возвращает специальный файловый объект (тип `TextIOWrapper`), который напрямую взаимодействует с операционной системой. Количество таких объектов в каждой операционной системе ограничено, поэтому очень важно их своевременно освобождать.

Приведенный ниже код:

```python
files = []

for _ in range(100_000):
    files.append(open('output.txt', mode='w', encoding='utf-8'))
```

на операционной системе Windows приводит к возбуждению исключения:

```no-highlight
OSError: [Errno 24] Too many open files: 'output.txt'
```

Атрибут `closed` экземпляров типа `TextIOWrapper` позволяет проверить состояние закрытости файла.

Приведенный ниже код:

```python
file = open('output.txt', mode='w', encoding='utf-8')

with file:
    print(file.closed)

print(file.closed)
```

выводит:

```no-highlight
False
True
```

С помощью методов `readable()` и `writable()` мы можем определить возможность чтения и записи из файла.

Приведенный ниже код:

```python
with open('output.txt', mode='w', encoding='utf-8') as file:
    print(file.readable(), file.writable())
    
with open('output.txt', mode='r', encoding='utf-8') as file:
    print(file.readable(), file.writable())
```

выводит:

```no-highlight
False True
True False
```

Мы можем использовать оператор `with` вместе с конструкцией `try-except-finally` при необходимости. Это может быть полезным при обработке исключений, связанных с открытием несуществующих файлов:

```python
try:
    with open('file.txt', encoding='utf-8') as file:
        print(file.read())
except Exception as error:
    print(f'Произошла ошибка {error}')
```

В данном примере, в случае, если файла `file.txt` не существует, будет возбуждено исключение, которое будет перехвачено в блоке `except`.

 Начиная с версии Python 3.10 мы можем использовать круглые скобки при использовании оператора `with`, который управляет сразу несколькими объектами. Это позволяет форматировать длинную коллекцию диспетчеров контекста в несколько строк.

Приведенный ниже код:

```python
with open('file.txt', encoding='utf-8') as file, open('output.txt', mode='w', encoding='utf-8') as output:
    for index, line in enumerate(file, 1):
        output.write(f'{index}. {line}')
```

можно переписать в виде:

```python
with (
    open('file.txt', encoding='utf-8') as file, 
    open('output.txt', mode='w', encoding='utf-8') as output
):
    for index, line in enumerate(file, 1):
        output.write(f'{index}. {line}')
```