Функция `ROW_NUMBER()` вычисляет порядковый номер записи в рамках указанного окна (начиная с `1`). В качестве примера ее использования напишем запрос, который извлекает полные имена всех сотрудников, а также дополнительно их пронумеровывает.

Результатом приведенного ниже запроса:

```sql
SELECT full_name,
       ROW_NUMBER() OVER all_rows AS row_num
FROM Employees
WINDOW all_rows AS ();
```

является:

```no-highlight
+-----------------+---------+
| full_name       | row_num |
+-----------------+---------+
| Sergey Brin     | 1       |
| John Doerr      | 2       |
| Larry Page      | 3       |
| Eric Schmidt    | 4       |
| Sundar Pichai   | 5       |
| Marissa Mayer   | 6       |
| Susan Wojcicki  | 7       |
| John Smith      | 8       |
| Sheryl Sandberg | 9       |
| Alice Johnson   | 10      |
+-----------------+---------+
```

Итак, запрос выше включает определение окна с именем `all_rows`. Данное окно имеет пустую спецификацию, поэтому его содержимое полностью совпадает с результирующим набором:

```no-highlight
+----+-----------------+-------------+--------+
| id | full_name       | department  | salary |
+----+-----------------+-------------+--------+
| 1  | Sergey Brin     | Engineering | 10000  |
| 2  | John Doerr      | Sales       | 10000  |
| 3  | Larry Page      | Engineering | 7000   |
| 4  | Eric Schmidt    | Marketing   | 8000   |
| 5  | Sundar Pichai   | Sales       | 11000  |
| 6  | Marissa Mayer   | Marketing   | 9000   |
| 7  | Susan Wojcicki  | Engineering | 8000   |
| 8  | John Smith      | Engineering | 7000   |
| 9  | Sheryl Sandberg | Marketing   | 9000   |
| 10 | Alice Johnson   | Engineering | 10000  |
+----+-----------------+-------------+--------+
```

Записи в окне `all_rows`, как и в результирующем наборе, могут располагаться в произвольном порядке, однако в данном случае они располагаются в том же порядке, что и в таблице `Employees`.

Запись `ROW_NUMBER() OVER all_rows` означает применение функции `ROW_NUMBER()` к окну `all_rows`. Запись состоит из вызова оконной функции, ключевого слова `OVER` и имени окна, к которому должна быть применена функция.

Для каждой рассматриваемой извлекающим запросом записи функция `ROW_NUMBER()` определяет ее порядковый номер в рамках окна `all_rows` и возвращает полученный результат, который затем указывается в поле `row_num`. Например, если извлекающий запрос рассматривает первую запись таблицы `Employees` (`id = 1`), то для такой записи вызов функции `ROW_NUMBER()` по отношению к окну `all_rows` вернет значение `1`, поскольку в окне `all_rows` эта запись располагается на первом месте.

Определение порядкового номера записи в рамках окна, в котором не определен строгий порядок, не имеет большого смысла. Поэтому воспользуемся одним из элементов спецификации окна — упорядочиванием, и напишем запрос, который извлекает полные имена и зарплаты всех сотрудников, а также дополнительно пронумеровывает их в порядке уменьшения зарплаты.

Результатом приведенного ниже запроса:

```sql
SELECT full_name, salary,
       ROW_NUMBER() OVER salary_desc AS row_num
FROM Employees
WINDOW salary_desc AS (ORDER BY salary DESC);
```

является:

```no-highlight
+-----------------+--------+---------+
| full_name       | salary | row_num |
+-----------------+--------+---------+
| Sundar Pichai   | 11000  | 1       |
| Sergey Brin     | 10000  | 2       |
| John Doerr      | 10000  | 3       |
| Alice Johnson   | 10000  | 4       |
| Marissa Mayer   | 9000   | 5       |
| Sheryl Sandberg | 9000   | 6       |
| Eric Schmidt    | 8000   | 7       |
| Susan Wojcicki  | 8000   | 8       |
| Larry Page      | 7000   | 9       |
| John Smith      | 7000   | 10      |
+-----------------+--------+---------+
```

Несложно заметить, что упорядочивание окна выполняется достаточно просто, поскольку использует уже знакомый синтаксис оператора `ORDER BY`. Так, в примере выше определяется окно с именем `salary_desc`, содержимое которого состоит из всех записей результирующего набора, расположенных в порядке убывания значения поля `salary`:

```no-highlight
+----+-----------------+-------------+--------+
| id | full_name       | department  | salary |
+----+-----------------+-------------+--------+
| 5  | Sundar Pichai   | Sales       | 11000  |
| 1  | Sergey Brin     | Engineering | 10000  |
| 2  | John Doerr      | Sales       | 10000  |
| 10 | Alice Johnson   | Engineering | 10000  |
| 6  | Marissa Mayer   | Marketing   | 9000   |
| 9  | Sheryl Sandberg | Marketing   | 9000   |
| 4  | Eric Schmidt    | Marketing   | 8000   |
| 7  | Susan Wojcicki  | Engineering | 8000   |
| 3  | Larry Page      | Engineering | 7000   |
| 8  | John Smith      | Engineering | 7000   |
+----+-----------------+-------------+--------+
```

Функция `ROW_NUMBER()`, применяемая к окну `salary_desc`, для каждой рассматриваемой извлекающим запросом записи определяет ее порядковый номер в рамках окна и возвращает полученный результат, который затем указывается в поле `row_num`. Например, если извлекающий запрос рассматривает пятую запись таблицы `Employees` (`id = 5`), то для такой записи вызов функции `ROW_NUMBER()` по отношению к окну `salary_desc` вернет значение `1`, поскольку в окне `salary_desc` эта запись располагается на первом месте.


Оператор `ORDER BY` в спецификации окна определяет порядок записей лишь внутри окна. Порядок в результате запроса может совпадать с порядком, определенным в спецификации окна, однако полагаться на это не нужно.

Рассмотрим еще один элемент спецификации окна — секционирование. Оно используется для разбиения окна на **секции** по определенному полю (или нескольким полям). Две записи окна попадают в одну секцию, если их значения по выбранному полю (или нескольким полям) совпадают. Важность секционирования заключается в том, что если окно разбито на секции, то применяемая к этому окну функция будет работать не со всем его содержимым, а лишь с определенной секцией.

В качестве примера использования секционирования напишем запрос, который извлекает полные имена и названия отделов всех сотрудников, а также дополнительно пронумеровывает их в рамках своего отдела.

Результатом приведенного ниже запроса:

```sql
SELECT full_name, department,
       ROW_NUMBER() OVER part_by_department AS row_num
FROM Employees
WINDOW part_by_department AS (PARTITION BY department);
```

является:

```no-highlight
+-----------------+-------------+---------+
| full_name       | department  | row_num |
+-----------------+-------------+---------+
| Sergey Brin     | Engineering | 1       |
| Larry Page      | Engineering | 2       |
| Susan Wojcicki  | Engineering | 3       |
| John Smith      | Engineering | 4       |
| Alice Johnson   | Engineering | 5       |
| Eric Schmidt    | Marketing   | 1       |
| Marissa Mayer   | Marketing   | 2       |
| Sheryl Sandberg | Marketing   | 3       |
| John Doerr      | Sales       | 1       |
| Sundar Pichai   | Sales       | 2       |
+-----------------+-------------+---------+
```

Как видно, секционирование выполняется с помощью оператора `PARTITION BY`, после которого перечисляются все поля, по которым должно быть произведено разбиение на секции. Здесь содержимое окна `part_by_department` разбивается на секции по одному полю `department`:

```no-highlight
+----+-----------------+-------------+--------+
| id | full_name       | department  | salary |
+----+-----------------+-------------+--------+
| 1  | Sergey Brin     | Engineering | 10000  | ┐
| 3  | Larry Page      | Engineering | 7000   | │
| 7  | Susan Wojcicki  | Engineering | 8000   | │
| 8  | John Smith      | Engineering | 7000   | │
| 10 | Alice Johnson   | Engineering | 10000  | ┘
| 4  | Eric Schmidt    | Marketing   | 8000   | ┐
| 6  | Marissa Mayer   | Marketing   | 9000   | │
| 9  | Sheryl Sandberg | Marketing   | 9000   | ┘
| 2  | John Doerr      | Sales       | 10000  | ┐
| 5  | Sundar Pichai   | Sales       | 11000  | ┘
+----+-----------------+-------------+--------+
```

Функция `ROW_NUMBER()`, применяемая к окну `part_by_department`, для каждой рассматриваемой извлекающим запросом записи определяет ее порядковый номер в рамках определенной секции окна и возвращает полученный результат, который затем указывается в поле `row_num`. Выбор секции зависит от того, какое значение рассматриваемая запись содержит в поле, которое было использовано при секционировании. В нашем случае это поле `department`.

Например, если извлекаемый запрос рассматривает шестую запись таблицы `Employees` (`id = 6`), то для такой записи вызов функции `ROW_NUMBER()` по отношению к окну `part_by_department` вернет значение `2`, поскольку в соответствующей секции окна `part_by_department` эта запись располагается на втором месте.

Формально окно всегда считается разбитым на секции, просто если секционирование не выполняется явно, то секцией является все окно целиком.

Определяемое окно можно секционировать и упорядочивать одновременно, однако в данном случае оператор `ORDER BY` будет определять порядок следования записей в рамках секции, а не всего окна. В качестве такого примера напишем запрос, который извлекает полные имена и названия отделов всех сотрудников, а также дополнительно пронумеровывает их в рамках отдела в порядке уменьшения зарплаты.

Результатом приведенного ниже запроса:

```sql
SELECT full_name, department, salary,
       ROW_NUMBER() OVER salary_desc_part_by_department AS row_num
FROM Employees
WINDOW salary_desc_part_by_department AS (PARTITION BY department ORDER BY salary DESC);
```

является:

```no-highlight
+-----------------+-------------+--------+---------+
| full_name       | department  | salary | row_num |
+-----------------+-------------+--------+---------+
| Sergey Brin     | Engineering | 10000  | 1       |
| Alice Johnson   | Engineering | 10000  | 2       |
| Susan Wojcicki  | Engineering | 8000   | 3       |
| Larry Page      | Engineering | 7000   | 4       |
| John Smith      | Engineering | 7000   | 5       |
| Marissa Mayer   | Marketing   | 9000   | 1       |
| Sheryl Sandberg | Marketing   | 9000   | 2       |
| Eric Schmidt    | Marketing   | 8000   | 3       |
| Sundar Pichai   | Sales       | 11000  | 1       |
| John Doerr      | Sales       | 10000  | 2       |
+-----------------+-------------+--------+---------+
```

Если определение окна включает как секционирование, так и упорядочивание, то оператор `PARTITION BY` должен располагаться до оператора `ORDER BY`.